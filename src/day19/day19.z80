; program /Users/joerg/Projects/NetBeans/aoc24/src/day19/day19.pas
CPM:            equ     1               ; Target is CP/M
                device  NOSLOT64K
                org     $0100
TEXT:           jp      __init
LIMIT:          =       $F000
; [0] (* ===================================================================== *)
; [1] (* === CP/M run-time library =========================================== *)
; [2] (* ===================================================================== *)
; [3] 
; [4] {$i system.pas  }
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] {$a+}
; [3] 
; [4] {$l system.asm}
                include "/Users/joerg/Projects/pasta80/rtl/system.asm"
; [5] 
; [6] (* -------------------------------------------------------------------------- *)
; [7] (* --- String support ------------------------------------------------------- *)
; [8] (* -------------------------------------------------------------------------- *)
; [9] 
; [10] (* Built-in: procedure Val(S: String; var Scalar; var E: Integer); *)
; [11] (* Built-in: procedure Str(N: Scalar; var S: String);              *)
; [12] 
; [13] procedure Delete(var S: String; Start, Count: Integer);     external '__delete';
; [14] procedure Insert(S: String; var T: String; Start: Integer); external '__insert';
; [15] 
; [16] (* Built-in: function Concat(S: String, ...): String;              *)
; [17] 
; [18] function Copy(S: String; Start, Count: Integer): String;    external '__copy';
; [19] function Length(S: String): Integer;                        external '__length';
; [20] function Pos(S, T: String): Integer;                        external '__pos';
; [21] 
; [22] (* -------------------------------------------------------------------------- *)
; [23] (* --- Set support ---------------------------------------------------------- *)
; [24] (* -------------------------------------------------------------------------- *)
; [25] 
; [26] (* Built-in: procedure Include(var S: Set; E: Element);     *)
; [27] (* Built-in: procedure Exclude(var S: Set; E: Element);     *)
; [28] 
; [29] (* -------------------------------------------------------------------------- *)
; [30] (* --- File support --------------------------------------------------------- *)
; [31] (* -------------------------------------------------------------------------- *)
; [32] 
; [33] (* TBD *)
; [34] 
; [35] (* -------------------------------------------------------------------------- *)
; [36] (* --- Heap management ------------------------------------------------------ *)
; [37] (* -------------------------------------------------------------------------- *)
; [38] 
; [39] type
; [40]   PBlock = ^TBlock;
; [41]   TBlock = record
; [42]     Next: PBlock;
; [43]     Size: Integer;
; [44]   end;
; [45] 
; [46] var
; [47]   HeapPtr: PBlock absolute '__heapptr';
; [48] 
; [49] (* Built-in: procedure New(var P: Pointer);       *)
; [50] (* Built-in: procedure Dispose(P: Pointer);       *)
; [51] 
; [52] procedure FreeMem(P: Pointer; Size: Integer);     register; external '__freemem';
; [53] procedure GetMem(var P: Pointer; Size: Integer);  register; external '__getmem';
; [54] 
; [55] function MemAvail: Integer;
; [56] var
                if      __USE__MemAvail7
; [57]   P: PBlock;
global8:        ds      2,0             ; Global P
; [58]   I: Integer;
global9:        ds      2,0             ; Global I
; [59] begin
; var MemAvail(@RESULT), P(@global8), I(@global9)
__MemAvail7:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [60]   P := HeapPtr;
                push    hl
                ld      hl,global8 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [61]   I := 0;
                ld      hl,global9 + 0
                ld      de,0
                ld      (hl),de
; [62]   while P <> nil do
while11:
                ld      hl,(global8 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [63]   begin
                bit     0,l
                jp      z,false12
; [64]     I := I + P^.Size;
                ld      hl,global9 + 0
                push    hl
                ld      hl,(global9 + 0)
                push    hl
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [65]     P := P^.Next;
                ld      hl,global8 + 0
                push    hl
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [66]   end;
                jp      while11
false12:
; [67] 
; [68]   MemAvail := I;
                ld      hl,(display+2)  ; Local MemAvail
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global9 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [69] end;
exit10:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [70] 
; [71] function MaxAvail: Integer;
; [72] var
                if      __USE__MaxAvail13
; [73]   P: PBlock;
global14:       ds      2,0             ; Global P
; [74]   I: Integer;
global15:       ds      2,0             ; Global I
; [75] begin
; var MaxAvail(@RESULT), P(@global14), I(@global15)
__MaxAvail13:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [76]   P := HeapPtr;
                push    hl
                ld      hl,global14 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [77]   I := 0;
                ld      hl,global15 + 0
                ld      de,0
                ld      (hl),de
; [78]   while P <> nil do
while17:
                ld      hl,(global14 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [79]   begin
                bit     0,l
                jp      z,false18
; [80]     if P^.Size > I then I := P^.Size;
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                ld      hl,(global15 + 0)
                call    __int16_lt
                and     a
                jp      z,false19
                ld      hl,global15 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false19:
; [81]     P := P^.Next;
                ld      hl,global14 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [82]   end;
                jp      while17
false18:
; [83] 
; [84]   MaxAvail := I;
                ld      hl,(display+2)  ; Local MaxAvail
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global15 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [85] end;
exit16:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [86] 
; [87] procedure InitHeap;
; [88] var
                if      __USE__InitHeap20
; [89]   EofMarker: Integer absolute 'eof';
; [90]   HeapStart, HeapBytes: Integer;
global21:       ds      2,0             ; Global HeapStart
global22:       ds      2,0             ; Global HeapBytes
; [91] begin
; var EofMarker(@eof), HeapStart(@global21), HeapBytes(@global22)
__InitHeap20:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
; [92]   HeapStart := Addr(EofMarker);
                push    hl
                ld      hl,global21 + 0
                push    hl
                ld      hl,eof + 0
                ex      de,hl
                pop     hl
                ld      (hl),de
; [93]   if (HeapStart >= 0) and (HeapStart < 24576) then HeapStart := 24576;
                ld      hl,(global21 + 0)
                ld      de,0
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(global21 + 0)
                ld      de,24576
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false24
                ld      hl,global21 + 0
                ld      de,24576
                ld      (hl),de
false24:
; [94]   HeapBytes := 57343 - HeapStart;
                ld      hl,global22 + 0
                push    hl
                ld      de,57343        ; Literal 57343
                push    de
                ld      hl,(global21 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [95]   HeapPtr := nil;
                ld      hl,__heapptr + 0
                ld      de,0
                ld      (hl),de
; [96] 
; [97]   if HeapBytes > 0 then
                ld      hl,(global22 + 0)
                push    hl
                ld      hl,0            ; Literal 0
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [98]     FreeMem(Ptr(HeapStart), HeapBytes);
                bit     0,l
                jp      z,false25
                ld      hl,(global21 + 0)
                push    hl
                ld      hl,(global22 + 0)
                ex      de,hl
                pop     hl
                call    __freemem
false25:
; [99] end;
exit23:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [100] 
; [101] (* -------------------------------------------------------------------------- *)
; [102] (* --- Standard procedures -------------------------------------------------- *)
; [103] (* -------------------------------------------------------------------------- *)
; [104] 
; [105] (* Built-in: procedure Break;                   *)
; [106] (* Built-in: procedure Continue;                *)
; [107] (* Built-in: procedure Exit;                    *)
; [108] 
; [109] const
; [110]   Black   = 0;
; [111]   Blue    = 1;
; [112]   Red     = 2;
; [113]   Magenta = 3;
; [114]   Green   = 4;
; [115]   Cyan    = 5;
; [116]   Yellow  = 6;
; [117]   White   = 7;
; [118] 
; [119] 
; [120] 
; [121] (* -------------------------------------------------------------------------- *)
; [122] (* --- Arithmetic functions ------------------------------------------------- *)
; [123] (* -------------------------------------------------------------------------- *)
; [124] 
; [125] const
; [126]   MaxInt = 32767;
; [127]   MinInt = -32768;
; [128] 
; [129] (* Built-in: function Abs(I: Integer): Integer  *)
; [130] (* Built-in: function Abs(R: Real): Real        *)
; [131] 
; [132] function ArcTan(R: Real): Real; register; external 'ATN';
; [133] function Cos(R: Real): Real; register;    external 'COS';
; [134] function Exp(R: Real): Real; register;    external 'EXP';
; [135] function Frac(R: Real): Real; register;   external 'FRAC';
; [136] function Int(R: Real): Real; register;    external 'INT';
; [137] function Ln(R: Real): Real; register;     external 'LN';
; [138] function Log(R: Real): Real; register;    external 'LOG';
; [139] function Sin(R: Real): Real; register;    external 'SIN';
; [140] function Sqr(R: Real): Real; register;    external '__fltpwr2';
; [141] function Sqrt(R: Real): Real; register;   external 'SQR';
; [142] function Tan(R: Real): Real; register;    external 'TAN';
; [143] 
; [144] function Pi: Real; register;              external 'ACPI';
; [145] 
; [146] function MaxReal: Real; register; inline
__MaxReal38:
; [147] (
; [148]   $01 / $7FFF /
                db      1
                dw      32767
; [149]   $11 / $FFFF /
                db      17
                dw      65535
; [150]   $21 / $FFFF /
                db      33
                dw      65535
; [151]   $c9
; [152] );
                db      201
                ret
; [153] 
; [154] function MinReal: Real; register; inline
__MinReal39:
; [155] (
; [156]   $01 / $FFFF /
                db      1
                dw      65535
; [157]   $11 / $FFFF /
                db      17
                dw      65535
; [158]   $21 / $FFFF /
                db      33
                dw      65535
; [159]   $c9
; [160] );
                db      201
                ret
; [161] 
; [162] (* -------------------------------------------------------------------------- *)
; [163] (* --- Scalar functions ----------------------------------------------------- *)
; [164] (* -------------------------------------------------------------------------- *)
; [165] 
; [166] (* Built-in: function Pred(Ordinal): Ordinal;     *)
; [167] (* Built-in: function Succ(Ordinal): Ordinal;     *)
; [168] (* Built-in: function Odd(Ordinal): Boolean;      *)
; [169] (* Built-in: function Even(Ordinal): Boolean;     *)
; [170] 
; [171] (* -------------------------------------------------------------------------- *)
; [172] (* --- Transfer functions --------------------------------------------------- *)
; [173] (* -------------------------------------------------------------------------- *)
; [174] 
; [175] (* Built-in: function Ord(Ordinal): Integer;      *)
; [176] 
; [177] function Round(R: Real): Integer; register; external '__fltrnd';
; [178] function Trunc(R: Real): Integer; register; external 'FIX';
; [179] 
; [180] function Chr(B: Byte): Char; register; inline
__Chr42:
; [181] (
; [182]   $c9         (* ret          *)
; [183] );
                db      201
                ret
; [184] 
; [185] (* -------------------------------------------------------------------------- *)
; [186] (* --- Miscellaneous standard functions ------------------------------------- *)
; [187] (* -------------------------------------------------------------------------- *)
; [188] 
; [189] (* Built-in: function KeyPressed: Boolean;        *)
; [190] (* Built-in: function SizeOf(XYZ): Integer;       *)
; [191] (* Built-in: function Addr(XYZ): Integer;         *)
; [192] (* Built-in: function Ptr(I: Integer): Pointer;   *)
; [193] 
; [194] function Hi(I: Integer): Byte; register; inline
__Hi43:
; [195] (
; [196]   $6c /       (* ld   l,h     *)
                db      108
; [197]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [198]   $c9         (* ret          *)
; [199] );
                db      201
                ret
; [200] 
; [201] function Lo(I: Integer): Byte; register; inline
__Lo44:
; [202] (
; [203]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [204]   $c9         (* ret          *)
; [205] );
                db      201
                ret
; [206] 
; [207] function Swap(I: Integer): Integer; register; inline
__Swap45:
; [208] (
; [209]   $7c /       (* ld   a,h     *)
                db      124
; [210]   $65 /       (* ld   h,l     *)
                db      101
; [211]   $6f /       (* ld   l,a     *)
                db      111
; [212]   $c9         (* ret          *)
; [213] );
                db      201
                ret
; [214] 
; [215] function UpCase(C: Char): Char; register; inline
__UpCase46:
; [216] (
; [217]   $7d /       (* ld   a,l     *)
                db      125
; [218]   $fe / $61 / (* cp   'a'     *)
                db      254,97
; [219]   $d8 /       (* ret  c       *)
                db      216
; [220]   $fe / $7b / (* cp   'z' + 1 *)
                db      254,123
; [221]   $d0 /       (* ret  nc      *)
                db      208
; [222]   $cb / $ad / (* res  4,l     *)
                db      203,173
; [223]   $c9         (* ret          *)
; [224] );
                db      201
                ret
; [225] 
; [226] function LoCase(C: Char): Char; register; inline
__LoCase47:
; [227] (
; [228]   $7d /       (* ld   a,l     *)
                db      125
; [229]   $fe / $41 / (* cp   'A'     *)
                db      254,65
; [230]   $d8 /       (* ret  c       *)
                db      216
; [231]   $fe / $5b / (* cp   'Z' + 1 *)
                db      254,91
; [232]   $d0 /       (* ret  nc      *)
                db      208
; [233]   $cb / $ed / (* set  4,l     *)
                db      203,237
; [234]   $c9         (* ret          *)
; [235] );
                db      201
                ret
; [236] 
; [237] 
; [238] 
; [239] var
; [240]   RandSeed1: Integer absolute 'seed1';
; [241]   RandSeed2: Integer absolute 'seed2';
; [242] 
; [243] function Random(Range: Integer): Integer; register; external '__random';
; [244] function RandomReal: Real; register;                external '__random48';
; [245] 
; [246] procedure Randomize; register; inline
__Randomize50:
; [247] (
; [248]   $ed / $5f /             (* ld   a,r             *)
                db      237,95
; [249]   $2a / RandSeed1 /       (* ld   hl,(RandSeed1)  *)
                db      42
                dw      seed1
; [250]   $ed / $5b / RandSeed2 / (* ld   de,(RandSeed2)  *)
                db      237,91
                dw      seed2
; [251]   $53 /                   (* ld   d,e             *)
                db      83
; [252]   $5c /                   (* ld   e,h             *)
                db      92
; [253]   $65 /                   (* ld   h,l             *)
                db      101
; [254]   $6f /                   (* ld   l,a             *)
                db      111
; [255]   $22 / RandSeed1 /       (* ld   (RandSeed1),hl  *)
                db      34
                dw      seed1
; [256]   $ed / $53 / RandSeed2 / (* ld   (RandSeed2),de  *)
                db      237,83
                dw      seed2
; [257]   $c9                     (* ret                  *)
; [258] );
                db      201
                ret
; [259] 
; [260] procedure CheckBreak; register; external '__checkbreak';
; [261] 
; [262] procedure CheckStack; register; external '__checkstack';
; [263] 
; [264] (* Built-in: procedure FillChar(var Dest; Length: Integer; Data); *)
; [265] 
; [266] procedure Move(var Source, Dest; Count: Integer); register; external '__move';
; [267] 
; [268] (* Built-in: procedure Halt([ExitCode: Byte]) *)
; [269] 
; [270] 
; [271] 
; [272] (* -------------------------------------------------------------------------- *)
; [273] (* --- Assertion support ---------------------------------------------------- *)
; [274] (* -------------------------------------------------------------------------- *)
; [275] 
; [276] (* Built-in: procedure Assert(B: Boolean); *)
; [277] 
; [278] var
; [279]   AssertPassed: Integer absolute '__assertpassed';
; [280]   AssertFailed: Integer absolute '__assertfailed';
; [5] 
; [6] {$l cpm.asm     }
                include "/Users/joerg/Projects/pasta80/rtl/cpm.asm"
; [7] 
; [8] (* --------------------------------------------------------------------- *)
; [9] (* --- VT52 terminal support ------------------------------------------- *)
; [10] (* --------------------------------------------------------------------- *)
; [11] 
; [12] const
; [13]   (**
; [14]    * Defines the default with of the CP/M screen in characters.
; [15]    *)
; [16]   ScreenWidth = 80;
; [17] 
; [18]   (**
; [19]    * Defines the default height of the CP/M screen in characters.
; [20]    *)
; [21]   ScreenHeight = 24;
; [22] 
; [23]   (**
; [24]    * Defines the line break convention used by CP/M.
; [25]    *)
; [26]   LineBreak = #13#10;
; [27] 
; [28] procedure ConOut(C: Char); register;        external '__conout';
; [29] 
; [30] (**
; [31]  * Clears the screen. Uses the most recently defined text color and
; [32]  * background for the attribute area.
; [33]  *)
; [34] procedure ClrScr; register;                 external '__clrscr';
; [35] 
; [36] (**
; [37]  * Moves the the cursor (aka printing position) to a given location. Note
; [38]  * that Pascal expects the screen column (X) first, followed by the screen
; [39]  * row (Y).
; [40]  *)
; [41] procedure GotoXY(X, Y: Integer); register;  external '__gotoxy';
; [42] 
; [43] (**
; [44]  * Shows the cursor.
; [45]  *)
; [46] procedure CursorOn; register;               external '__cursor_on';
; [47] 
; [48] (**
; [49]  * Hides the cursor.
; [50]  *)
; [51] procedure CursorOff; register;              external '__cursor_off';
; [52] 
; [53] (**
; [54]  * Clear everything from the current cursor position to the end of the
; [55]  * line.
; [56]  *)
; [57] procedure ClrEol; register; inline
__ClrEol60:
; [58] (
; [59]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [60]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [61]   $3e / 'K' /                 (* ld   a,'K'     *)
                db      62,75
; [62]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [63]   $c9                         (* ret            *)
; [64] );
                db      201
                ret
; [65] 
; [66] (**
; [67]  * Clear everything from the current cursor position to the end of the
; [68]  * screen.
; [69]  *)
; [70] procedure ClrEos; register; inline
__ClrEos61:
; [71] (
; [72]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [73]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [74]   $3e / 'J' /                 (* ld   a,'J'     *)
                db      62,74
; [75]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [76]   $c9                         (* ret            *)
; [77] );
                db      201
                ret
; [78] 
; [79] (**
; [80]  * Inserts an empty line at the current cursor position, scrolling
; [81]  * everything that follows down.
; [82]  *)
; [83] procedure InsLine; register; inline
__InsLine62:
; [84] (
; [85]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [86]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [87]   $3e / 'L' /                 (* ld   a,'L'     *)
                db      62,76
; [88]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [89]   $c9                         (* ret            *)
; [90] );
                db      201
                ret
; [91] 
; [92] (**
; [93]  * Deletes a line at the current cursor position, scrolling everything that
; [94]  * follows up.
; [95]  *)
; [96] procedure DelLine; register; inline
__DelLine63:
; [97] (
; [98]   $2e / 27 /                  (* ld   l,27      *)
                db      46,27
; [99]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [100]   $3e / 'M' /                 (* ld   l,'M'     *)
                db      62,77
; [101]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [102]   $c9                         (* ret            *)
; [103] );
                db      201
                ret
; [104] 
; [105] (**
; [106]  * Sets the text color (0..7).
; [107]  *)
; [108] procedure TextColor(I: Integer); register;      external '__textfg';
; [109] 
; [110] (**
; [111]  * Sets the text background (0..7).
; [112]  *)
; [113] procedure TextBackground(I: Integer); register; external '__textbg';
; [114] 
; [115] (**
; [116]  * Sets the video to "high", whatever that is supposed be. Currently a
; [117]  * no-op and just defined to allow other code to build.
; [118]  *)
; [119] procedure HighVideo; register; inline
__HighVideo66:
; [120] (
; [121]   $c9 (* TODO implement me! *)
; [122] );
                db      201
                ret
; [123] 
; [124] (**
; [125]  * Sets the video to "low", whatever that is supposed be. Currently a
; [126]  * no-op and just defined to allow other code to build.
; [127]  *)
; [128] procedure LowVideo; register; inline
__LowVideo67:
; [129] (
; [130]   $c9 (* TODO implement me! *)
; [131] );
                db      201
                ret
; [132] 
; [133] (**
; [134]  * Sets the video to "norm", whatever that is supposed be. Currently a
; [135]  * no-op and just defined to allow other code to build.
; [136]  *)
; [137] procedure NormVideo; register; inline
__NormVideo68:
; [138] (
; [139]   $c9 (* TODO implement me! *)
; [140] );
                db      201
                ret
; [141] 
; [142] (* -------------------------------------------------------------------------- *)
; [143] (* --- Keyboard support ----------------------------------------------------- *)
; [144] (* -------------------------------------------------------------------------- *)
; [145] 
; [146] (**
; [147]  * Returns True if a key has been pressed (and can be queried using the
; [148]  * ReadKey function), False if not.
; [149]  *)
; [150] function KeyPressed: Boolean;
; [151] begin
                if      __USE__KeyPressed69
; var KeyPressed(@RESULT)
__KeyPressed69:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [152]   KeyPressed := BDOS(11, 0) <> 0;
                ld      hl,(display+2)  ; Local KeyPressed
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,11           ; Literal 11
                ld      de,0            ; Literal 0
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                call    __int16_neq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [153] end;
exit70:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [154] 
; [155] (**
; [156]  * Reads a key press and returns the corresponding ASCII character. Does
; [157]  * echo the character to the screen. Waits for a key press, if necessary,
; [158]  * so use KeyPressed first if you don't want your program to be delayed.
; [159]  *)
; [160] function ReadKey: CHar;
; [161] begin
                if      __USE__ReadKey71
; var ReadKey(@RESULT)
__ReadKey71:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [162]   repeat until KeyPressed;
repeat73:
                ld      de,0            ; Literal 0
                push    de
                call    __KeyPressed69
                pop     hl
                bit     0,l
                jp      z,repeat73
break74:
; [163]   ReadKey := Chr(BDOS(6, 255));
                ld      hl,(display+2)  ; Local ReadKey
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,6            ; Literal 6
                ld      de,255          ; Literal 255
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                call    __Chr42
                ex      de,hl
                pop     hl
                ld      (hl),e
; [164] end;
exit72:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [165] 
; [166] (**
; [167]  * Waits for the given interval in milliseconds. Assumes a CP/M platform
; [168]  * with BDOS call 141 (i.e. normally CP/M 3, but tnylpo has this as an
; [169]  * extension) and a "tick" value of 20 ms (which is the case for both the
; [170]  * Spectrum Next's CP/M and tnylpo).
; [171]  *)
; [172] procedure Delay(Duration: Integer);
; [173] var
                if      __USE__Delay75
; [174]   A: Byte;
global76:       ds      1,0             ; Global A
; [175] begin
; var Duration(+4), A(@global76)
__Delay75:                              ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [176]   A := BDos(141, Duration div 20);
                push    hl
                ld      hl,global76 + 0
                push    hl
                ld      de,141          ; Literal 141
                push    de
                ld      hl,(display+2)  ; Local Duration
                ld      de,4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,20           ; Literal 20
                call    __sdiv16        ; Div
                ex      de,hl
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [177] end;
exit77:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [178] 
; [179] (* -------------------------------------------------------------------------- *)
; [180] (* --- Command-line parameters ---------------------------------------------- *)
; [181] (* -------------------------------------------------------------------------- *)
; [182] 
; [183] (**
; [184]  * Returns the number of command line parameters.
; [185]  *)
; [186] function ParamCount: Byte;
; [187] var
                if      __USE__ParamCount78
; [188]   CmdLine: String absolute $80;
; [189]   C, D: Boolean;
global79:       ds      1,0             ; Global C
global80:       ds      1,0             ; Global D
; [190]   I, J: Byte;
global81:       ds      1,0             ; Global I
global82:       ds      1,0             ; Global J
; [191] begin
; var ParamCount(@RESULT), CmdLine(@128), C(@global79), D(@global80), I(@global81), J(@global82)
__ParamCount78:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-264         ; Space
                add     hl,sp
                ld      sp,hl
; [192]   C := True;
                ld      hl,global79 + 0
                ld      de,1
                ld      (hl),e
; [193]   J := 0;
                ld      hl,global82 + 0
                ld      de,0
                ld      (hl),e
; [194] 
; [195]   for I := 1 to Length(CmdLine) do
                ld      hl,global81     ; Global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global81     ; Global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak85
forloop84:
; [196]   begin
; [197]     D := CmdLine[I] > ' ';
                ld      hl,global80 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global81 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [198]     if not C and D then Inc(J);
                ld      hl,global79 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global80 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false87
                ld      hl,global82 + 0
                inc     (hl)
false87:
; [199]     C := D;
                ld      hl,global79 + 0
                push    hl
                ld      hl,global80 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [200]   end;
fornext86:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global81     ; Global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak85
                ld      hl,global81     ; Global I
                inc     (hl)
                jp      forloop84
forbreak85:     pop     de              ; Cleanup limit
; [201] 
; [202]   ParamCount := J;
                ld      hl,(display+2)  ; Local ParamCount
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,global82 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [203] end;
exit83:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [204] 
; [205] (**
; [206]  * Returns the I'th command line parameter, if it exists, or an empty
; [207]  * string otherwise.
; [208]  *)
; [209] function ParamStr(I: Byte): String;
; [210] var
                if      __USE__ParamStr88
; [211]   CmdLine: String absolute $80;
; [212]   C, D: Boolean;
global89:       ds      1,0             ; Global C
global90:       ds      1,0             ; Global D
; [213]   J, K: Byte;
global91:       ds      1,0             ; Global J
global92:       ds      1,0             ; Global K
; [214] begin
; var ParamStr(@RESULT), I(+4), CmdLine(@128), C(@global89), D(@global90), J(@global91), K(@global92)
__ParamStr88:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-264         ; Space
                add     hl,sp
                ld      sp,hl
; [215]   C := True;
                ld      hl,global89 + 0
                ld      de,1
                ld      (hl),e
; [216]   K := 1;
                ld      hl,global92 + 0
                ld      de,1
                ld      (hl),e
; [217] 
; [218]   for J := 1 to Length(CmdLine) do
                ld      hl,global91     ; Global J
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global91     ; Global J
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak95
forloop94:
; [219]   begin
; [220]     D := CmdLine[J] > ' ';
                ld      hl,global90 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [221] 
; [222]     if not C and D then
                ld      hl,global89 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [223]       K := J
                bit     0,l
                jp      z,false97
                ld      hl,global92 + 0
; [224]     else if C and not D then
                push    hl
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
                jp      endif98
false97:
                ld      hl,global89 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [225]     begin
                bit     0,l
                jp      z,false99
; [226]       if I = 0 then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_eq0     ; Literal 0
                ld      h,0
                ld      l,a
; [227]       begin
                bit     0,l
                jp      z,false100
; [228]         Dec(J);
                ld      hl,global91 + 0
                dec     (hl)
; [229]         Break;
                jp      forbreak95      ; Break
; [230]       end;
false100:
; [231] 
; [232]       Dec(I);
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                dec     (hl)
; [233]     end;
false99:
endif98:
; [234] 
; [235]     C := D;
                ld      hl,global89 + 0
                push    hl
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [236]   end;
fornext96:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global91     ; Global J
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak95
                ld      hl,global91     ; Global J
                inc     (hl)
                jp      forloop94
forbreak95:     pop     de              ; Cleanup limit
; [237] 
; [238]   if I = 0 then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_eq0     ; Literal 0
                ld      h,0
                ld      l,a
; [239]     ParamStr := Copy(CmdLine, K, J - K + 1)
                bit     0,l
                jp      z,false101
                ld      hl,(display+2)  ; Local ParamStr
                ld      de,6
                add     hl,de
                push    hl
                call    __mkstr
                ld      hl,128 + 0
                call    __loadstr
                ld      hl,global92 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global92 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                inc     hl
; [240]   else
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
                jp      endif102
false101:
; [241]     ParamStr := '';
                ld      hl,(display+2)  ; Local ParamStr
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,string103
                pop     de
                ld      a,255
                call    __movestr
endif102:
; [242] end;
exit93:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [243] 
; [244] (* -------------------------------------------------------------------------- *)
; [245] (* --- CP/M BDOS interface including error handling ------------------------- *)
; [246] (* -------------------------------------------------------------------------- *)
; [247] 
; [248] const
; [249]   (**
; [250]    * The last error that occurred during file IO. Most file functions will
; [251]    * be disabled as long as this value is non-zero.
; [252]    *)
; [253]   LastError: Byte = 0;
const104:
                db      0
; [254] 
; [255] (**
; [256]  * Queries the last error that happened during an esxDOS call and resets
; [257]  * the value to zero, so that further esxDOS calls can be made.
; [258]  *)
; [259] function IOResult: Byte;
; [260] begin
                if      __USE__IOResult105
; var IOResult(@RESULT)
__IOResult105:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [261]   IOResult := LastError;
                ld      hl,(display+2)  ; Local IOResult
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [262]   LastError := 0;
                ld      hl,const104 + 0
                ld      de,0
                ld      (hl),e
; [263] end;
exit106:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [264] 
; [265] (**
; [266]  * Performs a BDOS call for the given function number and parameter value.
; [267]  * TODO Check if we can merge this with the built-in BDos and BDosHL
; [268]  * functions.
; [269]  *)
; [270] procedure BDosCatch(Func: Byte; Param: Integer);
; [271] var
                if      __USE__BDosCatch107
; [272]   A: Byte;
global108:      ds      1,0             ; Global A
; [273] begin
; var Func(+6), Param(+4), A(@global108)
__BDosCatch107:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [274]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false110
                jp      exit109         ; Exit
false110:
; [275]   A := BDos(Func, Param);
                ld      hl,global108 + 0
                push    hl
                ld      hl,(display+2)  ; Local Func
                ld      de,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local Param
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [276]   (* WriteLn('BDos(', Func, ') returned A=' , A); *)
; [277]   if A <> 0 then LastError := A;
                ld      hl,global108 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false111
                ld      hl,const104 + 0
                push    hl
                ld      hl,global108 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
false111:
; [278] end;
exit109:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [279] 
; [280] (**
; [281]  * Checks the last BDOS error and terminates the program if it is <> 0.
; [282]  * Calls to this function are automatically generated by the compiler in
; [283]  * {$i+} mode.
; [284]  *)
; [285] procedure BDosThrow;
; [286] begin
                if      __USE__BDosThrow112
__BDosThrow112:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [287]   if LastError <> 0 then
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [288]   begin
                bit     0,l
                jp      z,false114
; [289]     WriteLn('BDos error ', LastError);
                ld      hl,string115
                call    __puts
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [290]     Halt;
                jp      __done
; [291]   end;
false114:
; [292] end;
exit113:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [293] 
; [294] (* --------------------------------------------------------------------- *)
; [295] (* --- Internal implementation of "raw" untyped files ------------------ *)
; [296] (* --------------------------------------------------------------------- *)
; [297] 
; [298] type
; [299]   (**
; [300]    * Represents a CP/M file control block.
; [301]    *)
; [302]   FileControlBlock = record
; [303]     DR: Byte;                           (* Drive number                       *)
; [304]     FN: array[0..7] of Char;            (* File name, 8 chars, space-padded   *)
; [305]     TN: array[0..2] of Char;            (* Extension, 3 chars, space-padded   *)
; [306]     EX, S1, S2, RC: Byte;               (* CP/M internal stuff                *)
; [307]     AL: array[0..15] of Byte;           (* CP/M internal stuff                *)
; [308]     CR: Byte;                           (* CP/M internal stuff                *)
; [309]     RL: Integer; RH: Byte;              (* 24 bit random record number        *)
; [310]     SL: Integer; SH: Byte;              (* Record count, not part of CP/M FCB *)
; [311]   end;
; [312] 
; [313] procedure BlockAssign(var F: FileControlBlock; S: String);
; [314] var
                if      __USE__BlockAssign116
; [315]   I, L, P, Q: Integer;
global117:      ds      2,0             ; Global I
global118:      ds      2,0             ; Global L
global119:      ds      2,0             ; Global P
global120:      ds      2,0             ; Global Q
; [316] begin
; var F(+260), S(+4), I(@global117), L(@global118), P(@global119), Q(@global120)
__BlockAssign116:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
                push    hl
; [317]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false122
                jp      exit121         ; Exit
false122:
; [318] 
; [319]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [320]   begin
; [321]     L := Length(S);
                push    de
                ld      hl,global118 + 0
                push    hl
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de
                pop     hl
                ld      (hl),de
; [322] 
; [323]     if (L > 1) and (S[2] = ':') then
                ld      hl,(global118 + 0)
                push    hl
                ld      hl,1            ; Literal 1
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                inc     hl
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,58           ; Literal 58
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [324]     begin
                bit     0,l
                jp      z,false123
; [325]       DR := Ord(UpCase(S[1])) - 64;
                ld      hl,(display+2)  ; Local DR
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ld      de,64
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [326]       Delete(S, 1, 2);
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      de,2            ; Literal 2
                push    de
                call    __delete
; Post call cleanup 6 bytes
                pop     hl
                pop     hl
                pop     hl
; [327]       Dec(L, 2);
                ld      hl,global118 + 0
                push    hl
                ld      bc,2            ; Literal 2
                pop     hl
                call    __dec16by
; [328]     end
; [329]     else DR := 0;
                jp      endif124
false123:
                ld      hl,(display+2)  ; Local DR
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e
endif124:
; [330] 
; [331]     P := Pos('.', S);
                ld      hl,global119 + 0
                push    hl
                push    hl
                ld      de,46           ; Literal 46
                call    __char2str
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [332]     if P = 0 then P := L + 1;
                ld      hl,(global119 + 0)
                call    __int16_eq0
                and     a
                jp      z,false125
                ld      hl,global119 + 0
                push    hl
                ld      hl,(global118 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
false125:
; [333] 
; [334]     Q := P - 1;
                ld      hl,global120 + 0
                push    hl
                ld      hl,(global119 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [335]     if Q > 8 then Q := 8;
                ld      hl,(global120 + 0)
                push    hl
                ld      hl,8            ; Literal 8
                pop     de
                call    __int16_lt
                and     a
                jp      z,false126
                ld      hl,global120 + 0
                ld      de,8
                ld      (hl),de
false126:
; [336] 
; [337]     for I := 1 to Q do FN[I - 1] := UpCase(S[I]);
                ld      hl,global117    ; Global I
                ld      de,1
                ld      (hl),de
                ld      hl,(global120 + 0)
                push    hl
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak128
forloop127:
                ld      hl,(display+2)  ; Local FN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext129:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak128
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop127
forbreak128:    pop     de              ; Cleanup limit
; [338]     for I := Q + 1 to 8 do FN[I - 1] := ' ';
                ld      hl,global117    ; Global I
                push    hl
                ld      hl,(global120 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak131
forloop130:
                ld      hl,(display+2)  ; Local FN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext132:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak131
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop130
forbreak131:    pop     de              ; Cleanup limit
; [339] 
; [340]     Q := L - P;
                ld      hl,global120 + 0
                push    hl
                ld      hl,(global118 + 0)
                push    hl
                ld      hl,(global119 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [341]     if Q > 3 then Q := 3;
                ld      hl,(global120 + 0)
                push    hl
                ld      hl,3            ; Literal 3
                pop     de
                call    __int16_lt
                and     a
                jp      z,false133
                ld      hl,global120 + 0
                ld      de,3
                ld      (hl),de
false133:
; [342] 
; [343]     for I := 1 to Q do TN[I - 1] := UpCase(S[P + I]);
                ld      hl,global117    ; Global I
                ld      de,1
                ld      (hl),de
                ld      hl,(global120 + 0)
                push    hl
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak135
forloop134:
                ld      hl,(display+2)  ; Local TN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global119 + 0)
                push    hl
                ld      hl,(global117 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext136:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak135
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop134
forbreak135:    pop     de              ; Cleanup limit
; [344]     for I := Q + 1 to 3 do TN[I - 1] := ' ';
                ld      hl,global117    ; Global I
                push    hl
                ld      hl,(global120 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
                ld      de,3            ; Literal 3
                push    de
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak138
forloop137:
                ld      hl,(display+2)  ; Local TN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext139:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak138
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop137
forbreak138:    pop     de              ; Cleanup limit
; [345] (*
; [346]     Write(DR, ':');
; [347]     for I := 0 to 7 do Write(FN[I]);
; [348]     Write('.');
; [349]     for I := 0 to 2 do Write(TN[I]);
; [350]     WriteLn;
; [351] *)
; [352]   end;
                pop     bc
; [353] end;
exit121:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [354] 
; [355] procedure BlockErase(var F: FileControlBlock);
; [356] var
                if      __USE__BlockErase140
; [357]   A: Byte;
global141:      ds      1,0             ; Global A
; [358] begin
; var F(+4), A(@global141)
__BlockErase140:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [359]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false143
                jp      exit142         ; Exit
false143:
; [360]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global141 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [361] end;
exit142:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [362] 
; [363] procedure BlockRename(var F: FileControlBlock; S: String);
; [364] var
                if      __USE__BlockRename144
; [365]   G: FileControlBlock;
; [366]   A: Byte;
global145:      ds      1,0             ; Global A
; [367] begin
; var F(+260), S(+4), G(-39), A(@global145)
__BlockRename144:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-41          ; Space
                add     hl,sp
                ld      sp,hl
; [368]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false147
                jp      exit146         ; Exit
false147:
; [369]   BlockAssign(G, S);
                ld      hl,(display+2)  ; Local G
                ld      de,-39
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [370]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false148
                jp      exit146         ; Exit
false148:
; [371]   Move(G, F.AL, 12);
                ld      hl,(display+2)  ; Local G
                ld      de,-39
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,16           ; Literal 16
                add     hl,de
                push    hl
                ld      bc,12           ; Literal 12
                pop     de
                pop     hl
                call    __move
; [372]   BDosCatch(23, Addr(F));
                ld      de,23           ; Literal 23
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [373] end;
exit146:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [374] 
; [375] procedure BlockReset(var F: FileControlBlock);
; [376] var
                if      __USE__BlockReset149
; [377]   A: Byte;
global150:      ds      1,0             ; Global A
; [378] begin
; var F(+4), A(@global150)
__BlockReset149:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [379]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false152
                jp      exit151         ; Exit
false152:
; [380] 
; [381]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [382]   begin
; [383]     EX := 0;
                push    de
                ld      hl,(display+2)  ; Local EX
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [384]     S1 := 0;
                ld      hl,(display+2)  ; Local S1
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [385]     S2 := 0;
                ld      hl,(display+2)  ; Local S2
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [386]     RC := 0;
                ld      hl,(display+2)  ; Local RC
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [387]     CR := 0;
                ld      hl,(display+2)  ; Local CR
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [388] 
; [389]     RL := 0;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),de
; [390]     RH := 0;
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [391] 
; [392]     BDosCatch(15, Addr(F));
                ld      de,15           ; Literal 15
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [393]     BDosCatch(35, Addr(F));
                ld      de,35           ; Literal 35
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [394] 
; [395]     SL := RL; SH := RH;
                ld      hl,(display+2)  ; Local SL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
                ld      hl,(display+2)  ; Local SH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [396] 
; [397]     RL := 0;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),de
; [398]     RH := 0;
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [399]  end;
                pop     bc
; [400] end;
exit151:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [401] 
; [402] procedure BlockRewrite(var F: FileControlBlock);
; [403] var
                if      __USE__BlockRewrite153
; [404]   A: Byte;
global154:      ds      1,0             ; Global A
; [405] begin
; var F(+4), A(@global154)
__BlockRewrite153:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [406]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false156
                jp      exit155         ; Exit
false156:
; [407] 
; [408]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [409]   begin
; [410]     EX := 0;
                push    de
                ld      hl,(display+2)  ; Local EX
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [411]     S1 := 0;
                ld      hl,(display+2)  ; Local S1
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [412]     S2 := 0;
                ld      hl,(display+2)  ; Local S2
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [413]     RC := 0;
                ld      hl,(display+2)  ; Local RC
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [414]     CR := 0;
                ld      hl,(display+2)  ; Local CR
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [415] 
; [416]     RL := 0;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),de
; [417]     RH := 0;
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [418] 
; [419]     SL := 0;
                ld      hl,(display+2)  ; Local SL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),de
; [420]     SH := 0;
                ld      hl,(display+2)  ; Local SH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),e
; [421]   end;
                pop     bc
; [422] 
; [423]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global154 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [424]   BDosCatch(22, Addr(F));
                ld      de,22           ; Literal 22
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [425] end;
exit155:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [426] 
; [427] procedure BlockClose(var F: FileControlBlock);
; [428] begin
                if      __USE__BlockClose157
; var F(+4)
__BlockClose157:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [429]   BDosCatch(16, Addr(F));
                ld      de,16           ; Literal 16
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [430] end;
exit158:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [431] 
; [432] function BlockFilePos(var F: FileControlBlock): Integer;
; [433] begin
                if      __USE__BlockFilePos159
; var BlockFilePos(@RESULT), F(+4)
__BlockFilePos159:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [434]   BlockFilePos := F.RL;
                ld      hl,(display+2)  ; Local BlockFilePos
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [435] end;
exit160:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [436] 
; [437] function BlockFileSize(var F: FileControlBlock): Integer;
; [438] var
                if      __USE__BlockFileSize161
; [439]   I: Integer;
global162:      ds      2,0             ; Global I
; [440] begin
; var BlockFileSize(@RESULT), F(+4), I(@global162)
__BlockFileSize161:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [441]   BlockFileSize := F.SL;
                push    hl
                ld      hl,(display+2)  ; Local BlockFileSize
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36           ; Literal 36
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [442] end;
exit163:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [443] 
; [444] function BlockEof(var F: FileControlBlock): Boolean;
; [445] begin
                if      __USE__BlockEof164
; var BlockEof(@RESULT), F(+4)
__BlockEof164:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [446]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [447]     BlockEof := (RL = SL) and (RH = SH);
                push    de
                ld      hl,(display+2)  ; Local BlockEof
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local RL
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local SL
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(display+2)  ; Local RH
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local SH
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [448] end;
exit165:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [449] 
; [450] procedure BlockSeek(var F: FileControlBlock; I: Integer);
; [451] begin
                if      __USE__BlockSeek166
; var F(+6), I(+4)
__BlockSeek166:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [452]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false168
                jp      exit167         ; Exit
false168:
; [453] 
; [454]   F.RL := I;
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [455] end;
exit167:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [456] 
; [457] procedure BlockBlockRead(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
; [458] var
                if      __USE__BlockBlockRead169
; [459]   DMA: Integer;
global170:      ds      2,0             ; Global DMA
; [460] begin
; var F(+10), Buffer(+8), Count(+6), Actual(+4), DMA(@global170)
__BlockBlockRead169:                    ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [461]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false172
                jp      exit171         ; Exit
false172:
; [462] 
; [463]   DMA := Addr(Buffer);
                ld      hl,global170 + 0
                push    hl
                ld      hl,(display+2)  ; Local Buffer
                ld      de,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [464]   Actual := 0;
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),de
; [465] 
; [466]   while Count > 0 do
while173:
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ld      hl,0
                call    __int16_lt
                ld      h,0
                ld      l,a
; [467]   begin
                bit     0,l
                jp      z,false174
; [468]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global170 + 0)
                push    hl
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [469]     BDosCatch(33, Addr(F));
                ld      de,33           ; Literal 33
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [470] 
; [471]     if LastError = 1 then
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                call    __int16_eq
                ld      h,0
                ld      l,a
; [472]     begin
                bit     0,l
                jp      z,false175
; [473]       LastError := 0;
                ld      hl,const104 + 0
                ld      de,0
                ld      (hl),e
; [474]       Exit;
                jp      exit171         ; Exit
; [475]     end;
false175:
; [476] 
; [477]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false176
                jp      exit171         ; Exit
false176:
; [478] 
; [479]     Inc(F.RL);
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [480]     Inc(DMA, 128);
                ld      hl,global170 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [481]     Inc(Actual);
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __inc16
; [482]     Dec(Count);
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                call    __dec16
; [483]   end;
                jp      while173
false174:
; [484] end;
exit171:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [485] 
; [486] procedure BlockBlockWrite(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
; [487] var
                if      __USE__BlockBlockWrite177
; [488]   DMA: Integer;
global178:      ds      2,0             ; Global DMA
; [489] begin
; var F(+10), Buffer(+8), Count(+6), Actual(+4), DMA(@global178)
__BlockBlockWrite177:                   ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [490]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false180
                jp      exit179         ; Exit
false180:
; [491] 
; [492]   DMA := Addr(Buffer);
                ld      hl,global178 + 0
                push    hl
                ld      hl,(display+2)  ; Local Buffer
                ld      de,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [493]   Actual := 0;
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),de
; [494] 
; [495]   while Count > 0 do
while181:
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ld      hl,0
                call    __int16_lt
                ld      h,0
                ld      l,a
; [496]   begin
                bit     0,l
                jp      z,false182
; [497]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global178 + 0)
                push    hl
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [498]     BDosCatch(34, Addr(F));
                ld      de,34           ; Literal 34
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [499] 
; [500]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false183
                jp      exit179         ; Exit
false183:
; [501] 
; [502]     Inc(F.RL);
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [503]     Inc(DMA, 128);
                ld      hl,global178 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [504]     Inc(Actual);
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __inc16
; [505]     Dec(Count);
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                call    __dec16
; [506] 
; [507]     if F.RL > F.SL then F.SL := F.RL;
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36           ; Literal 36
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,false184
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36           ; Literal 36
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false184:
; [508]   end;
                jp      while181
false182:
; [509] end;
exit179:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [510] 
; [511] {$i files.pas}
; [0] (* --- Text file routines, use TextRec as representation -------------------- *)
; [1] 
; [2] type
; [3]   TextRec = record                      (* Internal text file representation  *)
; [4]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [5]     Readable: Boolean;                  (* File is open for reading           *)
; [6]     Writable: Boolean;                  (* File is open for writing           *)
; [7]     EndOfFile: Boolean;
; [8]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [9]     DMA: array[0..127] of Char;         (* Internal sector buffer             *)
; [10]   end;
; [11] 
; [12]   FileRec = record                      (* Internal typed file representation *)
; [13]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [14]     CompSize: Integer;                  (* Size of component type             *)
; [15]     CompCount: Integer;                 (* Number of components in file       *)
; [16]     CompIndex: Integer;                 (* Index of current component         *)
; [17]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [18]     Modified: Boolean;                  (* Current record has been modified   *)
; [19]     case Boolean of
; [20]       False: (DMA: array[0..127] of Char;); (* Internal sector buffer         *)
; [21]       True:  (HdrCount, HdrSize: Integer;); (* Typed file header              *)
; [22]   end;
; [23] 
; [24] procedure TextAssign(var T: TextRec; Name: String);
; [25] begin
                if      __USE__TextAssign185
; var T(+260), Name(+4)
__TextAssign185:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [26]   BlockAssign(T.FCB, Name);
                ld      hl,(display+2)  ; Local T
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Name
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [27] end;
exit186:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [28] 
; [29] procedure TextReset(var T: TextRec);
; [30] var
                if      __USE__TextReset187
; [31]   E: Integer;
global188:      ds      2,0             ; Global E
; [32] begin
; var T(+4), E(@global188)
__TextReset187:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [33]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [34]   begin
; [35]     BlockReset(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockReset149
; Post call cleanup 2 bytes
                pop     hl
; [36]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global188 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [37] 
; [38]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false190
                jp      exit189         ; Exit
false190:
; [39] 
; [40]     Readable := True;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,1
                ld      (hl),e
; [41]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),e
; [42] 
; [43]     Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [44]     EndOfFile := E = 0;
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(global188 + 0)
                call    __int16_eq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [45]   end;
                pop     bc
; [46] end;
exit189:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [47] 
; [48] procedure TextRewrite(var T: TextRec);
; [49] begin
                if      __USE__TextRewrite191
; var T(+4)
__TextRewrite191:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [50]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [51]   begin
; [52]     BlockRewrite(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockRewrite153
; Post call cleanup 2 bytes
                pop     hl
; [53] 
; [54]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false193
                jp      exit192         ; Exit
false193:
; [55] 
; [56]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),e
; [57]     Writable := True;
                ld      hl,(display+2)  ; Local Writable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,1
                ld      (hl),e
; [58] 
; [59]     Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [60]   end;
                pop     bc
; [61] end;
exit192:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [62] 
; [63] procedure TextReadChar(var T: TextRec; var C: Char);
; [64] var
                if      __USE__TextReadChar194
; [65]   E: Integer;
global195:      ds      2,0             ; Global E
; [66] begin
; var T(+6), C(+4), E(@global195)
__TextReadChar194:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [67]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [68]   begin
; [69]     if EndOfFile then
                push    de
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [70]     begin
                ex      de,hl
                bit     0,l
                jp      z,false197
; [71]       C := #26;
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                ld      (hl),e
; [72]       Exit;
                jp      exit196         ; Exit
; [73]     end;
false197:
; [74] 
; [75]     C := DMA[Offset];
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [76]     if C <> #26 then
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_neq
                ld      h,0
                ld      l,a
; [77]     begin
                bit     0,l
                jp      z,false198
; [78]       Inc(Offset);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                call    __inc16
; [79]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [80]       begin
                bit     0,l
                jp      z,false199
; [81]         BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global195 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [82]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false200
                jp      exit196         ; Exit
false200:
; [83]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [84]         EndOfFile := E = 0;
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(global195 + 0)
                call    __int16_eq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [85]       end;
false199:
; [86]     end;
false198:
; [87]   end;
                pop     bc
; [88] end;
exit196:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [89] 
; [90] procedure TextReadStr(var T: TextRec; var S: String);
; [91] var
                if      __USE__TextReadStr201
; [92]   C: Char;
global202:      ds      1,0             ; Global C
; [93] begin
; var T(+6), S(+4), C(@global202)
__TextReadStr201:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [94]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [95] 
; [96]   while Length(S) < 255 do
while204:
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [97]   begin
                bit     0,l
                jp      z,false205
; [98]     TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global202 + 0
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [99]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false206
                jp      exit203         ; Exit
false206:
; [100] 
; [101]     if C = #10 then Break;
                ld      hl,global202 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false207
                jp      false205        ; Break
false207:
; [102]     if C = #13 then
                ld      hl,global202 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_eq
                ld      h,0
                ld      l,a
; [103]     begin
                bit     0,l
                jp      z,false208
; [104]       if T.DMA[T.Offset] = #10 then TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44           ; Literal 44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42           ; Literal 42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false209
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global202 + 0
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
false209:
; [105]       Break;
                jp      false205        ; Break
; [106]     end;
false208:
; [107]     if C = #26 then Break;
                ld      hl,global202 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false210
                jp      false205        ; Break
false210:
; [108] 
; [109]     if C >= ' ' then S := S + C;
                ld      hl,global202 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                and     a
                jp      z,false211
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global202 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
false211:
; [110]   end;
                jp      while204
false205:
; [111] end;
exit203:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [112] 
; [113] procedure TextReadWord(var T: TextRec; var S: String);
; [114] var
                if      __USE__TextReadWord212
; [115]   C: Char;
global213:      ds      1,0             ; Global C
; [116] begin
; var T(+6), S(+4), C(@global213)
__TextReadWord212:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [117]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [118] 
; [119]   while Length(S) < 255 do
while215:
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [120]   begin
                bit     0,l
                jp      z,false216
; [121]     TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global213 + 0
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [122]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false217
                jp      exit214         ; Exit
false217:
; [123] 
; [124]     if C > ' ' then S := S + C else Break;
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                and     a
                jp      z,false218
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global213 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
                jp      endif219
false218:
                jp      false216        ; Break
endif219:
; [125]   end;
                jp      while215
false216:
; [126] end;
exit214:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [127] 
; [128] procedure TextReadInt(var T: TextRec; var I: Integer);
; [129] var
                if      __USE__TextReadInt220
; [130]   S: String;
; [131]   E: Integer;
global221:      ds      2,0             ; Global E
; [132] begin
; var T(+6), I(+4), S(-256), E(@global221)
__TextReadInt220:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [133]   TextReadWord(T, S);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextReadWord212
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [134]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false223
                jp      exit222         ; Exit
false223:
; [135]   Val(S, I, E);
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                call    __loadstr
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global221 + 0
                push    hl
                call    __val_int
; [136] end;
exit222:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [137] 
; [138] procedure TextReadFloat(var T: TextRec; var R: Real);
; [139] var
                if      __USE__TextReadFloat224
; [140]   S: String;
; [141]   E: Integer;
global225:      ds      2,0             ; Global E
; [142] begin
; var T(+6), R(+4), S(-256), E(@global225)
__TextReadFloat224:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [143]   TextReadWord(T, S);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextReadWord212
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [144]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false227
                jp      exit226         ; Exit
false227:
; [145]   Val(S, R, E);
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                call    __loadstr
                ld      hl,(display+2)  ; Local R
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global225 + 0
                push    hl
                call    __val_float
; [146] end;
exit226:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [147] 
; [148] procedure TextWriteChar(var T: TextRec; C: Char);
; [149] var
                if      __USE__TextWriteChar228
; [150]   E: Integer;
global229:      ds      2,0             ; Global E
; [151] begin
; var T(+6), C(+4), E(@global229)
__TextWriteChar228:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [152]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [153]   begin
; [154]     DMA[Offset] := C;
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [155]     Inc(Offset);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                call    __inc16
; [156]     if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [157]     begin
                bit     0,l
                jp      z,false231
; [158]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global229 + 0
                push    hl
                call    __BlockBlockWrite177
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [159]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false232
                jp      exit230         ; Exit
false232:
; [160]       Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [161]     end;
false231:
; [162]   end;
                pop     bc
; [163] end;
exit230:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [164] 
; [165] procedure TextFlush(var T: TextRec);
; [166] var
                if      __USE__TextFlush233
; [167]   E: Integer;
global234:      ds      2,0             ; Global E
; [168] begin
; var T(+4), E(@global234)
__TextFlush233:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [169]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [170]   begin
; [171]     (* FIXME !!! *)
; [172]     TextWriteChar(T, #26);
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    __TextWriteChar228
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [173] 
; [174]     if Offset <> 0 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [175]       BlockBlockWrite(FCB, DMA, 1, E);
                bit     0,l
                jp      z,false236
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global234 + 0
                push    hl
                call    __BlockBlockWrite177
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
false236:
; [176] 
; [177]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false237
                jp      exit235         ; Exit
false237:
; [178] 
; [179]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),e
; [180]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),e
; [181]   end;
                pop     bc
; [182] end;
exit235:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [183] 
; [184] procedure TextClose(var T: TextRec);
; [185] var
                if      __USE__TextClose238
; [186]   E: Integer;
global239:      ds      2,0             ; Global E
; [187] begin
; var T(+4), E(@global239)
__TextClose238:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [188]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [189]   begin
; [190]     if Writable then TextFlush(T);
                push    de
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                bit     0,l
                jp      z,false241
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextFlush233
; Post call cleanup 2 bytes
                pop     hl
false241:
; [191] 
; [192]     BlockClose(FCB);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockClose157
; Post call cleanup 2 bytes
                pop     hl
; [193] 
; [194]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false242
                jp      exit240         ; Exit
false242:
; [195] 
; [196]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),e
; [197]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),e
; [198]   end;
                pop     bc
; [199] end;
exit240:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [200] 
; [201] procedure TextWriteStr(var T: TextRec; S: String);
; [202] var
                if      __USE__TextWriteStr243
; [203]   I: Byte;
global244:      ds      1,0             ; Global I
; [204] begin
; var T(+260), S(+4), I(@global244)
__TextWriteStr243:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [205]   for I := 1 to Length(S) do
                push    hl
                ld      hl,global244    ; Global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global244    ; Global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak247
forloop246:
; [206]   begin
; [207]     TextWriteChar(T, S[I]);
                ld      hl,(display+2)  ; Local T
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,global244 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    __TextWriteChar228
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [208]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false249
                jp      exit245         ; Exit
false249:
; [209]   end;
fornext248:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global244    ; Global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak247
                ld      hl,global244    ; Global I
                inc     (hl)
                jp      forloop246
forbreak247:    pop     de              ; Cleanup limit
; [210] end;
exit245:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [211] 
; [212] procedure TextWriteEoln(var T: TextRec);
; [213] begin
                if      __USE__TextWriteEoln250
; var T(+4)
__TextWriteEoln250:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [214]   TextWriteStr(T, LineBreak);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,string54
                call    __loadstr
                call    __TextWriteStr243
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [215] end;
exit251:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [216] 
; [217] function TextEoln(var T: TextRec): Boolean;
; [218] begin
                if      __USE__TextEoln252
; var TextEoln(@RESULT), T(+4)
__TextEoln252:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [219]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [220]     TextEoln := DMA[Offset] = #13;
                push    de
                ld      hl,(display+2)  ; Local TextEoln
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local DMA
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [221] end;
exit253:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [222] 
; [223] function TextEof(var T: TextRec): Boolean;
; [224] begin
                if      __USE__TextEof254
; var TextEof(@RESULT), T(+4)
__TextEof254:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [225]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [226]     TextEof := EndOfFile or (DMA[Offset] = #26);
                push    de
                ld      hl,(display+2)  ; Local TextEof
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local EndOfFile
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                or      e
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [227] end;
exit255:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [228] 
; [229] procedure TextSeekEof(var T: TextRec);
; [230] var
                if      __USE__TextSeekEof256
; [231]   E: Integer;
global257:      ds      2,0             ; Global E
; [232]   C: Char;
global258:      ds      1,0             ; Global C
; [233] begin
; var T(+4), E(@global257), C(@global258)
__TextSeekEof256:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [234]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [235]   begin
; [236]     BlockSeek(FCB, BlockFileSize(FCB) - 1);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                push    hl
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockFileSize161
; Post call cleanup 2 bytes
                pop     hl
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [237]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global257 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [238] 
; [239]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false260
                jp      exit259         ; Exit
false260:
; [240] 
; [241]     while not TextEof(T) do
while261:
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextEof254
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [242]       TextReadChar(T, C);
                bit     0,l
                jp      z,false262
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global258 + 0
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                jp      while261
false262:
; [243]   end;
                pop     bc
; [244] end;
exit259:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [245] 
; [246] procedure TextSeekEoln(var T: TextRec);
; [247] var
                if      __USE__TextSeekEoln263
; [248]   C: Char;
global264:      ds      1,0             ; Global C
; [249] begin
; var T(+4), C(@global264)
__TextSeekEoln263:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [250]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [251]   begin
; [252]     while DMA[Offset] <> #13 do
                push    de
while266:
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_neq
                ld      h,0
                ld      l,a
; [253]     begin
                bit     0,l
                jp      z,false267
; [254]       TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global264 + 0
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [255]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false268
                jp      exit265         ; Exit
false268:
; [256]     end;
                jp      while266
false267:
; [257]   end;
                pop     bc
; [258] end;
exit265:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [259] 
; [260] procedure TextAppend(var T: TextRec);
; [261] begin
                if      __USE__TextAppend269
; var T(+4)
__TextAppend269:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [262]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [263]   begin
; [264]     TextReset(T);
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextReset187
; Post call cleanup 2 bytes
                pop     hl
; [265]     TextSeekEof(T);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextSeekEof256
; Post call cleanup 2 bytes
                pop     hl
; [266] 
; [267]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false271
                jp      exit270         ; Exit
false271:
; [268] 
; [269]     BlockSeek(FCB, FCB.RL - 1);
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [270] 
; [271]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),e
; [272]     Writable := True;
                ld      hl,(display+2)  ; Local Writable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,1
                ld      (hl),e
; [273]   end;
                pop     bc
; [274] end;
exit270:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [275] 
; [276] (* --- Typed file routines, use FileRec as representation ------------------- *)
; [277] 
; [278] procedure FileAssign(var F: FileRec; Name: String; Size: Integer);
; [279] begin
                if      __USE__FileAssign272
; var F(+262), Name(+6), Size(+4)
__FileAssign272:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [280]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false274
                jp      exit273         ; Exit
false274:
; [281] 
; [282]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,262
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [283]   begin
; [284]     BlockAssign(FCB, Name);
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Name
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [285]     CompSize := Size;
                ld      hl,(display+2)  ; Local CompSize
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Size
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [286]   end;
                pop     bc
; [287] end;
exit273:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [288] 
; [289] procedure FileReset(var F: FileRec);
; [290] var
                if      __USE__FileReset275
; [291]   E: Integer;
global276:      ds      2,0             ; Global E
; [292] begin
; var F(+4), E(@global276)
__FileReset275:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [293]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false278
                jp      exit277         ; Exit
false278:
; [294] 
; [295]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [296]   begin
; [297]     BlockReset(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockReset149
; Post call cleanup 2 bytes
                pop     hl
; [298]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global276 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [299] 
; [300]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false279
                jp      exit277         ; Exit
false279:
; [301] 
; [302]     if CompSize <> HdrSize then
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local HdrSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,50
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [303]     begin
                bit     0,l
                jp      z,false280
; [304]       WriteLn('Invalid file type');
                ld      hl,string281
                call    __puts
                call    __newline
; [305]       Halt;
                jp      __done
; [306]     end;
false280:
; [307] 
; [308]     CompCount := HdrCount;
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [309]     CompIndex := 0;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                ld      de,0
                ld      (hl),de
; [310] 
; [311]     Offset := 4;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,4
                ld      (hl),de
; [312]     Modified := False;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      de,0
                ld      (hl),e
; [313] 
; [314]     (*WriteLn('Opened existing file, size=', CompSize, ' count=', CompCount);
; [315]     ReadLn;*)
; [316]   end;
                pop     bc
; [317] end;
exit277:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [318] 
; [319] procedure FileRewrite(var F: FileRec);
; [320] var
                if      __USE__FileRewrite282
; [321]   E: Integer;
global283:      ds      2,0             ; Global E
; [322] begin
; var F(+4), E(@global283)
__FileRewrite282:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [323]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false285
                jp      exit284         ; Exit
false285:
; [324] 
; [325]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [326]   begin
; [327]     BlockRewrite(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockRewrite153
; Post call cleanup 2 bytes
                pop     hl
; [328] 
; [329]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false286
                jp      exit284         ; Exit
false286:
; [330] 
; [331]     HdrSize := CompSize;
                ld      hl,(display+2)  ; Local HdrSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,50
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [332]     HdrCount := 0;
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                ld      de,0
                ld      (hl),de
; [333] 
; [334]     CompCount := 0;
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,0
                ld      (hl),de
; [335]     CompIndex := 0;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                ld      de,0
                ld      (hl),de
; [336] 
; [337]     Offset := 4;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,4
                ld      (hl),de
; [338]     Modified := True;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      de,1
                ld      (hl),e
; [339] 
; [340]     BlockBlockWrite(FCB, DMA, 1, E); (* TODO Delay this until Flush/Close? *)
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global283 + 0
                push    hl
                call    __BlockBlockWrite177
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [341] 
; [342]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false287
                jp      exit284         ; Exit
false287:
; [343] 
; [344]     (*WriteLn('Created new file, size=', CompSize, ' count=', CompCount);*)
; [345]   end;
                pop     bc
; [346] end;
exit284:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [347] 
; [348] function FileFileSize(var F: FileRec): Integer;
; [349] begin
                if      __USE__FileFileSize288
; var FileFileSize(@RESULT), F(+4)
__FileFileSize288:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [350]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false290
                jp      exit289         ; Exit
false290:
; [351] 
; [352]   FileFileSize := F.CompCount;
                ld      hl,(display+2)  ; Local FileFileSize
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41           ; Literal 41
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [353] end;
exit289:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [354] 
; [355] function FileFilePos(var F: FileRec): Integer;
; [356] begin
                if      __USE__FileFilePos291
; var FileFilePos(@RESULT), F(+4)
__FileFilePos291:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [357]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false293
                jp      exit292         ; Exit
false293:
; [358] 
; [359]   FileFilePos := F.CompIndex;
                ld      hl,(display+2)  ; Local FileFilePos
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43           ; Literal 43
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [360] end;
exit292:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [361] 
; [362] function FileEof(var F: FileRec): Boolean;
; [363] begin
                if      __USE__FileEof294
; var FileEof(@RESULT), F(+4)
__FileEof294:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [364]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false296
                jp      exit295         ; Exit
false296:
; [365] 
; [366]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [367]     FileEof := CompIndex = CompCount;
                push    de
                ld      hl,(display+2)  ; Local FileEof
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompIndex
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [368] end;
exit295:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [369] 
; [370] procedure FileFlush(var F: FileRec);
; [371] var
                if      __USE__FileFlush297
; [372]   E: Integer;
global298:      ds      2,0             ; Global E
; [373] begin
; var F(+4), E(@global298)
__FileFlush297:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [374]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false300
                jp      exit299         ; Exit
false300:
; [375] 
; [376]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [377]   begin
; [378]     if Modified then
                push    de
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [379]     begin
                ex      de,hl
                bit     0,l
                jp      z,false301
; [380]       BlockSeek(FCB, FCB.RL - 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [381]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global298 + 0
                push    hl
                call    __BlockBlockWrite177
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [382]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false302
                jp      exit299         ; Exit
false302:
; [383]       Modified := False;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      de,0
                ld      (hl),e
; [384]     end;
false301:
; [385]   end;
                pop     bc
; [386] end;
exit299:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [387] 
; [388] procedure FileSeek(var F: FileRec; I: Integer);
; [389] var
                if      __USE__FileSeek303
; [390]   P, S: Real;
global304:      ds      6,0             ; Global P
global305:      ds      6,0             ; Global S
; [391]   E: Integer;
global306:      ds      2,0             ; Global E
; [392] begin
; var F(+6), I(+4), P(@global304), S(@global305), E(@global306)
__FileSeek303:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [393]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false308
                jp      exit307         ; Exit
false308:
; [394] 
; [395]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [396]   begin
; [397]     FileFlush(F);
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush297
; Post call cleanup 2 bytes
                pop     hl
; [398] 
; [399]     if I > CompCount then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [400]     begin
                bit     0,l
                jp      z,false309
; [401]       WriteLn('*** ', I, ' > ', CompCount);
                ld      hl,string310
                call    __puts
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string311
                call    __puts
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [402]       Halt;
                jp      __done
; [403]     end;
false309:
; [404] 
; [405]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false312
                jp      exit307         ; Exit
false312:
; [406] 
; [407]     P := 4.0 + I * 1.0 * CompSize;    (* Should we use Real here?    *)
                ld      hl,global304 + 0
                push    hl
                constfp 0x0083,0x0000,0x0000
                pushfp
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                constfp 0x0081,0x0000,0x0000
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                pushfp
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    FLOAT
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPADD
                exx
                pop     hl
                call    __storefp
; [408]     S := Int(P / 128);
                ld      hl,global305 + 0
                push    hl
                ld      hl,global304 + 0
                call    __loadfp
                pushfp
                ld      hl,128          ; Literal 128
                call    FLOAT
                exx
                popfp
                call    FPDIV
                call    INT
                exx
                pop     hl
                call    __storefp
; [409]     (* WriteLn('Seeking to index ', I, ' offset ', P, ' sector ', S);*)
; [410]     BlockSeek(FCB, Trunc(S));  (* Why does div not work here? *)
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global305 + 0
                call    __loadfp
                call    FIX
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [411]     if S < BlockFileSize(FCB) then
                ld      hl,global305 + 0
                call    __loadfp
                pushfp
                push    hl
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockFileSize161
; Post call cleanup 2 bytes
                pop     hl
                pop     hl
                call    FLOAT
                exx
                popfp
                call    __fltlt
; [412]       BlockBlockRead(FCB, DMA, 1, E)
                ex      de,hl
                bit     0,l
                jp      z,false313
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global306 + 0
; [413]     else
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                jp      endif314
false313:
; [414]       BlockSeek(FCB, FCB.RL + 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
endif314:
; [415] 
; [416]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false315
                jp      exit307         ; Exit
false315:
; [417] 
; [418]     Offset := Trunc(P - 128 * S); (* Abs(P mod 128); *)
                ld      hl,(display+2)  ; Local Offset
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,global304 + 0
                call    __loadfp
                pushfp
                ld      de,128          ; Literal 128
                push    de
                ld      hl,global305 + 0
                call    __loadfp
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPSUB
                call    FIX
                ex      de,hl
                pop     hl
                ld      (hl),de
; [419] 
; [420]     CompIndex := I;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [421]   end;
                pop     bc
; [422] end;
exit307:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [423] 
; [424] procedure FileRead(var F: FileRec; var Comp);
; [425] var
                if      __USE__FileRead316
; [426]   Address, Need, Avail, Bytes, E: Integer;
global317:      ds      2,0             ; Global Address
global318:      ds      2,0             ; Global Need
global319:      ds      2,0             ; Global Avail
global320:      ds      2,0             ; Global Bytes
global321:      ds      2,0             ; Global E
; [427]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [428]   P: ^Byte absolute Address;
; [429] begin
; var F(+6), Comp(+4), Address(@global317), Need(@global318), Avail(@global319), Bytes(@global320), E(@global321), P(@global317)
__FileRead316:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [430]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false323
                jp      exit322         ; Exit
false323:
; [431] 
; [432]   (* WriteLn('Read entry #', FileFilePos(F)); *)
; [433] 
; [434]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [435]   begin
; [436]     Address := Addr(Comp);
                push    de
                ld      hl,global317 + 0
                push    hl
                ld      hl,(display+2)  ; Local Comp
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [437]     Need := CompSize;
                ld      hl,global318 + 0
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [438] 
; [439]     while Need <> 0 do
while324:
                ld      hl,(global318 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [440]     begin
                bit     0,l
                jp      z,false325
; [441]       Avail := 128 - Offset;
                ld      hl,global319 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [442]       if Avail >= Need then
                ld      hl,(global319 + 0)
                push    hl
                ld      hl,(global318 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [443]         Bytes := Need
                bit     0,l
                jp      z,false326
                ld      hl,global320 + 0
; [444]       else
                push    hl
                ld      hl,(global318 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
                jp      endif327
false326:
; [445]         Bytes := Avail;
                ld      hl,global320 + 0
                push    hl
                ld      hl,(global319 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
endif327:
; [446] 
; [447]       Move(DMA[Offset], P^, Bytes); (* Hmm... feels like a hack. *)
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global317 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global320 + 0)
                ld      bc,hl
                pop     de
                pop     hl
                call    __move
; [448]       Inc(Address, Bytes);
                ld      hl,global317 + 0
                push    hl
                ld      hl,(global320 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [449]       Inc(Offset, Bytes);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,(global320 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [450]       Dec(Need, Bytes);
                ld      hl,global318 + 0
                push    hl
                ld      hl,(global320 + 0)
                ld      bc,hl
                pop     hl
                call    __dec16by
; [451] 
; [452]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [453]       begin
                bit     0,l
                jp      z,false328
; [454]         FileFlush(F);
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush297
; Post call cleanup 2 bytes
                pop     hl
; [455]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileEof294
; Post call cleanup 2 bytes
                pop     hl
; [456]           BlockSeek(FCB, FCB.RL + 1)
                pop     hl
                bit     0,l
                jp      z,false329
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
; [457]         else
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                jp      endif330
false329:
; [458]           BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global321 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
endif330:
; [459]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false331
                jp      exit322         ; Exit
false331:
; [460]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,0
                ld      (hl),de
; [461]       end;
false328:
; [462]     end;
                jp      while324
false325:
; [463] 
; [464]     Inc(CompIndex);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                call    __inc16
; [465]   end;
                pop     bc
; [466] end;
exit322:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [467] 
; [468] procedure FileWrite(var F: FileRec; var Comp);
; [469] var
                if      __USE__FileWrite332
; [470]   Address, Need, Avail, Bytes, E: Integer;
global333:      ds      2,0             ; Global Address
global334:      ds      2,0             ; Global Need
global335:      ds      2,0             ; Global Avail
global336:      ds      2,0             ; Global Bytes
global337:      ds      2,0             ; Global E
; [471]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [472]   P: ^Byte absolute Address;
; [473] begin
; var F(+6), Comp(+4), Address(@global333), Need(@global334), Avail(@global335), Bytes(@global336), E(@global337), P(@global333)
__FileWrite332:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [474]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false339
                jp      exit338         ; Exit
false339:
; [475] 
; [476]   (* WriteLn('Wrote entry #', FileFilePos(F)); *)
; [477] 
; [478]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [479]   begin
; [480]     Address := Addr(Comp);
                push    de
                ld      hl,global333 + 0
                push    hl
                ld      hl,(display+2)  ; Local Comp
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [481]     Need := CompSize;
                ld      hl,global334 + 0
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [482] 
; [483]     while Need <> 0 do
while340:
                ld      hl,(global334 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [484]     begin
                bit     0,l
                jp      z,false341
; [485]       Avail := 128 - Offset;
                ld      hl,global335 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [486]       if Avail >= Need then
                ld      hl,(global335 + 0)
                push    hl
                ld      hl,(global334 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [487]         Bytes := Need
                bit     0,l
                jp      z,false342
                ld      hl,global336 + 0
; [488]       else
                push    hl
                ld      hl,(global334 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
                jp      endif343
false342:
; [489]         Bytes := Avail;
                ld      hl,global336 + 0
                push    hl
                ld      hl,(global335 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
endif343:
; [490] 
; [491]       Move(P^, DMA[Offset], Bytes); (* Hmm... feels like a hack. *)
                ld      hl,global333 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global336 + 0)
                ld      bc,hl
                pop     de
                pop     hl
                call    __move
; [492]       Inc(Address, Bytes);
                ld      hl,global333 + 0
                push    hl
                ld      hl,(global336 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [493]       Inc(Offset, Bytes);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,(global336 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [494]       Dec(Need, Bytes);
                ld      hl,global334 + 0
                push    hl
                ld      hl,(global336 + 0)
                ld      bc,hl
                pop     hl
                call    __dec16by
; [495]       Modified := True;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      de,1
                ld      (hl),e
; [496] 
; [497]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [498]       begin
                bit     0,l
                jp      z,false344
; [499]         FileFlush(F);
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush297
; Post call cleanup 2 bytes
                pop     hl
; [500]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false345
                jp      exit338         ; Exit
false345:
; [501] 
; [502]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileEof294
; Post call cleanup 2 bytes
                pop     hl
; [503]           BlockSeek(FCB, FCB.RL + 1)
                pop     hl
                bit     0,l
                jp      z,false346
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
; [504]         else
                push    hl
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                jp      endif347
false346:
; [505]           BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global337 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
endif347:
; [506] 
; [507]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,0
                ld      (hl),de
; [508]       end;
false344:
; [509]     end;
                jp      while340
false341:
; [510] 
; [511]     if CompIndex = CompCount then Inc(CompCount);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_eq
                and     a
                jp      z,false348
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                call    __inc16
false348:
; [512]     Inc(CompIndex);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,43
                add     hl,de
                call    __inc16
; [513]   end;
                pop     bc
; [514] end;
exit338:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [515] 
; [516] procedure FileClose(var F: FileRec);
; [517] var
                if      __USE__FileClose349
; [518]   E: Integer;
global350:      ds      2,0             ; Global E
; [519] begin
; var F(+4), E(@global350)
__FileClose349:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [520]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false352
                jp      exit351         ; Exit
false352:
; [521] 
; [522]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [523]   begin
; [524]     FileFlush(F);
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush297
; Post call cleanup 2 bytes
                pop     hl
; [525] 
; [526]     BlockSeek(FCB, 0);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [527]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global350 + 0
                push    hl
                call    __BlockBlockRead169
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [528] 
; [529]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false353
                jp      exit351         ; Exit
false353:
; [530] 
; [531]     HdrCount := CompCount;
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [532] 
; [533]     (*WriteLn('File closing: ', CompCount, '*', CompCount, ' --- ', HdrCount, '*', HdrSize);
; [534]     ReadLn; *)
; [535] 
; [536]     BlockSeek(FCB, 0);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek166
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [537]     BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,48
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global350 + 0
                push    hl
                call    __BlockBlockWrite177
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [538]     BlockClose(FCB);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockClose157
; Post call cleanup 2 bytes
                pop     hl
; [539]   end;
                pop     bc
; [540]   (* WriteLn('Closed file'); *)
; [541] end;
exit351:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [512] 
; [513] end.
; [0] program Day19;
; [1] 
; [2] {$a-}
; [3] {$m 16384}
; [4] 
; [5] {$I bigint.pas}
; [0] {$L bigint.asm}
                include "/Users/joerg/Projects/NetBeans/aoc24/src/day19/bigint.asm"
; [1] 
; [2] type
; [3]   BigInt = array[0..7] of Byte;
; [4] 
; [5] const
; [6]   BigMin: BigInt = (0, 0, 0, 0, 0, 0, 0, 0);
const354:
                db      0,0,0,0,0,0,0,0
; [7]   BigMax: BigInt = (255, 255, 255, 255, 255, 255, 255, 127);
const355:
                db      255,255,255,255,255,255,255,127
; [8]   BigOne: BigInt = (1, 0, 0, 0, 0, 0, 0, 0);
const356:
                db      1,0,0,0,0,0,0,0
; [9]   BigTen: BigInt = (10, 0, 0, 0, 0, 0, 0, 0);
const357:
                db      10,0,0,0,0,0,0,0
; [10] 
; [11] procedure BigAdd(var X, Y: BigInt); register; external 'bigadd';
; [12] procedure BigSub(var X, Y: BigInt); register; external 'bigsub';
; [13] procedure BigMul(var X, Y: BigInt); register; external 'bigmul';
; [14] procedure BigDiv(var X, Y, Z: BigInt); register; external 'bigdiv';
; [15] 
; [16] function BigCmp(var X, Y: BigInt): Integer;
; [17] var
                if      __USE__BigCmp362
; [18]   I: Integer;
; [19]   B: Byte;
; [20] begin
; var BigCmp(@RESULT), X(+6), Y(+4), I(-2), B(-4)
__BigCmp362:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [21]   for B := 7 downto 0 do
                push    hl
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                ld      de,7
                ld      (hl),e
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_geq
                and     a
                jp      z,forbreak365
forloop364:
; [22]   begin
; [23]     I := X[B] - Y[B];
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                push    hl
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local Y
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [24]     if I <> 0 then
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [25]     begin 
                bit     0,l
                jp      z,false367
; [26]       BigCmp := I; 
                ld      hl,(display+2)  ; Local BigCmp
                ld      de,8
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [27]       Exit;
                jp      exit363         ; Exit
; [28]     end;
false367:
; [29]   end;
fornext366:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_lt
                and     a
                jp      z,forbreak365
                ld      hl,(display+2)  ; Local B
                ld      de,-4
                add     hl,de
                dec     (hl)
                jp      forloop364
forbreak365:    pop     de              ; Cleanup limit
; [30] 
; [31]   BigCmp := 0;
                ld      hl,(display+2)  ; Local BigCmp
                ld      de,8
                add     hl,de
                ld      de,0
                ld      (hl),de
; [32] end;
exit363:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [33] 
; [34] procedure BigVal(S: String; var X: BigInt);
; [35] var
                if      __USE__BigVal368
; [36]   B: Byte;
; [37]   Y: BigInt;
; [38]   I, J: Integer;
; [39] begin
; var S(+6), X(+4), B(-2), Y(-10), I(-12), J(-14)
__BigVal368:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [40]   X := BigMin;
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const354 + 0
                ld      bc,8
                pop     de
                ldir
; [41] 
; [42]   if Length(S) < 3 then
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,3            ; Literal 3
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [43]   begin
                bit     0,l
                jp      z,false370
; [44]     Val(S, I, J);
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                ld      hl,(display+2)  ; Local I
                ld      de,-12
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local J
                ld      de,-14
                add     hl,de
                push    hl
                call    __val_int
; [45]     X[0] := I;
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                push    hl
                ld      hl,(display+2)  ; Local I
                ld      de,-12
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),e
; [46]     Exit;
                jp      exit369         ; Exit
; [47]   end;
false370:
; [48] 
; [49]   Y := BigMin;
                ld      hl,(display+2)  ; Local Y
                ld      de,-10
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                ld      bc,8
                pop     de
                ldir
; [50] 
; [51]   for B := 1 to Length(S) do
                ld      hl,(display+2)  ; Local B
                dec     hl
                dec     hl
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local B
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak372
forloop371:
; [52]   begin
; [53]     BigMul(X, BigTen);
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const357 + 0
                ex      de,hl
                pop     hl
                call    bigmul
; [54]     Y[0] := Ord(S[B]) - 48;
                ld      hl,(display+2)  ; Local Y
                ld      de,-10
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local B
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,48           ; Literal 48
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [55]     BigAdd(X, Y); 
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Y
                ld      de,-10
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [56]   end;
fornext373:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local B
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak372
                ld      hl,(display+2)  ; Local B
                dec     hl
                dec     hl
                inc     (hl)
                jp      forloop371
forbreak372:    pop     de              ; Cleanup limit
; [57] end;
exit369:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [58] 
; [59] procedure BigStr(X: BigInt; var S: String);
; [60] var
                if      __USE__BigStr374
; [61]   Y: BigInt;
; [62] begin
; var X(+6), S(+4), Y(-8)
__BigStr374:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
                push    hl
; [63]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [64] 
; [65]   repeat
repeat376:
; [66]     BigDiv(X, BigTen, Y);
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,const357 + 0
                push    hl
                ld      hl,(display+2)  ; Local Y
                ld      de,-8
                add     hl,de
                ld      bc,hl
                pop     de
                pop     hl
                call    bigdiv
; [67]     S := '' + Char(48 + Y[0]) + S;
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,string103
                call    __loadstr
                ld      de,48           ; Literal 48
                push    de
                ld      hl,(display+2)  ; Local Y
                ld      de,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
; [68]   until BigCmp(X, BigMin) = 0;
                push    hl
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                push    hl
                call    __BigCmp362
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                and     a
                jp      z,repeat376
break377:
; [69] end;
exit375:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [6] 
; [7] type
; [8]   TowelPtr = ^Towel;
; [9]   Towel = record
; [10]     Pattern: String[10];
; [11]     Next: TowelPtr;
; [12]   end;
; [13] 
; [14] var
; [15]   Towels: array['a'..'z'] of TowelPtr;
global378:      ds      52,0            ; Global Towels
; [16] 
; [17]   Table: array[0..79] of BigInt;
global379:      ds      640,0           ; Global Table
; [18]   Used: array[0..79] of Boolean;
global380:      ds      80,0            ; Global Used
; [19] 
; [20]   Pattern: String;
global381:      ds      256,0           ; Global Pattern
; [21] 
; [22] procedure Init;
; [23] var
                if      __USE__Init382
; [24]   C: Char;
; [25] begin
; var C(-2)
__Init382:                              ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [26]   for C := 'a' to 'z' do
                push    hl
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      de,97
                ld      (hl),e
                ld      de,122          ; Literal 122
                push    de
                push    de
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak385
forloop384:
; [27]     Towels[C] := nil;
                ld      hl,global378 + 0
                push    hl
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,0
                ld      (hl),de
fornext386:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak385
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                inc     (hl)
                jp      forloop384
forbreak385:    pop     de              ; Cleanup limit
; [28] end;
exit383:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [29] 
; [30] procedure Clear;
; [31] var
                if      __USE__Clear387
; [32]   I: Integer;
; [33] begin
; var I(-2)
__Clear387:                             ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [34]   for I := 0 to 79 do
                push    hl
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,0
                ld      (hl),de
                ld      de,79           ; Literal 79
                push    de
                push    de
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak390
forloop389:
; [35]   begin
; [36]     Used[I] := False;
                ld      hl,global380 + 0
                push    hl
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,0
                ld      (hl),e
; [37]     Table[I] := BigMin;
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                ld      bc,8
                pop     de
                ldir
; [38]   end;
fornext391:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak390
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                call    __inc16
                jp      forloop389
forbreak390:    pop     de              ; Cleanup limit
; [39] end;
exit388:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [40] 
; [41] procedure AddTowel(S: String);
; [42] var
                if      __USE__AddTowel392
; [43]   C: Char;
; [44]   P: TowelPtr;
; [45] begin
; var S(+4), C(-2), P(-4)
__AddTowel392:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [46]   C := S[1];
                push    hl
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [47]   New(P);
                ld      hl,(display+2)  ; Local P
                ld      de,-4
                add     hl,de
                ld      de,13
                call    __getmem
; [48]   P^.Pattern := S;
                ld      hl,(display+2)  ; Local P
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                pop     de
                ld      a,10
                call    __movestr
; [49]   P^.Next := Towels[C];
                ld      hl,(display+2)  ; Local P
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                push    hl
                ld      hl,global378 + 0
                push    hl
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [50]   Towels[C] := P;
                ld      hl,global378 + 0
                push    hl
                ld      hl,(display+2)  ; Local C
                dec     hl
                dec     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [51] end;
exit393:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [52] 
; [53] function StrEquals(var A, B: Char; Len: Integer): Boolean; register; inline
__StrEquals394:
; [54] (
; [55]   $41 /               (*       ld b,c     *)
                db      65
; [56]   $1a /               (* loop: ld a, (de) *)
                db      26
; [57]   $be /               (*       cp (hl)    *)
                db      190
; [58]   $28 / $04 /         (*       jr z,pass  *)
                db      40,4
; [59]   $21 / $00 / $00 /   (*       ld hl, 0   *)
                db      33,0,0
; [60]   $c9 /               (*       ret        *)
                db      201
; [61]   $23 /               (* pass: inc hl     *)
                db      35
; [62]   $13 /               (*       inc de     *)
                db      19
; [63]   $10 / $f4 /         (*       djnz loop  *)
                db      16,244
; [64]   $21 / $01 / $00 /   (*       ld hl, 1   *)
                db      33,1,0
; [65]   $c9                 (*       ret        *)
; [66] );
                db      201
                ret
; [67] 
; [68] 
; [69] function NumberOfWays(Pattern: String): BigInt;
; [70] var
                if      __USE__NumberOfWays395
; [71]   I, J, LP, LT: Integer;
; [72]   C: Char;
; [73]   P: TowelPtr;
; [74] begin
; var NumberOfWays(@RESULT), Pattern(+4), I(-2), J(-4), LP(-6), LT(-8), C(-10), P(-12)
__NumberOfWays395:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [75]   for I := 0 to 79 do
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,0
                ld      (hl),de
                ld      de,79           ; Literal 79
                push    de
                push    de
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak398
forloop397:
; [76]     Table[I] := BigMin;
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                ld      bc,8
                pop     de
                ldir
fornext399:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak398
                ld      hl,(display+2)  ; Local I
                dec     hl
                dec     hl
                call    __inc16
                jp      forloop397
forbreak398:    pop     de              ; Cleanup limit
; [77] 
; [78]   LP := Byte(Pattern[0]);
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Pattern
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [79] 
; [80]   Table[LP + 1] := BigOne;
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ld      de,8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const356 + 0
                ld      bc,8
                pop     de
                ldir
; [81] 
; [82]   for J := LP downto 1 do
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
                ld      de,1            ; Literal 1
                push    de
                push    de
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_geq
                and     a
                jp      z,forbreak401
forloop400:
; [83]   begin
; [84]     C := Pattern[J];
                ld      hl,(display+2)  ; Local C
                ld      de,-10
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Pattern
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [85]     P := Towels[C];
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                push    hl
                ld      hl,global378 + 0
                push    hl
                ld      hl,(display+2)  ; Local C
                ld      de,-10
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [86]     while P <> nil do
while403:
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [87]     begin
                bit     0,l
                jp      z,false404
; [88]       LT := Byte(P^.Pattern[0]);
                ld      hl,(display+2)  ; Local LT
                ld      de,-8
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [89]       if J + LT <= LP + 1 then
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local LT
                ld      de,-8
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
; [90]         if StrEquals(Pattern[J], P^.Pattern[1], LT) then
                bit     0,l
                jp      z,false405
                ld      hl,(display+2)  ; Local Pattern
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                ld      hl,(display+2)  ; Local LT
                ld      de,-8
                add     hl,de
                ld      bc,(hl)
                pop     de
                pop     hl
                call    __StrEquals394
; [91]         begin
                bit     0,l
                jp      z,false406
; [92]           //GotoXY(J, 22);
; [93]           //Write(Copy(Pattern, J, LT));
; [94]           BigAdd(Table[J], Table[J + LT]);
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local LT
                ld      de,-8
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [95]           (*GotoXY(J, 22);
; [96]           //Write(#27'q', Copy(Pattern, J, LT));*)
; [97]         end;
false406:
false405:
; [98] 
; [99]       P := P^.Next;
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-12
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [100]     end;
                jp      while403
false404:
; [101]   end;
fornext402:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                and     a
                jp      z,forbreak401
                ld      hl,(display+2)  ; Local J
                ld      de,-4
                add     hl,de
                call    __dec16
                jp      forloop400
forbreak401:    pop     de              ; Cleanup limit
; [102] 
; [103]   NumberOfWays := Table[1];
                ld      hl,(display+2)  ; Local NumberOfWays
                ld      de,260
                add     hl,de
                push    hl
                ld      hl,global379 + 0
                push    hl
                ld      hl,1            ; Literal 1
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      bc,8
                pop     de
                ldir
; [104] end;
exit396:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [105] 
; [106] procedure Explore(Index: Integer; var Count: BigInt);
; [107] var
                if      __USE__Explore407
; [108]   I, LT, LP: Integer;
; [109]   P: TowelPtr;
; [110] begin
; var Index(+6), Count(+4), I(-2), LT(-4), LP(-6), P(-8)
__Explore407:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
                push    hl
; [111]   LP := Byte(Pattern[0]);
                push    hl
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                push    hl
                ld      hl,global381 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [112] 
; [113]   if Index = LP + 1 then
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
; [114]   begin
                bit     0,l
                jp      z,false409
; [115]     BigAdd(Count, BigOne);
                ld      hl,(display+2)  ; Local Count
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const356 + 0
                ex      de,hl
                pop     hl
                call    bigadd
; [116]     Exit;
                jp      exit408         ; Exit
; [117]   end;
false409:
; [118] 
; [119]   if not Used[Index] then
                ld      hl,global380 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
; [120]   begin
                bit     0,l
                jp      z,false410
; [121]     P := Towels[Pattern[Index]];
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                push    hl
                ld      hl,global378 + 0
                push    hl
                ld      hl,global381 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [122]     while P <> nil do
while411:
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [123]     begin
                bit     0,l
                jp      z,false412
; [124]       LT := Byte(P^.Pattern[0]);
                ld      hl,(display+2)  ; Local LT
                ld      de,-4
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),de
; [125] 
; [126]       if Index + LT <= LP + 1 then
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local LT
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local LP
                ld      de,-6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
; [127]         if StrEquals(Pattern[Index], P^.Pattern[1], LT) then
                bit     0,l
                jp      z,false413
                ld      hl,global381 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                ld      hl,(display+2)  ; Local LT
                ld      de,-4
                add     hl,de
                ld      bc,(hl)
                pop     de
                pop     hl
                call    __StrEquals394
; [128]           Explore(Index + LT, Table[Index]);
                bit     0,l
                jp      z,false414
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local LT
                ld      de,-4
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                call    __Explore407
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
false414:
false413:
; [129] 
; [130]       P := P^.Next;
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local P
                ld      de,-8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [131]     end;
                jp      while411
false412:
; [132]     
; [133]     Used[Index] := True;
                ld      hl,global380 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      de,1
                ld      (hl),e
; [134]   end;
false410:
; [135] 
; [136]   BigAdd(Count, Table[Index]);
                ld      hl,(display+2)  ; Local Count
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global379 + 0
                push    hl
                ld      hl,(display+2)  ; Local Index
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [137] end;
exit408:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [138] 
; [139] procedure Solve(Path: String);
; [140] var
                if      __USE__Solve415
; [141]   T: Text;
; [142]   S: String;
; [143]   C: Char;
; [144]   Part1: Integer;
; [145]   Part2, Tmp: BigInt;
; [146] begin
; var Path(+4), T(-256), S(-512), C(-514), Part1(-516), Part2(-524), Tmp(-532)
__Solve415:                             ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-532         ; Space
                add     hl,sp
                ld      sp,hl
; [147]   Part1 := 0;
                ld      hl,(display+2)  ; Local Part1
                ld      de,-516
                add     hl,de
                ld      de,0
                ld      (hl),de
; [148]   Part2 := BigMin;
                ld      hl,(display+2)  ; Local Part2
                ld      de,-524
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                ld      bc,8
                pop     de
                ldir
; [149] 
; [150]   Assign(T, Path);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Path
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __TextAssign185
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [151]   Reset(T);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextReset187
; Post call cleanup 2 bytes
                pop     hl
; [152] 
; [153]   S := '';
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,string103
                pop     de
                ld      a,255
                call    __movestr
; [154]   Read(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [155]   while C >= ' ' do
while417:
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                ld      h,0
                ld      l,a
; [156]   begin
                bit     0,l
                jp      z,false418
; [157]     if C >= 'a' then
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                call    __int16_geq
                ld      h,0
                ld      l,a
; [158]       S := S + C
                bit     0,l
                jp      z,false419
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                call    __loadstr
; [159]     else if C = ',' then
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
                jp      endif420
false419:
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,44           ; Literal 44
                call    __int16_eq
                ld      h,0
                ld      l,a
; [160]     begin
                bit     0,l
                jp      z,false421
; [161]       AddTowel(S);
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                call    __loadstr
                call    __AddTowel392
; Post call cleanup 256 bytes
                call    __rmstr
; [162]       S := '';
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,string103
                pop     de
                ld      a,255
                call    __movestr
; [163]     end;
false421:
endif420:
; [164] 
; [165]     Read(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,(display+2)  ; Local C
                ld      de,-514
                add     hl,de
                push    hl
                call    __TextReadChar194
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [166]   end;
                jp      while417
false418:
; [167] 
; [168]   AddTowel(S);
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                call    __loadstr
                call    __AddTowel392
; Post call cleanup 256 bytes
                call    __rmstr
; [169] 
; [170]   ReadLn(T, S);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                call    __TextReadStr201
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [171]   while not Eof(T) do
while422:
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextEof254
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [172]   begin
                bit     0,l
                jp      z,false423
; [173]     ReadLn(T, Pattern);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global381 + 0
                push    hl
                call    __TextReadStr201
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [174]     GotoXY(1, 6);
                ld      hl,1            ; Literal 1
                ld      de,6            ; Literal 6
                call    __gotoxy
; [175]     Write(#27'M');
                ld      hl,string424
                call    __puts
; [176]     GotoXY(1, 22);
                ld      hl,1            ; Literal 1
                ld      de,22           ; Literal 22
                call    __gotoxy
; [177]     Write(Pattern);
                ld      hl,global381 + 0
                call    __puts
; [178]     (*Clear;*)
; [179]     Tmp := NumberOfWays(Pattern);
                ld      hl,(display+2)  ; Local Tmp
                ld      de,-532
                add     hl,de
                push    hl
                push    hl
                push    hl
                push    hl
                push    hl
                ld      hl,global381 + 0
                call    __loadstr
                call    __NumberOfWays395
; Post call cleanup 256 bytes
                call    __rmstr
                ld      bc,8
                call    __store16
; [180]     if BigCmp(Tmp, BigMin) <> 0 then
                push    hl
                ld      hl,(display+2)  ; Local Tmp
                ld      de,-532
                add     hl,de
                push    hl
                ld      hl,const354 + 0
                push    hl
                call    __BigCmp362
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [181]       Inc(Part1);
                bit     0,l
                jp      z,false425
                ld      hl,(display+2)  ; Local Part1
                ld      de,-516
                add     hl,de
                call    __inc16
false425:
; [182] 
; [183]     BigStr(Tmp, S);
                ld      hl,(display+2)  ; Local Tmp
                ld      de,-532
                add     hl,de
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                call    __BigStr374
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [184]     GotoXY(60, 22); Write(' -> ', S:15);
                ld      hl,60           ; Literal 60
                ld      de,22           ; Literal 22
                call    __gotoxy
                ld      hl,string426
                call    __puts
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                call    __loadstr
                ld      bc,15           ; Literal 15
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                call    __rmstr
; [185] 
; [186]     BigAdd(Part2, Tmp);
                ld      hl,(display+2)  ; Local Part2
                ld      de,-524
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Tmp
                ld      de,-532
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [187] 
; [188]     GotoXY(9, 3);
                ld      hl,9            ; Literal 9
                ld      de,3            ; Literal 3
                call    __gotoxy
; [189]     Write(Part1:15);
                ld      hl,(display+2)  ; Local Part1
                ld      de,-516
                add     hl,de
                ld      de,(hl)
                push    de
                ld      bc,15           ; Literal 15
                pop     hl
                call    __putn_fmt
; [190]     GotoXY(9, 4);
                ld      hl,9            ; Literal 9
                ld      de,4            ; Literal 4
                call    __gotoxy
; [191]     BigStr(Part2, S);
                ld      hl,(display+2)  ; Local Part2
                ld      de,-524
                add     hl,de
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                push    hl
                call    __BigStr374
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [192]     Write(S: 15);
                ld      hl,(display+2)  ; Local S
                ld      de,-512
                add     hl,de
                call    __loadstr
                ld      bc,15           ; Literal 15
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                call    __rmstr
; [193]   end;
                jp      while422
false423:
; [194] 
; [195]   Close(T);
                ld      hl,(display+2)  ; Local T
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextClose238
; Post call cleanup 2 bytes
                pop     hl
; [196] end;
exit416:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [197]     
; [198] var
; [199]   S, T: String;
global427:      ds      256,0           ; Global S
global428:      ds      256,0           ; Global T
; [200] 
; [201] begin
; var BigMin(@const354), BigMax(@const355), BigOne(@const356), BigTen(@const357), Towels(@global378), Table(@global379), Used(@global380), Pattern(@global381), S(@global427), T(@global428)
main:
                ld      (display),sp
                call    __InitHeap20
; [202]   Write(#27'E'#27'f');
                ld      hl,string430
                call    __puts
; [203]   WriteLn('*** AoC 2024.19 Linen Layout ***');
                ld      hl,string431
                call    __puts
                call    __newline
; [204]   WriteLn;
                call    __newline
; [205]   WriteLn('Part 1:');
                ld      hl,string432
                call    __puts
                call    __newline
; [206]   WriteLn('Part 2:');
                ld      hl,string433
                call    __puts
                call    __newline
; [207] (*
; [208]   S := 'HALLO';
; [209]   T := 'HAILO';
; [210]   WriteLn(StrEquals(S[1], T[1], 5));
; [211] *)
; [212]   //InitHeap(32768);
; [213]   Init;
                call    __Init382
; [214]   Solve('INPUT   .TXT');
                ld      hl,string434
                call    __loadstr
                call    __Solve415
; Post call cleanup 256 bytes
                call    __rmstr
; [215] 
; [216]   GotoXY(1, 23);
                ld      hl,1            ; Literal 1
                ld      de,23           ; Literal 23
                call    __gotoxy
; [217]   Write(#27'e');
                ld      hl,string435
                call    __puts
; [218] end.
                ret
string54:       db      2,13,10
string103:      db      0
string115:      db      11,"BDos error "
string281:      db      17,"Invalid file type"
string310:      db      4,"*** "
string311:      db      3," > "
string424:      db      2,27,"M"
string426:      db      4," -> "
string430:      db      4,27,"E",27,"f"
string431:      db      32,"*** AoC 2024.19 Linen Layout ***"
string432:      db      7,"Part 1:"
string433:      db      7,"Part 2:"
string434:      db      12,"INPUT   .TXT"
string435:      db      2,27,"e"
display:        ds      16,0            ; Display
eof:                                    ; End of file
__USE__Solve415:equ     1
__USE__Explore407:equ     0
__USE__NumberOfWays395:equ     1
__USE__AddTowel392:equ     1
__USE__Clear387:equ     0
__USE__Init382: equ     1
__USE__BigStr374:equ     1
__USE__BigVal368:equ     0
__USE__BigCmp362:equ     1
__USE__FileClose349:equ     0
__USE__FileWrite332:equ     0
__USE__FileRead316:equ     0
__USE__FileSeek303:equ     0
__USE__FileFlush297:equ     0
__USE__FileEof294:equ     0
__USE__FileFilePos291:equ     0
__USE__FileFileSize288:equ     0
__USE__FileRewrite282:equ     0
__USE__FileReset275:equ     0
__USE__FileAssign272:equ     0
__USE__TextAppend269:equ     0
__USE__TextSeekEoln263:equ     0
__USE__TextSeekEof256:equ     0
__USE__TextEof254:equ     1
__USE__TextEoln252:equ     0
__USE__TextWriteEoln250:equ     0
__USE__TextWriteStr243:equ     0
__USE__TextClose238:equ     1
__USE__TextFlush233:equ     1
__USE__TextWriteChar228:equ     1
__USE__TextReadFloat224:equ     0
__USE__TextReadInt220:equ     0
__USE__TextReadWord212:equ     0
__USE__TextReadStr201:equ     1
__USE__TextReadChar194:equ     1
__USE__TextRewrite191:equ     0
__USE__TextReset187:equ     1
__USE__TextAssign185:equ     1
__USE__BlockBlockWrite177:equ     1
__USE__BlockBlockRead169:equ     1
__USE__BlockSeek166:equ     0
__USE__BlockEof164:equ     0
__USE__BlockFileSize161:equ     0
__USE__BlockFilePos159:equ     0
__USE__BlockClose157:equ     1
__USE__BlockRewrite153:equ     0
__USE__BlockReset149:equ     1
__USE__BlockRename144:equ     0
__USE__BlockErase140:equ     0
__USE__BlockAssign116:equ     1
__USE__BDosThrow112:equ     0
__USE__BDosCatch107:equ     1
__USE__IOResult105:equ     0
__USE__ParamStr88:equ     0
__USE__ParamCount78:equ     0
__USE__Delay75: equ     0
__USE__ReadKey71:equ     0
__USE__KeyPressed69:equ     0
__USE__InitHeap20:equ     1
__USE__MaxAvail13:equ     0
__USE__MemAvail7:equ     0
TEXT_END:       =       $
STACK:          =       $B000
HEAP:           =       STACK-32767
                if      HEAP < $
HEAP:           =       $
                endif
                if      HEAP > STACK
HEAP:           =       STACK
                endif
; end
                LUA
                if      sj.calc("__ERRORS__") ~= 0 then print() end
                SegInfo("Program",sj.calc("TEXT"),sj.calc("$"),sj.calc("STACK-TEXT"), "")
                SegInfo("Heap",sj.calc("HEAP"),sj.calc("STACK"), 32767, "")
                SegInfo("Stack",sj.calc("STACK"),sj.calc("LIMIT"),16384, "")
                ENDLUA
                savebin "/Users/joerg/Projects/NetBeans/aoc24/src/day19/day19.com",$0100,HEAP-$0100
