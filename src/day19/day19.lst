; --------------------------------------
; zasm: assemble "day19.z80"
; date: 2024-12-23 16:14:27
; --------------------------------------


; program day19.pas
CPM:            equ     1               ; Target is CP/M .com file
                include "/Users/joerg/Projects/pl0/pl0.z80"
;
; PL0 built-in assembler functions
;

#if defined(CPM)
                org     $100
#endif

#if defined(NXT)
                org     $2000
#endif

                jp      main

;
; Some stuff shared between the routines
;
#if defined(CPM)
__buffer:       ds      32
#endif

#if defined(NXT)
__saved_iy:     dw      0
__win_handle:   dw      0
__buffer:       equ     23698
#endif

__linemax:      ds      1
__linelen:      ds      1
__linebuf:      ds      128
;
; Boolean literals
;
__boolean1:     db      4,"True"
__boolean0:     db      5,"False"
__boolean_enum: dw __boolean0, __boolean1

;
; Signed 16 bit '=' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_eq:     xor a
                sbc hl,de
                ; add hl,de
                ret nz
                inc a
                ret

;
; Signed 16 bit '<>' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_neq:    xor a
                sbc hl,de
                ; add hl,de
                ret z
                inc a
                ret

;
; Signed 16 bit 'lt' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_lt:     xor a
                sbc hl,de
                ; add hl,de
                jp pe,__int16_lt_of
                ret p
                inc a
                ret
__int16_lt_of:  ret m
                inc a
                ret

;
; Signed 16 bit '>=' check (with help from Ped7g)
;
; In:   HL (left), DE (right)
; Out:  A=0 if false, A=1 if true
;
__int16_geq:    xor a
                sbc hl,de
                ; add hl,de
                jp pe,__int16_geq_of
                ret m
                inc a
                ret
__int16_geq_of: ret p
                inc a
                ret

; Signed bc <= de <= hl check

__int16_case:   push    de
                call    __int16_geq
                pop     hl
                and     a
                ret     z
                push    hl
                ld      de,bc
                call    __int16_geq
                pop     de
                and     a
                ret     z
                inc     a
                ret

; Signed 16 bit left-shift 
;
; Entry: HL (Number), E (number of Bits)
; Exit:  HL (Number)
__int_shl:      ld a,e
                and a
                ret z
                ld b,a
__int_shl1:
                sla l
                rl h
                djnz __int_shl1
                ret

; Signed 16 bit right-shift 
;
; Entry: HL (Number), E (number of Bits)
; Exit:  HL (Number)
__int_shr:      ld a,e
                and a
                ret z
                ld b,a
__int_shr1:
                srl h
                rr l
                djnz __int_shr1
                ret

;
; Signed 16 bit multiplication (taken from Leventhal/Saville)
;
; Entry:  HL (multiplicand), DE (multiplier)
; Exit:   HL (product)
; Uses:   AF, BC
;
__mul16:        ld      c,l
                ld      b,h
                ld      hl,0
                ld      a,15
__mul16a:       sla     e
                rl      d
                jr      nc,__mul16b
                add     hl,bc
__mul16b:       add     hl,hl
                dec     a
                jr      nz,__mul16a
                or      d
                ret     p
                add     hl,bc
                ret

;
; Signed 16 bit division (taken from Leventhal/Saville)
;
; Entry:  HL (dividend), DE (divisior)
; Exit:   HL (quotient), DE (remainder), CF (div-by-zero)
; Uses:   AF, BC
;
__sdiv16:       ld      a,h
                ld      (__srem),a
                xor     d
                ld      (__squot),a
                ld      a,d
                or      a
                jp      p,__chkde
                sub     a
                sub     e
                ld      e,a
                sbc     a,a
                sub     d
                ld      d,a
__chkde:        ld      a,h
                or      a
                jp      p,__dodiv
                sub     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
__dodiv:        call    __udiv16
                ret     c
                ld      a,(__squot)
                or      a
                jp      p,__dorem
                sub     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
__dorem:        ld      a,(__srem)
                or      a
                ret     p
                sub     a
                sub     e
                ld      e,a
                sbc     a,a
                sub     d
                ld      d,a
                ret
__udiv16:       ld      a,e
                or      d
                jr      nz,__divide
                ld      hl,0
                ld      d,h
                ld      e,l
                scf
                ret
__divide:       ld      c,l
                ld      a,h
                ld      hl,0
                ld      b,16
                or      a
__dvloop:       rl      c
                rla
                rl      l
                rl      h
                push    hl
                sbc     hl,de
                ccf
                jr      c,__drop
                ex      (sp),hl
__drop:         inc     sp
                inc     sp
                djnz    __dvloop
                ex      de,hl
                rl      c
                ld      l,c
                rla
                ld      h,a
                or      a
                ret

__squot:        ds      1
__srem:         ds      1
__count:        ds      1

;
; Multiplication by 10
;
; Entry:  HL (multiplicand)
; Exit:   HL (product)
; Uses:   DE
;
__mul10:    
                ex      hl,de
                add     hl,hl
                ld      de,hl
                add     hl,hl
                add     hl,hl
                add     hl,de
                ex      hl,de
                ret

;
; Division by 10 (taken from Z80 Heaven)
;
; Entry:  HL (dividend)
; Exit:   HL (quotient), A (remainder)
; Uses:   AF, BC
;
__div10:    
                ld      bc,$0D0A
                xor     a
                add     hl,hl
                rla
                add     hl,hl
                rla
                add     hl,hl
                rla
__div10a:       add     hl,hl
                rla
                cp      c
                jr c,   __div10b
                sub c
                inc l
__div10b:       djnz __div10a
                ret

; Fallthrough intended
__abs16:
                bit     7,h
                ret     z

; Negation from Z80 Heaven
__neg16:
                xor     a
                sub     l
                ld      l,a
                sbc     a,a
                sub     h
                ld      h,a
                ret

;
;
;
;

__random:
    ; ex hl,de
    call __rand16
    res 7,h
    call __sdiv16
    ex hl,de
    ret

__random48:
    ; ex hl,de
    call __rand16
    push hl
    call __rand16
    push hl
    call __rand16
    pop de
    pop bc
    res 7,b
    ld   l,$81
    call FRAC
    ret

;#define smc    ;uncomment if you are using SMC
__rand16:
;;collaboration by Zeda with Runer112
;;160cc or 148cc if using SMC
;;26 bytes
;;cycle: 4,294,901,760 (almost 4.3 billion)
#if defined(smc)
seed1=$+1
    ld hl,9999
#else
    ld hl,(seed1)
#endif
    ld b,h
    ld c,l
    add hl,hl
    add hl,hl
    inc l
    add hl,bc
    ld (seed1),hl
#if defined(smc)
seed2=$+1
    ld hl,9999
#else
    ld hl,(seed2)
#endif
    add hl,hl
    sbc a,a
    and %00101101
    xor l
    ld l,a
    ld (seed2),hl
    add hl,bc
    ret
seed1:              dw 1234
seed2:              dw 5678

; String Compare Leventhal Saville P.290
;
; HL string 1
; DE string 2
; Result: Z=1, C=0 1<2
; Z =0, C=0 1>2
; Z=0, C=1 1<2


__strcmp:
        ld      a,(hl)
        ld      (__lens1),a
        ld      a,(de)
        ld      (__lens2),a
        cp      (hl)
        jr      c,__begcmp
        ld      a,(hl)
__begcmp:
        or      a
        jr      z,__cmplen
        ld      b,a
        ex      de,hl
__cmplp:
        inc     hl
        inc     de
        ld      a,(de)
        cp      (hl)
        ret     nz
        djnz    __cmplp
__cmplen:
        ld      a,(__lens1)
        ld      hl,__lens2
        cp      (hl)
        ret
__lens1:
        ds      1
__lens2:
        ds      1

; String concatenate
; HL = String 1, DE = String 2, B = max len, CF=1 if shortened
__strcat:
        ld      (__s1adr),hl
        push    bc
        ld      a,(hl)
        ld      (__s1len),a
        ld      c,a
        ld      b,0
        add     hl,bc
        inc     hl
        ld      a,(de)
        ld      (__s2len),A
        inc     de
        pop     bc
        ld      c,a
        ld      a,(__s1len)
        add     a,c
        jr      c,__toolng
        cp      b
        jr      z,__lenok
        jr      c,__lenok
__toolng:
        ld      a,255
        ld      (__strgov),a
        ld      a,(__s1len)
        ld      c,a
        ld      a,b
        sub     c
        ret     c
        ld      (__s2len),a
        ld      a,b
        ld      (__s1len),a
        jr      __docat
__lenok:
        ld      (__s1len),a
        sub     a
        ld      (__strgov),a
__docat:
        ld      a,(__s2len)
        or      a
        jr      z,__exit
        ld      c,a
        ld      b,0
        ex      de,hl
        ldir
__exit:
        ld      a,(__s1len)
        ld      hl,(__s1adr)
        ld      (hl),a
        ld      a,(__strgov)
        rra
        ret
__s1adr:
        ds      2
__s1len:
        ds      1
__s2len:
        ds      1
__strgov:
        ds      1

; String pos
__strpos:
        ld      (__string),hl
        ex      de,hl
        ld      a,(hl)
        or      a
        jr      z,__notfnd
        inc     hl
        ld      (__substg),hl
        ld      (__sublen),a
        ld      c,a
        ld      a,(de)
        or      a
        jr      z,__notfnd
        sub     c
        jr      c,__notfnd
        inc     a
        ld      b,a
        sub     a
        ld      (__index),a
__slp1:
        ld      hl,__index
        inc     (hl)
        ld      hl,__sublen
        ld      c,(hl)
        ld      hl,(__string)
        inc     hl
        ld      (__string),hl
        ld      de,(__substg)
__cmplp2:
        ld      a,(de)
        cp      (hl)
        jr      nz,__slp2
        dec     c
        jr      z,__found
        inc     hl
        inc     de
        jr      __cmplp2
__slp2:
        djnz    __slp1
        jr      __notfnd
__found:
        ld      a,(__index)
        ret
__notfnd:
        sub     a
        ret
__string:
        ds      2
__substg:
        ds      2
__slen:
        ds      1
__sublen:
        ds      1
__index:
        ds      1


; strcpy
__strcpy:
        ld      (__maxlen),a
        sub     a
        ld      (de),a
        ld      (__cpyerr),a
        or      b
        ret     z
        ld      a,(__maxlen)
        or      a
        jr      z,__erexit
        ld      a,c
        or      a
        jr      z,__erexit
        ld      a,(hl)
        cp      c
        ret     c
        ld      a,c
        add     a,b
        jr      c,__recalc
        dec     a
        cp      (hl)
        jr      c,__cnt1ok
        jr      z,__cnt1ok
__recalc:
        ld      a,255
        ld      (__cpyerr),a
        ld      a,(hl)
        sub     c
        inc     a
        ld      b,a
__cnt1ok:
        ld      a,(__maxlen)
        cp      b
        jr      nc,__cnt2ok
        ld      b,a
        ld      a,255
        ld      (__cpyerr),a
__cnt2ok:
        ld      a,b
        or      a
        jr      z,__erexit
        ld      b,0
        add     hl,bc
        ld      (de),a
        ld      c,a
        inc     de
        ldir
        ld      a,(__cpyerr)
__okexit:
        or      a
        ret     z
__erexit:
        scf
        ret
__maxlen:
        ds      1
__cpyerr:
        ds      1

;Insert
__strins:
        sub     a
        ld      (__inserr),a
        ld      a,(de)
        or      a
        ret     z
__idx0:
        ld      a,c
        or      a
        scf
        ret     z
__chklen:
        ld      a,(de)
        add     a,(hl)
        jr      c,__trunc
        cp      b
        ld      a,(de)
        jr      c,__idxlen
        jr      z,__idxlen
__trunc:
        ld      a,255
        ld      (__inserr),a
        ld      a,b
        sub     (hl)
        ret     c
        scf
        ret     z
__idxlen:
        ld      b,a
        ld      a,(hl)
        cp      c
        jr      nc,__lenok2
        ld      c,a
        add     a,b
        ld      (hl),a
        ex      de,hl
        ld      a,c
        inc     a
        add     a,e
        ld      e,a
        jr      nc,__idxl1
        inc     d
__idxl1:
        ld      a,255
        ld      (__inserr),a
        jr      __mvesub
__lenok2:
        push    bc
        push    de
        ld      e,a
        ld      d,0
        add     a,b
        ld      (hl),a
        ld      a,e
        sub     c
        inc     a
        add     hl,de
        ld      e,l
        ld      d,h
        ld      c,b
        ld      b,0
        add     hl,bc
        ex      de,hl
        ld      c,a
        lddr
        ex      de,hl
        inc     de
        pop     hl
        pop     bc
__mvesub:
        inc     hl
        ld      c,b
        ld      b,0
        ldir
        ld      a,(__inserr)
        rra
        ret
__inserr:
        ds      1

; Delete
__strdel:
        sub     a
        ld      (__delerr),a
        or      b
        ret     z
        ld      a,c
        or      a
        scf
        ret     z
        ld      a,(hl)
        cp      c
        ret     c
        ld      a,c
        add     a,b
        jr      c,__trunc2
        ld      e,a
        dec     a
        cp      (hl)
        jr      c,__cntok
        jr      z,__trunc2
        ld      a,255
        ld      (__delerr),a
__trunc2:
        ld      a,c
        dec     a
        ld      (hl),a
        ld      a,(__delerr)
        rra
        ret
__cntok:
        ld      a,(hl)
        ld      d,a
        sub     b
        ld      (hl),a
        ld      a,d
        sub     e
        inc     a
        push    hl
        ld      b,0
        add     hl,bc
        ex      (sp),hl
        ld      d,0
        add     hl,de
        pop     de
        ld      c,a
        ldir
__okexit2:
        or      a
        ret
__delerr:
        ds      1        
;
; String "equal" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__streq:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     h
__streqnosp:
        ld      a,(de)
        cp      (hl)
        jr      nz,__streq0     ; Fast track if lengths differ
        call    __strcmp
        jr      z,__streq1
__streq0:
        ld      de,0

;        ld      (hl),de
        ret
__streq1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

;
; String "less than" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__strlt:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        call    __strcmp
        jr      c,__strlt1
__strlt0:
;        ld      a,0
        ld      de,0
;        ld      (hl),de
        ret
__strlt1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

;
; String "less than or equal" check. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE,BC,AF
;
__strleq:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        call    __strcmp
        jr      z,__strleq1
        jr      c,__strleq1
__strleq0:
        ld      de,0
;        ld      (hl),de
;        ld      a,0
        ret
__strleq1:
        ld      de,1
;        ld      (hl),de
;        ld      a,1
        ret

; Concat
__stradd:
        ld      hl,258
        add     hl,sp
        ld      de,hl
        dec     d
        ld      b,255
        call    __strcat
        ret

__pos:
        ld      hl,514
        add     hl,sp
        push    hl
        dec     h
        ld      de,hl
        dec     d
        ex      de,hl
        call    __strpos
        pop     hl
        ld      (hl),a
        inc     hl
        ld      (hl),0
        ret

__copy:
        ld      hl,2
        add     hl,sp
        ld      b,(hl)
        inc     hl
        inc     hl
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      de,hl
        inc     d
        ld      a,255
        call    __strcpy
        ret

__insert:
        ld      hl,2
        add     hl,sp
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      de,hl
        ld      h,(hl)
        ld      l,a
        inc     de

        ld      b,255
        call    __strins
        ret

__delete:
        ld      hl,2
        add     hl,sp
        ld      b,(hl)
        inc     hl
        inc     hl
        ld      c,(hl)
        inc     hl
        inc     hl
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
        call    __strdel
        ret

__str_int:
        ld      hl,2
        add     hl,sp
        ld      bc,(hl)
        inc     hl
        inc     hl
        ld      de,(hl)
        ld      hl,bc
        push    hl
        inc     hl
        call    __itoa
        pop     hl
        ld      (hl),a
        ret

__val_int:
        ld      hl,6
        add     hl,sp
        ld      a,(hl)
        inc     hl
        call    __atoi
        ld      hl,4        
        add     hl,sp
        ld      bc,(hl)
        ld      hl,bc
        ld      (hl),de
        pop     de
        ld      hl,260
        add     hl,sp
        ld      sp,hl
        push    de
        ret                     ; FIXME: Error reporting 

__val_float:
        ld      hl,6
        add     hl,sp
;        ld      a,(hl)
;        inc     hl
        call    __atof
        exx
        pop     de
        pop     bc
        pop     hl
        call    __storefp
        exx
        ld      hl,256
        add     hl,sp
        ld      sp,hl
        push    de
        ret                     ; FIXME: Error reporting 

; string on stack, de table, b size, a contains code if found, 255 if not
__val_enum:     ld      hl,6
                add     hl,sp
                call    __atoe
                ld      a,d
                and     a
                jr      nz,__val_enum1

                ld      hl,4            ; Result
                add     hl,sp
                ld      bc,(hl)
                ld      hl,bc
                ld      (hl),e
                inc     hl
                ld      (hl),a                
                ld      e,0

__val_enum1:    ld      hl,2            ; Error
                add     hl,sp
                ld      bc,(hl)
                ld      hl,bc
                ld      (hl),e
                xor     a
                inc     hl
                ld      (hl),a                

                pop     de
                ld      hl,260
                add     hl,sp
                ld      sp,hl
                push    de
                ret                     ; FIXME: Error reporting 

__val_enum2:    ld      a,c
                ld      hl,4        
                add     hl,sp
                ld      bc,(hl)
                ld      hl,bc
                ld      (hl),a
                pop     de
                ld      hl,260
                add     hl,sp
                ld      sp,hl
                push    de
                ret                     ; FIXME: Error reporting 

;
; String length. Arguments and result on stack.
;
; Entry:    -
; Exit:     -
; Uses:     HL,DE
;
__length:
        ld      hl,2
        add     hl,sp
        ld      d,0
        ld      e,(hl)
        inc     h
        ld      (hl),de
        ret

;
; Load string from HL to stack, return properly.
;
__loadstr:
        pop     bc
        ex      de,hl
        ld      hl,-256
        add     hl,sp
        ld      sp,hl
        ex      de,hl
        push    bc
        ld      a,255
        call    __movestr
        ret

;
; Store string of max length A from stack to address, cleanup stack, return properly.
;
__storestr:
        ld      hl,258
        add     hl,sp
        ld      de,(hl)
        dec     h
        call    __movestr
        pop     bc
        ld      hl,258
        add     hl,sp
        ld      sp,hl
        push    bc
        ret

;
; Move string of max length A from HL to DE, bypassing the stack.
;
__movestr:
        ld      b,(hl)
        cp      b
        jp      c,__movestr_1
        ld      a,b
__movestr_1:
        ld      (de),a
        and     a
        ret     z
        inc     hl
        inc     de
        ld      b,0
        ld      c,a
        ldir
        ret

__mkstr:        pop     de
                ld      hl,-256
                add     hl,sp
                ld      sp,hl
                ex      de,hl
                jp      (hl)

__rmstr:        pop     de
                ld      hl,256
                add     hl,sp
                ld      sp,hl
                ex      de,hl
                jp      (hl)

__char2str:     ld      b,e
                pop     de
                ld      hl,-254
                add     hl,sp
                ld      sp,hl
                ld      c,1
                push    bc
                ex      de,hl
                jp      (hl)

__load16:       pop     de
                ex      de,hl
                ld      (__load16ret),hl
                and     a
                sbc     hl,hl
                sbc     hl,bc
                add     hl,sp
                ld      sp,hl
                ex      de,hl
                ldir
                ld      hl,(__load16ret)
                jp      (hl)
__load16ret:    ds      2

__store16:      pop     hl
                ld      (__store16ret),hl
                ld      hl,bc
                add     hl,sp
                ld      de,(hl)
                ld      hl,0
                add     hl,sp
                ldir
                ld      sp,hl
                pop     hl
                ld      hl,(__store16ret)
                jp      (hl)
__store16ret:   ds      2

__inc16:        inc     (hl)
                ret     nz
                inc     hl
                inc     (hl)
                ret

__inc16by:      ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                add     hl,bc
                ex      de,hl
                ld      (hl),d
                dec     hl
                ld      (hl),e
                ret

__dec16:        ld      a,(hl)
                sub     1
                ld      (hl),a
                ret     nc
                inc     hl
                dec     (hl)
                ret

__dec16by:      ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                and     a
                sbc     hl,bc
                ex      de,hl
                ld      (hl),d
                dec     hl
                ld      (hl),e
                ret

#include "math48.z80"
;       Math48 Floating Point Package
;       Version 1.1 Revision 1
;       by Anders Hejlsberg
;       2532 Bytes

;HOPTABEL

        JP   FPADD
        JP   FPSUB
        JP   FPMUL
        JP   FPDIV
        JP   MOD
        JP   PWR
        JP   CMP

        JP   SQR
        JP   LN
        JP   EXP
        JP   LOG
        JP   SIN
        JP   COS
        JP   TAN
        JP   ATN
        JP   ACPI
        JP   INT
        JP   FRAC

        JP   EQUAL
        JP   MUL10
        JP   FIX
        JP   FLOAT

        JP   FSTRS
        JP   FSTRR
        JP   CNVN


SIGN:   EQU  80H
EXPN:   EQU  80H

IWIDTH: EQU  0F0H
FWIDTH: EQU  0FH


;FLOATING POINT ADDITION.

FPADD:  EXX             ;Er AC negativ?
        BIT  7,B
        EXX
        JP   NZ,SUB1    ;Ja => SUB1

ADD1:   EXX             ;Er AC' nul?
        LD   A,L
        OR   A
        EXX
        RET  Z          ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EXX

        LD   A,L        ;Er AC nul?
        OR   A
        JR   NZ,ADD2    ;Nej => ADD2
        EXX             ;Returner AC'
        RES  7,B        ;Positivt
        JR   ADD10

ADD2:   PUSH BC         ;Gem fortegn
        SET  7,B        ;Saet MSB
        XOR  A          ;Saet Z'
        EX   AF,AF'
        EXX
        SET  7,B        ;Saet MSB'
        LD   A,L        ;A=EXP'-EXP
        EXX
        SUB  L
        JR   Z,ADD4     ;EXP=EXP' => ADD4
        JR   NC,ADD3    ;EXP<EXP' => ADD3

        NEG             ;Goer A positiv
        EX   AF,AF'     ;Nulstil Z'
        DEC  A
        EX   AF,AF'
        EXX             ;Juster AC'

ADD3:   CALL SRIGHT     ;Skift til hoejre
        INC  L          ;Er EXP=EXP'?
        DEC  A
        JR   NZ,ADD3    ;Nej => ADD3

        EX   AF,AF'     ;Var det AC'?
        JR   Z,ADD4     ;Nej => ADD4
        EXX             ;Ja => Ombyt

ADD4:   POP  AF         ;Hent AC fortegn
        AND  SIGN       ;Negativt?
        JR   NZ,ADD5    ;Ja => ADD5

        CALL ADDAC      ;MANT=MANT+MANT'
        JR   NC,ADD9    ;Ikke overflow => ADD9
        CALL RIGHT      ;Roter til hoejre
        OR   A
        INC  L          ;Juster exponent
        JR   NZ,ADD9
        SCF
        JR   ADD10

ADD5:   CALL CMPAC      ;Sammenlign
        CCF             ;Komplementer carry og
        PUSH AF         ;gem som fortegn
        JR   Z,ADDZ     ;AC=AC' => ADDZ
        JR   C,ADD6     ;AC>AC' => ADD6
        EXX             ;AC<AC' => Ombyt
ADD6:   CALL SUBAC      ;MANT=MANT-MANT'
ADD7:   BIT  7,B        ;Normaliseret?
        JR   NZ,ADD8    ;Ja => ADD8
        CALL SLEFT      ;Skift til venstre
        INC  L          ;Er exponent -128?
        DEC  L
        JR   Z,ADDZ     ;Ja => AC lig nul
        DEC  L          ;Traek 1 fra exponent
        JR   ADD7

ADDZ:   CALL ZERO

ADD8:   POP  AF         ;Hent fortegn
ADD9:   JR   C,ADD9A    ;Carry => negativt
        RES  7,B
ADD9A:  OR   A

ADD10:  EXX             ;Hent AC'
        POP  HL
        POP  DE
        POP  BC
        EXX
        RET


;FLOATING POINT SUBTRAKTION

FPSUB:  EXX             ;Er AC negativ?
        BIT  7,B
        EXX
        JP   NZ,ADD1    ;Ja => ADD1

SUB1:   CALL FPNEG      ;AC=-AC
        CALL ADD1       ;Laeg AC' til AC

FPNEG:  INC  L          ;Er AC nul?
        DEC  L
        RET  Z          ;Ja => Returner
        EX   AF,AF'     ;Gem carry
        LD   A,B        ;Komplementer fortegn
        XOR  SIGN
        LD   B,A
        EX   AF,AF'     ;Hent carry
        RET


;FLOATING POINT DIVISION.

FPDIV:  EXX             ;Er AC' nul?
        INC  L
        DEC  L
        EXX
        SCF
        RET  Z          ;Ja => Overflow

        LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Returner

        EXX             ;Subtraher exponenter
        SUB  L
        EXX
        CCF             ;Juster exponent og
        CALL EXPSGN     ;udregn fortegn

        PUSH HL         ;Opret 6 bytes work-
        PUSH HL         ;space
        PUSH HL
        ADD  IX,SP

        EXX             ;5 bytes
        LD   L,5
        EXX
        LD   A,8        ;Med hver 8 bits

DIVI1:  EX   AF,AF'     ;Gem taeller
        CALL CMPAC      ;Er MANT>MANT'
        JR   C,DIVI2    ;Nej => DIVI2
        CALL SUBAC      ;Traek AC' fra AC

DIVI2:  CCF             ;Komplementer carry
        RL   L          ;Roter ind i resultat
        EX   AF,AF'     ;Hent bittaeller
        DEC  A          ;Byte faerdig?
        JR   NZ,DIVI3   ;Nej => DIVI3

        LD   (IX+5),L   ;Gem byte i buffer
        DEC  IX         ;Peg til naeste
        EXX             ;Er 5 bytes klaret?
        DEC  L
        EXX
        JR   Z,DIVI4    ;Ja => DIVI4
        LD   A,8        ;8 bits

DIVI3:  CALL SLEFT      ;Skift AC til venstre
        JR   NC,DIVI1   ;Ingen carry => DIVI1

        EX   AF,AF'     ;Gem taeller
        CALL SUBAC      ;MANT=MANT-MANT'
        OR   A          ;Nulstil carry
        JR   DIVI2

DIVI4:  CALL SLEFT      ;Udregn afrundingsbit
        JR   C,DIVI5
        CALL CMPAC
        CCF

DIVI5:  POP  HL         ;Hent resultat
        POP  DE
        POP  BC
        BIT  7,B        ;Normaliseret?
        JR   NZ,DIVI6   ;Ja => DIVI6

        CALL LEFT       ;Roter afrundingsbit
        JR   MUL5       ;ind i resultatet

DIVI6:  INC  L          ;Laeg 1 til exponent
        JR   NZ,MUL5
        DEC  L
        SCF
        JR   MUL5A


;FLOATING POINT MULTIPLIKATION

FPMUL:  EXX             ;Er AC' nul?
        LD   A,L
        OR   A
        EXX
        JP   Z,ZERO     ;Ja => Resultat 0

        LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Retur

        EXX             ;Adder exponenter
        ADD  A,L
        EXX             ;Juster exponent og
        CALL EXPSGN     ;udregn fortegn

        PUSH BC         ;Gem AC
        PUSH DE
        PUSH HL
        ADD  IX,SP      ;Peg IX til AC

        CALL ZERO       ;Nulstil resultat
        EXX             ;5 bytes
        LD   L,5
        EXX

MUL1:   LD   A,8        ;Bittaeller lig 8
        INC  IX         ;Hent ny byte
        LD   L,(IX+0)

MUL2:   EX   AF,AF'     ;Gem taeller
        RR   L          ;Roter byte til hoejre
        JR   NC,MUL3    ;Hvis carry saa laeg
        CALL ADDAC      ;AC' til resultatet

MUL3:   CALL RIGHT      ;Roter res. til hoejre
        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Byte faerdig?
        JR   NZ,MUL2    ;Nej => MUL2
        EXX             ;5 bytes klaret?
        DEC  L
        EXX
        JR   NZ,MUL1    ;Nej => MUL1

        LD   L,(IX-5)   ;Hent exponent
        BIT  7,B        ;Normaliseret?
        JR   NZ,MUL4    ;Ja => MUL4

        EX   AF,AF'     ;Hent sidste carry
        CALL LEFT       ;Roter res. til venstre
        INC  L          ;Traek 1 fra exponent
        DEC  L
        JR   Z,MUL4
        DEC  L

MUL4:   POP  AF         ;Fjern workspace
        POP  AF
        POP  AF

MUL5:   OR   A          ;Status = OK
MUL5A:  EX   AF,AF'     ;Gem status
        POP  AF         ;Hent res. fortegn
        EXX
        POP  BC         ;Hent AC' fortegn
        POP  HL         ;Hent AC' exponent
        EXX
        POP  IX         ;Hent IX
        RES  7,B        ;Erstat MSB i AC med
        OR   B          ;fortegn
        LD   B,A
        EX   AF,AF'     ;Hent status
        INC  L
        DEC  L
        CALL Z,ZERO
        RET

;Juster exponent og udregn fortegn.

EXPSGN: JR   C,EXPS1    ;Carry => EXPS1
        ADD  A,EXPN     ;Juster exponent
        JR   C,EXPS2    ;Carry => EXPS2
        JR   EXPS3      ;Underflow

EXPS1:  ADD  A,EXPN     ;Juster exponent
        JR   C,EXPS3    ;carry => Overflow

EXPS2:  LD   L,A        ;Gem i exponent
        EX   (SP),IX    ;Gem IX
        EXX
        PUSH HL         ;Gem AC' exponent
        PUSH BC         ;Gem AC' fortegn
        LD   A,B        ;Udregn nyt fortegn
        SET  7,B
        EXX
        XOR  B
        AND  SIGN
        PUSH AF
        SET  7,B
        PUSH IX
        LD   IX,0       ;Nulstil IX
        RET

EXPS3:  POP  HL         ;Juster stakken
        RET  C          ;Carry => Returner

;Nulstil AC.

ZERO:   XOR  A          ;Nulstil carry, expo-
        LD   L,A        ;nent og mantissa
        LD   B,A
        LD   C,A
        LD   D,A
        LD   E,A
        LD   H,A
        RET

;Roter AC til hoejre.

SRIGHT: OR   A
RIGHT:  RR   B
        RR   C
        RR   D
        RR   E
        RR   H
        RET

;Roter AC til venstre.

SLEFT:  OR   A
LEFT:   RL   H
        RL   E
        RL   D
        RL   C
        RL   B
        RET

;Laeg AC' til AC.

ADDAC:  LD   A,H
        EXX
        ADD  A,H
AAC1:   EXX
        LD   H,A
        LD   A,E
        EXX
        ADC  A,E
        EXX
        LD   E,A
        LD   A,D
        EXX
        ADC  A,D
        EXX
        LD   D,A
        LD   A,C
        EXX
        ADC  A,C
        EXX
        LD   C,A
        LD   A,B
        EXX
        ADC  A,B
        EXX
        LD   B,A
        RET

;Traek AC' fra AC.

SUBAC:  LD   A,H
        EXX
        SUB  H
SAC1:   EXX
        LD   H,A
        LD   A,E
        EXX
        SBC  A,E
        EXX
        LD   E,A
        LD   A,D
        EXX
        SBC  A,D
        EXX
        LD   D,A
        LD   A,C
        EXX
        SBC  A,C
        EXX
        LD   C,A
        LD   A,B
        EXX
        SBC  A,B
        EXX
        LD   B,A
        RET

;Sammenlign AC med AC'.

CMPAC:  LD   A,B
        EXX
        CP   B
        EXX
        RET  NZ
        LD   A,C
        EXX
        CP   C
        EXX
        RET  NZ
        LD   A,D
        EXX
        CP   D
        EXX
        RET  NZ
        LD   A,E
        EXX
        CP   E
        EXX
        RET  NZ
        LD   A,H
        EXX
        CP   H
        EXX
        RET


;FLOATING POINT COMPARE.

CMP:    EXX             ;Er fortegn ens?
        LD   A,B
        EXX
        XOR  B
        JP   P,CMP1     ;Ja => CMP1
        LD   A,B        ;Fortegn fra AC til
        RLA             ;carry
        RET

CMP1:   BIT  7,B        ;Negative tal?
        JR   Z,CMP2     ;Nej => CMP2

        CALL CMP2       ;Sammenlign abs.vaerdi
        RET  Z          ;Ens => Returner
        CCF             ;Complementer resultat
        RET

CMP2:   LD   A,L        ;Er exponenter ens?
        EXX
        CP   L
        EXX
        RET  NZ         ;Nej => Returner
        OR   A          ;Er exponenter nul?
        RET  Z          ;Ja => Returner
        JP   CMPAC      ;Sammenlign AC med AC'


;FLOATING POINT INTEGER.

INT:    LD   A,L        ;Er exponent mindre
        SUB  EXPN+1     ;end nul?
        JP   C,ZERO     ;Ja => Resultat nul
        INC  A

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EX   AF,AF'
        CALL ZERO       ;Nulstil AC'
        EX   AF,AF'

INT1:   SCF             ;Saet alle bits der har
        CALL RIGHT      ;en exponent stoerre
        DEC  A          ;end eller lig nul
        JR   NZ,INT1

        EXX             ;Nulstil alle bits i AC
        LD   A,H        ;der har en exponent
        EXX             ;mindre end 0
        AND  H
        EXX
        LD   H,A
        LD   A,E
        EXX
        AND  E
        EXX
        LD   E,A
        LD   A,D
        EXX
        AND  D
        EXX
        LD   D,A
        LD   A,C
        EXX
        AND  C
        EXX
        LD   C,A
        LD   A,B
        EXX
        AND  B
        EXX
        LD   B,A
INT2:   JP   ADD10      ;Hent AC'


;FLOATING POINT FRACTION.

;FRAC(X) udregnes af X-INT(X).

FRAC:   EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX

        CALL EQUAL
        EXX
        CALL INT
        EXX
        CALL FPSUB
        JR   INT2


;MODULUS.

;X MOD Y beregnes af FRAC(X/Y)*Y.

MOD:    CALL FPDIV
        RET  C
        CALL FRAC
        JP   FPMUL


;KVADRATROD.

;Kvadratroden beregnes med Newton-Raphson
;iterationsmetoden. Et gaet udregnes ud fra
;det foregaaende gaet efter formelen:
;I(n+1)=(X/I(n)+I(n))/2.
;Som foerste gaet halveres X's exponent.
;Der fortsaettes indtil ABS(I(n+1)-I(n)) er
;mindre end den halve exponent af X minus 20.

SQR:    LD   A,L        ;Er AC nul?
        OR   A
        RET  Z          ;Ja => Returer

        BIT  7,B        ;Er AC negativ?
        SCF             ;Saet carry
        RET  NZ         ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL      ;AC'=AC
        LD   A,L        ;Foerste iteration:
        ADD  A,EXPN     ;halver exponenten
        SRA  A
        ADD  A,EXPN
        LD   L,A        ;Sammenligningsvaerdi
        SUB  20         ;er den halve exponent
        PUSH AF         ;Gem s.vaerdi
        EXX

SQR1:   PUSH BC         ;Gem tallet
        PUSH DE
        PUSH HL
        CALL FPDIV      ;Divider med og adder
        CALL FPADD      ;forrige gaet
        DEC  L          ;Halver
        PUSH BC         ;Gem dette gaet
        PUSH DE
        PUSH HL
        CALL FPSUB      ;Udregn forskellen mel-
        LD   A,L        ;lem de to gaet
        POP  HL         ;Hent det nye gaet
        POP  DE
        POP  BC
        EXX
        POP  HL         ;Hent tallet
        POP  DE
        POP  BC
        EX   (SP),HL    ;Hent s.vaerdi ind i H
        CP   H
        EX   (SP),HL    ;Fortsaet indtil forsk.
        JR   NC,SQR1    ;er lille nok

        POP  AF         ;Fjern s.vaerdi
        EXX
        OR   A          ;Nulstil carry
SQR2:   JP   ADD10      ;Hent AC'


;TANGENS.

;TAN(X) beregnes af SIN(X)/COS(X)

TAN:    EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL
        CALL COS
        EXX
        CALL SIN
        CALL FPDIV
        JR   SQR2


;COSINUS.

;COS(X) beregnes af SIN(PI/2-X)

COS:    EXX
        PUSH BC
        PUSH DE
        PUSH HL
        CALL ACPI
        DEC  L
        CALL FPSUB
        EXX
        JR   SINC


;SINUS.

;SIN(X) beregnes paa flg. maade:
;Hvis ABS(X)>2*PI saa X=FRAC(X/(2*PI))*2*PI
;Hvis X<0 saa X=X+2*PI
;Hvis X>PI saa X=X-PI, fortegn -
;Hvis X>PI/2 saa X=PI-X
;Y=X/3, Z=Y^2
;SIN(Y)=Y(((((Z+K1)Z+K2)Z+K3)Z+K4)Z+K5)/K5
;K1=-110      K2=7920       K3=-332640
;K4=6652800   K5=-39916800
;SIN(X)=4(.75*SIN(Y)-SIN(Y)^3)

SIN:    EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
SINC:   CALL ACPI       ;AC'=2PI
        INC  L
        EXX

        LD   A,L        ;Hvis tallet er mindre
        CP   EXPN-20    ;end 1E-7 saa returner
        JP   C,SIN7

        PUSH BC         ;Er ABS(AC)>2PI
        RES  7,B
        CALL CMP
        POP  BC
        CALL NC,MOD     ;Ja => AC=AC MOD 2PI

SIN1A:  BIT  7,B        ;Hvis AC<0 saa laeg
        JR   Z,SIN2     ;2PI til AC
        CALL FPADD

SIN2:   EXX             ;AC'=PI
        DEC  L
        EXX
        CALL CMP        ;Er AC>PI?
        PUSH AF         ;Gem flag som fortegn
        JR   C,SIN3     ;Nej => SIN3
        CALL FPSUB      ;AC=AC-PI

SIN3:   EXX             ;AC'=PI/2
        DEC  L
        EXX
        CALL CMP        ;Er AC>PI/2?
        JR   C,SIN4     ;Nej => SIN4
        EXX             ;AC=PI-AC
        INC  L
        CALL FPSUB

SIN4:   LD   A,L        ;Hvis tallet er mindre
        CP   EXPN-20    ;end 1E-7 saa returner
        JR   C,SIN7A

        EXX             ;AC=AC/3
        LD   BC,02AAAH
        LD   DE,0AAAAH
        LD   HL,0AA7FH
        CALL FPMUL

        PUSH IX
        LD   IX,SINK-6
        LD   A,5
        CALL COMSER
        POP  IX

        CALL EQUAL      ;Gem i AC'
        CALL FPMUL      ;Udregn SIN(X)^3
        CALL FPMUL
        PUSH BC         ;Gem paa stakken
        PUSH DE
        PUSH HL
        EXX
        CALL EQUAL      ;Udregn .75*SIN(X)
        DEC  L
        DEC  L
        EXX
        DEC  L
        CALL FPADD
        EXX             ;Hent SIN(X)^3
        POP  HL
        POP  DE
        POP  BC
        EXX
        CALL FPSUB      ;Traek det fra
        INC  L          ;Gang med 4
        INC  L

SIN7A:  POP  AF         ;Indsaet fortegn
        INC  L
        DEC  L
        JR   Z,SIN7
        JR   C,SIN7
        LD   A,B
        XOR  SIGN
        LD   B,A
SIN7:   OR   A
        JP   ADD10      ;Hent AC'

;Konstanter for udregning af SINUS.

SINK:   DW 0DC00H,00000H,00087H  ;K1

        DW 07780H,00000H,0008DH  ;K2

        DW 0A26CH,00000H,00093H  ;K3

        DW 04B07H,00000H,00097H  ;K4

        DW 09845H,04000H,0009AH  ;K5



;TITALS LOGARITME.

;LOG(X) beregnes af LN(X)/LN(10).

LOG:    CALL LN
        RET  C
        EXX
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,05E5BH  ;1/LN(10)
        LD   DE,0D8A9H
        LD   HL,0367FH
        CALL FPMUL
        JP   ADD10


;NATURLIGE LOGARITME.

;LN(X) beregnes paa flg. maade:
;X=Y*2^N, 1<=Y<2
;Z=Y*SQR(2)/2
;U=(Z-1)/(Z+1), V=U^2
;R=U((((((V+K1)V+K2)V+K3)V+K4)V+K5)V+K6)/K6
;Kn=13/(13-2n)
;LN(X)=2*R+LN(2)/2+N*LN(2)

LN:     INC  L          ;Er AC nul?
        DEC  L
        SCF             ;Indiker fejl
        RET  Z          ;Ja => Returner
        BIT  7,B        ;Negativ?
        RET  NZ         ;Ja => Returner

        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,03504H  ;AC'=SQR(2)/2
        LD   DE,0F333H
        LD   HL,0FB80H
        EXX

        LD   A,L        ;Udregn N
        LD   L,EXPN+1   ;Udregn Y
        SUB  L
        PUSH AF         ;Gem N

        CALL FPMUL      ;Udregn Z
        EXX             ;Udregn U
        CALL AC1
        EXX
        CALL FPSUB
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        INC  L
        CALL FPADD
        EXX
        POP  HL
        POP  DE
        POP  BC
        CALL FPDIV

        PUSH IX         ;Udregn LN(Z)
        LD   IX,LNK-6
        LD   A,6
        CALL COMSER
        POP  IX

        INC  L          ;Laeg LN(2)/2 til
        EXX
        CALL ACLN2
        DEC  L
        EXX
        CALL FPADD
        POP  AF
        PUSH BC         ;Gem resultat
        PUSH DE
        PUSH HL
        LD   L,A        ;Udregn N*LN(2)
        LD   H,0
        JR   NC,LN1
        DEC  H
LN1:    CALL FLOAT
        EXX
        INC  L
        CALL FPMUL
        EXX
        POP  HL         ;Hent resultat
        POP  DE
        POP  BC
        CALL FPADD      ;Adder
        LD   A,L
        CP   EXPN-25    ;LN(X)<3E-8 => LN(X)=0
        CALL C,ZERO
        JP   ADD10      ;Hent AC'

;Konstanter for udregning af LN.

LNK:    DW 01745H,0D174H,05D81H  ;K1

        DW 038E3H,08E38H,0E481H  ;K2

        DW 06DB6H,0DB6DH,0B781H  ;K3

        DW 02666H,06666H,06682H  ;K4

        DW 00AAAH,0AAAAH,0AB83H  ;K5

        DW 05000H,00000H,00084H  ;K6



;POTENSOPLOEFTNING.

;X^Y beregnes af EXP(Y*LN(X)).

PWR:    LD   A,L
        OR   A
        RET  Z
        CALL LN
        RET  C
        CALL FPMUL
        RET  C


;EXPONENTIALFUNKTIONEN.

;Hvis X<0 saa udregnes EXP(X)=1/EXP(-X).
;EXP(X) beregnes paa flg. maade:
;EXP(X)=2^Y, Y=X/LN(2)
;2^Y=2^INT(Y)*2^Z, Z=FRAC(Y)
;2^Z udregnes af:
;2^Z=(((((((Z+K1)*Z+K2)*Z)2+K3)....)*Z+K7)/K7
;K1=6.6042604723   K2=62.027114868
;K3=444.01034843   K4=2563.5667136
;K5=11095.090786   K6=32013.685271
;K7=46185.984492

EXP:    EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        CALL ACLN2      ;AC'=LN(2)
        EXX

        OR   A          ;Gem fortegn
        BIT  7,B
        PUSH AF
        RES  7,B        ;Goer positivt

        CALL FPDIV      ;Udregn Y
        LD   A,L        ;Er Y>128?
        CP   EXPN+8
        JP   NC,EXP4    ;Ja => EXP4

        CALL EQUAL      ;AC'=Y
        CALL FRAC       ;Udregn Z=FRAC(Y)
        EXX             ;Udregn INT(Y)
        CALL FIX
        LD   A,L
        PUSH AF         ;Gem INT(Y)
        EXX

EXP1:   PUSH IX         ;Udregn 2^Z
        LD   IX,EXPK-6
        LD   A,7
        CALL CALCS
        POP  IX

EXP3:   POP  AF         ;Hent 2^INT(Y)
        ADD  A,L        ;Udregn 2^Z*2^INT(Y)
        LD   L,A
        JR   NC,EXP6    ;Ikke overflow => EXP6

EXP4:   POP  AF         ;Juster stakken
        SCF             ;Indiker overflow
EXP5:   JP   ADD10      ;Hent AC'

EXP6:   POP  AF         ;Hent fortegn
        JR   Z,EXP5     ;Positivt => EXP5
        EXX             ;Tag den reciprokke
        CALL AC1
        CALL FPDIV
        JR   EXP5

;Konstanter for udregning af EXP.

EXPK:   DW 05356H,01A0EH,0DE83H  ;K1

        DW 0781BH,0C3FFH,0FB86H  ;K2

        DW 05E01H,05318H,0F189H  ;K3

        DW 02039H,01142H,0418CH  ;K4

        DW 02D5CH,05CF6H,0DF8EH  ;K5

        DW 07A1BH,05EDBH,0CD8FH  ;K6

        DW 03469H,0FC07H,0E590H  ;K7


;ARCCUS TANGENS.

;Hvis X>1 udregnes ATN(X)=PI/2-ATN(1/X).
;Til beregning af ATN(X) bruges:
;Y=X^2, A=PI/24,
;ATN(X)=X(((((Y+K1)*Y+K2)*Y+K3)*Y+K4)*Y+K5)/K5,
;hvor 0<=X<A og
;K1=-11/9  K2=11/7  K3=-11/5  K4=11/3  K5=-11
;X bestemmes til at ligge i et af interv.:
;1. X<TAN(A)
;2. TAN(A)<=X<TAN(3*A)    ,K=2*A
;3. TAN(3*A)<=X<TAN(5*A)  ,K=4*A
;4. X>=TAN(5*A)           ,K=6*A
;Hvis X er i foerste interv. bruges formelen
;alene, men ellers bruges:
;Y=(X-TAN(K))/(1+X*TAN(K))
;ATN(X)=K+ATN(Y)

ATN:    LD   A,L
        OR   A
        RET  Z
        EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        PUSH IX
        CALL AC1        ;AC'=1
        EXX
        XOR  A          ;Nulstil flagbyte
        BIT  7,B        ;Er AC positiv?
        JR   Z,ATN1     ;Ja => ATN1

        INC  A          ;Saet negativflag
        RES  7,B        ;AC=ABS(AC)

ATN1:   PUSH AF         ;Gem flag
        CALL CMP        ;Er AC>1
        JR   C,ATN2     ;Ja => ATN2

        EXX             ;AC=1/AC
        CALL FPDIV
        POP  AF         ;Saet reciprokflag
        SET  7,A
        PUSH AF

ATN2:   EXX
        LD   BC,006CFH
        LD   DE,0E98EH
        LD   HL,04A7EH
        EXX
        CALL CMP        ;Er AC<TAN(PI/24)?
        JR   NC,ATN3    ;Nej => ATN3

        CALL ARCTAN     ;Udregn ATN(X)
        JR   ATN6

ATN3:   LD   IX,ATNK-18 ;Peg IX til skalerings-
        LD   A,2        ;konstanter

ATN4:   EX   AF,AF'     ;Gem taeller
        EXX
        LD   DE,18      ;Peg til naeste saet
        ADD  IX,DE
        CALL GETCIX     ;Hent oeverste endepkt.
        EXX
        CALL CMP        ;Er X i dette interval?
        JR   C,ATN5     ;Ja => ATN5
        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Faerdig?
        JR   NZ,ATN4    ;Nej => ATN4

        EXX             ;Juster IX
        LD   DE,12
        ADD  IX,DE
        EXX

ATN5:   EXX
        CALL GTNCIX     ;Hent TAN(K)
        SET  7,B        ;Udregn X-TAN(K)
        CALL FPADD
        PUSH BC         ;Gem resultat
        PUSH DE
        PUSH HL
        CALL GETCIX     ;Hent TAN(K)
        CALL FPMUL      ;Udregn X*TAN(K)
        EXX
        CALL AC1        ;Laeg 1 til
        CALL FPADD
        EXX             ;Gem i AC'
        POP  HL         ;Hent forrige resultat
        POP  DE
        POP  BC
        CALL FPDIV      ;Udregn Y
        PUSH IX         ;Udregn ATN(Y)
        CALL ARCTAN
        POP  IX
        EXX
        CALL GTNCIX     ;Hent K
        CALL FPADD      ;Udregn K+ATN(Y)

ATN6:   POP  AF         ;Hent flagbyte
        RLA             ;Var X>1?
        JR   NC,ATN7    ;Nej => ATN7

        PUSH AF         ;Gem flagbyte
        EXX             ;Udregn PI/2-ATN(X)
        CALL ACPI
        DEC  L
        CALL FPSUB
        POP  AF         ;Hent flagbyte

ATN7:   POP  IX         ;Hent IX
        BIT  1,A        ;Var X<0?
        JR   Z,ATN8     ;Nej => ATN8
        SET  7,B        ;Resultat negativt
ATN8:   OR   A
        JP   ADD10      ;Hent AC'

;Konstanter til skalering af X under beregning
;af ATN.

ATNK:   DW 05413H,0CCCFH,0E77FH  ;TAN(3*A)

        DW 00930H,0A2F4H,0F67FH  ;TAN(2*A)

        DW 0060AH,091C1H,06A7FH  ;2*A

        DW 0446FH,08A9EH,0B580H  ;TAN(5*A)

        DW 013CDH,03A2CH,08280H  ;TAN(4*A)

        DW 0060AH,091C1H,06A80H  ;4*A

        DW 00000H,00000H,00081H  ;TAN(6*A)

        DW 0490FH,0DAA2H,02180H  ;6*A


;Konstanter for beregning af ATN.

ARCTK:  DW 09C71H,0C71CH,07281H  ;K1

        DW 04924H,09249H,02581H  ;K2

        DW 08CCCH,0CCCCH,0CD82H  ;K3

        DW 06AAAH,0AAAAH,0AB82H  ;K4

        DW 0B000H,00000H,00084H  ;K5


;Udregn taylorraekken for ARCCUS TANGENS.

ARCTAN: LD   IX,ARCTK-6
        LD   A,5

;COMSER udregner en potensraekke af formen:
;T=X*((((X^2+K1)*X^2+K2)....)*X^2+Kn)/Kn,
;hvor X er i AC, n er i A, og adressen paa
;konstanterne (minus 6) i IX.

COMSER: PUSH BC         ;Gem X
        PUSH DE
        PUSH HL
        PUSH AF         ;Gem laengde
        CALL EQUAL      ;Udregn Z=X^2
        CALL FPMUL
        POP  AF         ;Hent laengde
        CALL CALCS      ;Udregn raekken
        EXX             ;Hent X
        POP  HL
        POP  DE
        POP  BC
        JP   FPMUL      ;Gang med X

;CALCS udregner en potensraekke af formen:
;U=(((((Z+K1)*Z+K2)*Z+K3)....)*Z+Kn)/Kn,
;hvor Z er i AC, n er i A, og adressen paa
;konstanterne (minus 6) i IX.

CALCS:  EXX             ;Gem Z i AC'
        CALL AC1        ;Start med resultat=1
CALC1:  PUSH AF         ;Gang med Z
        CALL FPMUL
        POP  AF
        PUSH AF
        EXX
        PUSH BC         ;Gem Z
        PUSH DE
        PUSH HL
        CALL GTNCIX     ;Hent naeste konstant
        CALL FPADD      ;Laeg til resultat
        EXX             ;Hent Z
        POP  HL
        POP  DE
        POP  BC
        EXX
        POP  AF         ;Faerdig?
        DEC  A
        JR   NZ,CALC1   ;Nej => CALC1
        EXX
        CALL GETCIX
        EXX
        JP   FPDIV

;Saet AC lig den konstant IX peger paa.

GTNCIX: LD   DE,6
        ADD  IX,DE
GETCIX: LD   C,(IX+0)
        LD   B,(IX+1)
        LD   E,(IX+2)
        LD   D,(IX+3)
        LD   L,(IX+4)
        LD   H,(IX+5)
        RET

;Saet AC lig 2*PI.

ACPI:   LD   BC,0490FH
        LD   DE,0DAA2H
        LD   HL,02182H
        RET

;Saet AC lig LN(2).

ACLN2:  LD   BC,03172H
        LD   DE,017F7H
        LD   HL,0D280H
        RET

;FLOATING POINT EQUAL.

EQUAL:  PUSH BC
        PUSH DE
        PUSH HL
        EXX
        POP  HL
        POP  DE
        POP  BC
        RET

;FLOATING POINT TIL 16-BIT INTEGER MED
;2'S COMPLEMENT FORTEGN.

FIX:    OR   A
        BIT  7,L        ;Exponent<0?
        JR   Z,FIX4     ;Ja => FIX4
        BIT  7,B        ;Gem fortegn
        EX   AF,AF'
        SET  7,B        ;Saet MSB

FIX1:   LD   A,EXPN+15  ;Test exponent
        CP   L
        RET  C          ;EXP>15 => overflow
        JR   Z,FIX2     ;EXP=15 => FIX2
        CALL SRIGHT     ;EXP<15 => roter til
        INC  L          ;hoejre og laeg 1 til
        JR   FIX1       ;exponent

FIX2:   CALL SRIGHT     ;Roter til hoejre
        EX   AF,AF'     ;Negativt fortegn?
        JR   Z,FIX3     ;Nej => INT2
        LD   HL,0       ;Tag 2's complement
        SBC  HL,BC
        OR   A          ;Nulstil carry
        RET

FIX3:   LD   H,B        ;Hent tallet
        LD   L,C
        RET

FIX4:   LD   HL,0       ;Underflow
        RET

;16-BIT INTEGER MED 2'S COMPLEMENT FORTEGN
;TIL FLOATING POINT.

FLOAT:  LD   A,H        ;Er HL=0?
        OR   L
        JP   Z,ZERO     ;Ja => ZERO

        BIT  7,H        ;Er HL negativ?
        JR   Z,FLT1     ;Nej => FLT1

        EX   DE,HL      ;Tag 2's complement
        LD   HL,0
        OR   A
        SBC  HL,DE

FLT1:   EX   AF,AF'     ;Gem fortegn i F'
        LD   B,H        ;Saet mantissa
        LD   C,L
        LD   DE,0
        LD   HL,EXPN+16 ;Saet exponent

FLT2:   BIT  7,B        ;Normaliser
        JR   NZ,FLT3
        CALL SLEFT
        DEC  L
        JR   FLT2

FLT3:   EX   AF,AF'     ;Negativt?
        RET  C          ;Ja => Retur
        RES  7,B        ;Positivt
        RET


;FLYDENDE TAL TIL TEKSTSTRENG.

;Resultatet afleveres i den buffer IX peger
;paa, og er afsluttet med et 0.
;Udskriftens format afgoeres af H' og L'.

;Register L':

;Bit 0    Udskriftstype
;           0 - Fastkomma notation
;           1 - Exponentiel notation
;Bit 2-1  Fortegnsformat
;           00 - Intet fortegn
;           01 - AC>=0: Intet fortegn
;                AC<0:  "-"
;           10 - AC>=0: " "
;                AC<0:  "-"
;           11 - AC>=0: "+"
;                AC<0:  "-"
;Bit 3    Decimaldelsformat
;           0 - Kun betydende cifre
;           1 - Skriv alle cifre
;Bit 4    Heltalsdelformat
;           0 - Kun betydende cifre
;           1 - Blanktegn foer betydende cifre

;Register H':

;Bit 3-0  Decimalfeltets laengde (0-15)
;Bit 7-4  Heltalsfeltets laengde (1-15)
;         Bruges kun hvis bit 0 i L' er 0


FSTRR:  EXX
        LD   A,L        ;Gem format i A og A'
        EX   AF,AF'
        LD   A,H
        EXX
        JR   OUTN1

;FLYDENDE TAL TIL TEKSTSTRENG.

;Formatet efterfoelger kaldet som to bytes, der
;har samme betydning som L' henholdsvis H' ved
;kald af FSTRR.

FSTRS:  EX   (SP),IX
        LD   A,(IX+0)    ;Gem format i A og A'
        INC  IX
        EX   AF,AF'
        LD   A,(IX+0)
        INC  IX
        EX   (SP),IX

OUTN1:  PUSH IX         ;Gem IX,IY,AC,AC'
        PUSH IY
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        PUSH BC
        PUSH DE
        PUSH HL
        EXX
        LD   IY,-13     ;Opret en 13 bytes
        ADD  IY,SP      ;buffer paa stakken
        LD   SP,IY
        EXX
        LD   E,A        ;Gem formatet
        EX   AF,AF'
        LD   D,A
        PUSH DE
        EXX

        INC  L          ;Er AC nul?
        DEC  L
        JR   NZ,DIGITS  ;Nej => DIGITS

        POP  DE         ;Hent formatet
DZERO:  LD   (IY+0),L   ;Marker bufferslut
        JP   OUTM

DIGITS: PUSH BC         ;Gem BC
        RES  7,B        ;Goer AC positiv
        LD   A,L        ;Hent exponent
        EXX

;Udregn titalsexponenten udfra totalsexponenten
;paa foelgende maade:
;E10=INT(E2*LOG(2))=INT((E2*77+5)/256)

        LD   H,0        ;HL=toexponent
        SUB  EXPN
        JR   NC,SC1
        DEC  H
SC1:    LD   L,A
        PUSH HL         ;HL=HL*77+5
        ADD  HL,HL
        ADD  HL,HL
        PUSH HL
        ADD  HL,HL
        LD   D,H
        LD   E,L
        ADD  HL,HL
        ADD  HL,HL
        ADD  HL,HL
        ADD  HL,DE
        POP  DE
        ADD  HL,DE
        POP  DE
        ADD  HL,DE
        LD   DE,5
        ADD  HL,DE
        LD   A,H        ;A=INT(HL/256)
        CP   -39
        JR   NZ,SC2
        INC  A
SC2:    LD   (IY+0),A   ;Gem tiexponent
        NEG             ;Multiplicer AC med
        CALL TENF       ;10^-tiexponent
        LD   A,L        ;Er AC<1?
        CP   EXPN+1
        JR   NC,SC3     ;Nej => SC3
        DEC  (IY+0)     ;Tiexponent-1
        CALL MUL10      ;AC=AC*10

SC3:    SET  7,B
        LD   A,EXPN+4
        SUB  L
        LD   L,0
        JR   Z,DIGI1
SC4:    CALL SRIGHT
        RR   L
        DEC  A
        JR   NZ,SC4

DIGI1:  LD   A,(IY+0)   ;Hent tiexp.
        LD   (IY+0),0   ;Marker bufferstart
        PUSH IY         ;Gem IY
        PUSH AF         ;Gem tiexp.
        LD   A,12       ;Udregn 12 cifre

DIGI2:  EX   AF,AF'     ;Gem taeller
        LD   A,B
        RRA
        RRA
        RRA
        RRA
        AND  0FH
        ADD  A,'0'
        INC  IY
        LD   (IY+0),A
        LD   A,B
        AND  0FH
        LD   B,A

        PUSH BC         ;Gang AC med 10
        PUSH DE
        PUSH HL
        SLA  L
        CALL LEFT
        SLA  L
        CALL LEFT
        EX   DE,HL
        EX   (SP),HL
        ADD  HL,DE
        POP  DE
        EX   (SP),HL
        ADC  HL,DE
        EX   DE,HL
        POP  HL
        EX   (SP),HL
        ADC  HL,BC
        LD   B,H
        LD   C,L
        POP  HL
        SLA  L
        CALL LEFT

        EX   AF,AF'     ;Hent taeller
        DEC  A          ;Faerdig?
        JR   NZ,DIGI2   ;Nej => DIGI2

        POP  AF         ;Hent tiexp.
        POP  IY         ;Hent IY,BC
        POP  BC
        INC  IY         ;Peg til foerste ciffer
        LD   C,A        ;Gem titalsexp. i C

ROUND:  POP  DE         ;Hent format
        LD   A,E        ;Udregn nummeret paa
        AND  FWIDTH     ;det ciffer der skal
        INC  A          ;afrundes fra
        BIT  0,D
        JR   NZ,ROU1
        ADD  A,C
        JP   M,DZERO    ;Neg. => Udskriv 0

ROU1:   CP   12         ;Max. nummer 11
        JR   C,ROU2
        LD   A,11

ROU2:   PUSH IY         ;Udregn adressen paa
        POP  HL         ;det ciffer der skal
        ADD  A,L        ;afrundes
        LD   L,A
        JR   NC,ROU3
        INC  H

ROU3:   LD   A,(HL)     ;Hent ciffer
        LD   (HL),0     ;Marker bufferslut
        CP   '5'        ;Afrunding?
        JR   C,ROU5     ;Nej => ROU5

ROU4:   DEC  HL         ;Tag forrige ciffer
        LD   A,(HL)
        OR   A          ;Bufferstart?
        JR   Z,ROU6     ;Ja => ROU6
        INC  A          ;Laeg 1 til ciffer
        LD   (HL),A
        CP   '9'+1      ;Var ciffer '9'?
        JR   C,OUTM     ;Nej => OUTM
        LD   (HL),0     ;Marker bufferslut
        JR   ROU4

ROU5:   DEC  HL         ;Tag forrige ciffer
        LD   A,(HL)
        SUB  '0'        ;Er det '0'?
        JR   NZ,OUTM    ;Nej => OUTM
        LD   (HL),A     ;Marker bufferslut
        JR   ROU5

ROU6:   INC  HL         ;Tallet var 9999...
        LD   (HL),'1'   ;Lav om til 10000...
        INC  HL
        LD   (HL),0
        INC  C          ;Laeg 1 til tiexp.

OUTM:   LD   A,(IY+0)   ;Er tallet 0?
        OR   A
        JR   NZ,OM1     ;Nej => OM1
        LD   B,A        ;Positivt fortegn
        LD   C,A        ;Tiexp = 0

OM1:    BIT  0,D        ;Exponentielt?
        JR   NZ,OM6     ;Ja => OM6

        LD   A,E        ;Udregn det antal
        AND  IWIDTH     ;blanktegn der skal
        RRCA            ;udskrives inden tallet
        RRCA
        RRCA
        RRCA
        DEC  A
        BIT  2,D
        JR   NZ,OM2
        BIT  1,D
        JR   Z,OM3
        BIT  7,B
        JR   Z,OM3
OM2:    DEC  A
OM3:    BIT  7,C
        JR   NZ,OM4
        SUB  C
OM4:    OR   A          ;Negativt?
        SCF             ;Indiker fejl
        JP   M,POPALL   ;Ja => POPALL

        BIT  4,D        ;Blanktegn?
        JR   Z,OM6      ;Nej => OM6

        LD   H,A        ;Gem blanktegn
        INC  H
OM5:    DEC  H
        JR   Z,OM6
        LD   A,' '
        CALL STOA
        JR   OM5

OM6:    BIT  7,B        ;Gem fortegn
        JR   Z,OM7
        LD   A,'-'
        BIT  2,D
        JR   NZ,OM8
        BIT  1,D
        JR   NZ,OM8
        JR   OM9
OM7:    BIT  2,D
        JR   Z,OM9
        LD   A,' '
        BIT  1,D
        JR   Z,OM8
        LD   A,'+'
OM8:    CALL STOA

OM9:    BIT  0,D        ;Exponentielt?
        JR   Z,OM10     ;Nej => OM10
        LD   H,C        ;Gem tiexp. i H
        LD   C,0        ;tiexp. = 0

OM10:   BIT  7,C        ;Er tiexp.>=0?
        JR   Z,OM11     ;Ja => OM11

        CALL STOZ       ;Gem '0'
        JR   OM12

OM11:   CALL STODIG     ;Gem de cifre der
        DEC  C          ;staar foer kommaet
        JP   P,OM11

OM12:   LD   A,E        ;Skal der cifre efter
        AND  FWIDTH     ;kommaet?
        JR   Z,OM15     ;Nej => OM15
        LD   E,A
        CALL MORED      ;Er der flere cifre?
        JR   Z,OM15     ;Nej => OM15

        LD   A,'.'      ;Gem '.'
        CALL STOA

OM13:   INC  C          ;Gem ubetydende nuller
        JR   Z,OM14
        CALL STOZ
        DEC  E
        JR   NZ,OM13

OM14:   DEC  E          ;Gem betydende cifre
        JP   M,OM15
        CALL STODIG
        CALL MORED
        JR   NZ,OM14

OM15:   BIT  0,D        ;Exponentielt?
        JR   Z,POPA1    ;Nej => POPA1

        LD   A,'E'      ;Gem 'E'
        CALL STOA
        LD   A,'+'      ;Gem fortegn
        BIT  7,H
        JR   Z,OEX1
        LD   A,H
        NEG
        LD   H,A
        LD   A,'-'
OEX1:   CALL STOA
        LD   A,H        ;Udregn 2-cifret exp.
        LD   B,'0'-1
OEX2:   INC  B
        SUB  10
        JR   NC,OEX2
        ADD  A,10+'0'
        LD   (IX+0),B   ;Gem exponent
        INC  IX
        CALL STOA

POPA1:  OR   A          ;Nulstil carry
POPALL: EX   AF,AF'     ;Gem status
        LD   (IX+0),0   ;Marker bufferslut
        LD   HL,13      ;Fjern talbuffer
        ADD  HL,SP
        LD   SP,HL
        POP  HL         ;Hent AC',AC,IY,IX
        POP  DE
        POP  BC
        EXX
        POP  HL
        POP  DE
        POP  BC
        POP  IY
        POP  IX
        EX   AF,AF'     ;Hent status
        RET

;Gem et ciffer i bufferen.

STODIG: LD   A,(IY+0)   ;Hent ciffer
        INC  IY
        OR   A          ;Bufferslut?
        JR   NZ,STOA    ;Nej => STOA
        DEC  IY         ;Juster
STOZ:   LD   A,'0'      ;Gem '0'
STOA:   LD   (IX+0),A
        INC  IX
        RET

;Undersoeg om der er flere cifre.

MORED:  BIT  3,D
        RET  NZ
        LD   A,(IY+0)
        OR   A
        RET

;Multiplicer AC med 10^A.

TENF:   PUSH AF         ;Gem AF
        OR   A          ;Positiv exponent?
        JP   P,TF1      ;Ja => TF1
        NEG             ;A=ABS(A)
TF1:    PUSH AF         ;Gem flag
        SRL  A          ;A=INT(A/4)
        SRL  A
        LD   HL,-6      ;Udregn offset til
        LD   DE,6       ;konstant nummer A
        INC  A
TF2:    ADD  HL,DE
        DEC  A
        JR   NZ,TF2
        EX   DE,HL
        PUSH IX         ;Gem IX
        LD   IX,CON10   ;Hent konstant
        ADD  IX,DE
        CALL GETCIX
        POP  IX         ;Hent IX
        POP  AF         ;Hent exponent
        AND  3          ;Juster faktor
TF3:    JR   Z,TF4
        PUSH AF
        CALL MUL10
        POP  AF
        DEC  A
        JR   TF3
TF4:    POP  AF         ;Hent exponent
        OR   A          ;Positiv?
        JP   P,FPMUL    ;Ja => Multipicer
        EXX             ;Nej => Divider
        JP   FPDIV

;Tier potens konstanter for konvertering.

CON10:  DW 00000H,00000H,00081H ;1E+00

        DW 01C40H,00000H,0008EH ;1E+04

        DW 03EBCH,02000H,0009BH ;1E+08

        DW 0684DH,0A510H,000A8H ;1E+12

        DW 00E1BH,0C9BFH,004B6H ;1E+16

        DW 02D78H,0EBC5H,0ACC3H ;1E+20

        DW 053C2H,01BCEH,0CDD0H ;1E+24

        DW 0013FH,03978H,0F9DEH ;1E+28

        DW 01DC5H,0ADA8H,02BEBH ;1E+32

        DW 04097H,0CE7BH,0C9F8H ;1E+36



;AC=ABS(AC)*10.

MUL10:  LD   A,L
        OR   A
        RET  Z
        SET  7,B
        PUSH BC
        PUSH DE
        LD   A,H
        CALL SRIGHT
        CALL SRIGHT
        ADD  A,H
        LD   H,A
        EX   (SP),HL
        ADC  HL,DE
        EX   DE,HL
        POP  HL
        EX   (SP),HL
        ADC  HL,BC
        LD   B,H
        LD   C,L
        POP  HL
        JR   NC,M10A
        CALL RIGHT
        INC  L
        SCF
        RET  Z
M10A:   LD   A,L
        ADD  A,3
        LD   L,A
        RES  7,B
        RET

;ASCII TIL FLOATING POINT.

CNVN:   EXX             ;Gem AC'
        PUSH BC
        PUSH DE
        PUSH HL
        LD   BC,0       ;Nulstil flag
        EXX
        CALL ZERO       ;Nulstil AC

        LD   A,(IX+0)   ;Hent foerste karakter
        CP   '+'        ;Plus?
        JR   Z,CNV1     ;Ja => CNV1
        DEC  IX
        CP   '-'        ;Minus?
        JR   NZ,CNV1    ;Nej => CNV1
        EXX             ;Saet minusflag
        SET  7,B
        EXX
        INC  IX

CNV1:   INC  IX         ;Hent naeste karakter
        LD   A,(IX+0)

        CP   '.'        ;Decimalpunkt?
        JR   NZ,CNV2    ;Nej => CNV2
        EXX             ;Er det det foerste?
        BIT  6,B
        SCF
        JP   NZ,CNV6    ;Nej => FEJL
        SET  6,B        ;Ja => saet flag
        EXX
        JR   CNV1

CNV2:   CP   'E'        ;Exponentnotation?
        JR   Z,CNV4     ;Ja => CNV4

        CALL DIGTST     ;Er det et ciffer?
        JR   NC,CNV5    ;Nej => CNV5

        EX   AF,AF'     ;Gang resultat med 10
        CALL MUL10
        JR   C,CNV6A
        EX   AF,AF'
        EXX             ;Laeg det nye ciffer
        PUSH BC         ;til
        LD   L,A
        LD   H,0
        CALL FLOAT
        CALL FPADD
        EXX
        POP  BC
        JR   C,CNV6A
        BIT  6,B        ;Er decimalflag sat?
        JR   Z,CNV3     ;Nej => CNV3
        DEC  C          ;Traek 1 fra tiexp.
CNV3:   EXX
        JR   CNV1

CNV4:   CALL MFACT      ;Gang med titalsfaktor
        JR   C,CNV6     ;Overflow => CNV6
        EXX
        INC  IX         ;Hent naeste karakter
        LD   A,(IX+0)
        CP   '+'        ;Plus?
        JR   Z,CNV4A    ;Ja => CNV4A
        CP   '-'        ;Minus?
        JR   NZ,CNV4B   ;Nej => CNV4B
        SET  5,B        ;Saet minusflag
CNV4A:  INC  IX

CNV4B:  CALL GDTST      ;Er der et ciffer?
        CCF             ;Saet carry hvis ikke
CNV6A:  JR   C,CNV6     ;Nej => CNV6
        LD   C,A        ;Gem i C
        INC  IX         ;Er der et mere?
        CALL GDTST
        JR   NC,CNV4C   ;Nej => CNV4C

        INC  IX         ;Gang forrige ciffer
        LD   D,A        ;med 10 og laeg det
        LD   A,C        ;nye til
        ADD  A,A
        ADD  A,A
        ADD  A,C
        ADD  A,A
        ADD  A,D
        LD   C,A

CNV4C:  BIT  5,B        ;Negativt?
        JR   Z,CNV4D    ;Nej => CNV4D
        LD   A,C
        NEG
        LD   C,A
CNV4D:  EXX

CNV5:   CALL MFACT      ;Gang med titalsfaktor
        JR   C,CNV6     ;Overflow => CNV6
        EXX             ;Negativt?
        BIT  7,B
        EXX
        JR   Z,CNV6     ;Nej => CNV6
        SET  7,B        ;Saet minusflag i AC

CNV6:   JP   ADD10      ;Hent AC'

;Gang tallet i AC med 10^C'

MFACT:  EXX
        LD   A,C
        ADD  A,EXPN
        CP   -37+EXPN   ;Tiexp.<-37?
        RET  C          ;Ja => Retur
        CP   38+EXPN    ;Tiexp.>37?
        CCF
        RET  C          ;Ja => Retur

        PUSH BC         ;Gem BC
        LD   A,C        ;Hent tiexponent
        CALL TENF       ;Mul. med 10^tiexp.
        EXX             ;Hent BC
        POP  BC
        EXX
        RET

;Saet carry hvis karakteren i A er et ciffer.

GDTST:  LD   A,(IX+0)
DIGTST: SUB  '0'
        CCF
        RET  NC
        CP   10
        RET

;Saet AC lig 1.

AC1:    LD   BC,00000H
        LD   DE,00000H
        LD   HL,00081H
        RET
;------------END OF MATH48------------

.macro constfp %xx,%yy,%zz
        ld      hl,%xx
        ld      de,%yy
        ld      bc,%zz
.endm

.macro pushfp
        push    bc
        push    de
        push    hl
.endm

.macro popfp
        pop     hl
        pop     de
        pop     bc
.endm

; Load FP at address HL into BCDEHL
__loadfp:
        push    ix
        push    hl
        pop     ix
        ld      l,(ix+0)
        ld      h,(ix+1)
        ld      e,(ix+2)
        ld      d,(ix+3)
        ld      c,(ix+4)
        ld      b,(ix+5)
        pop     ix
        ret

; Store FP into BCDEHL into address HL
__storefp:
        push    ix
        push    hl
        pop     ix
        exx
        ld      (ix+0),l
        ld      (ix+1),h
        ld      (ix+2),e
        ld      (ix+3),d
        ld      (ix+4),c
        ld      (ix+5),b
        pop     ix
        ret

__flteq:
        call    CMP
        jr      z,__flteq1
__flteq0:
        ld      de,0
        ret
__flteq1:
        ld      de,1
        ret

__fltneq:
        call    CMP
        jr      nz,__fltneq1
__fltneq0:
        ld      de,0
        ret
__fltneq1:
        ld      de,1
        ret

__fltlt:
        call    CMP
        jr      c,__fltlt1
__fltlt0:
        ld      de,0
        ret
__fltlt1:
        ld      de,1
        ret

__fltleq:
        call    CMP
        jr      c,__fltleq1
        jr      z,__fltleq1
__fltleq0:
        ld      de,0
        ret
__fltleq1:
        ld      de,1
        ret

__fltpwr2:
        call    EQUAL
        call    FPMUL
        ret

__fltrnd:
        exx
        ld      hl,$0080
        ld      de,$0000
        ld      bc,$0000
        exx
        bit     7,b
        jr      nz,__fltrnd_neg
        call    FPADD
        jp      FIX
__fltrnd_neg:
        call    FPSUB
        jp      FIX
        
__atof:
        push    ix
        ld      de,hl
        ld      ix,de
        inc     ix
        call    CNVN
        pop     ix
        ret

__ftoa:
        push    ix
        ld      ix,__ftoatmp + 1
        call    FSTRR
        jr      nc,__ftoaok
        ld      hl,__ftoaerr
        pop     ix
        ret
__ftoaok:
        ld      ix,__ftoatmp
        ld      b,255
__ftoalp:
        inc     ix
        inc     b
        ld      a,(ix)
        cp      0
        jr      nz, __ftoalp
        ld      a,b
        ld      (__ftoatmp),a
        ld      hl,__ftoatmp
        pop     ix
        ret
__ftoatmp:
        db 31,  "                                "
__ftoaerr:
        db      5,"ERROR"

__putf:
        exx
        ld      hl,$090d
        exx
        call __ftoa
        call __puts
        ret

__putf_exp:
        exx
        push    bc
        ld      a,c
        cp      $09
        jr      nc,__putf_exp_0
        ld      a,1
        jr      __putf_exp_1
__putf_exp_0:             
        sub     $07
        cp      $0a
        jp      c,__putf_exp_1
        
        ld      a,$09
__putf_exp_1:             
        ld      h,a
        ld      l,$0d
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

__putf_fix:
        exx
        push    de
        ld      a,c
;        cp      $10
;        jp      c,__putf_fix_1
;        ld      a,$0f
__putf_fix_1:
        or      $f0
        ld      h,a
        ld      l,$0a
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

; ========================================================================
; Set support
; ========================================================================

;
; Set membership test
;
; Entry: (SP+2) 32 bytes set, (SP+34) 1 byte element
; Exit:  DE=1 if element in set, 0 otherwise
; Uses:  AF, HL, DE
;
__setin_new:
        ld      hl,34
        ld      d,h
        add     hl,sp       ; HL = sp+32
        ld      e,(hl)
        db      $ed,$94 ; pixelad
        db      $ed,$95 ; setae
        db      $ed,$24 ; mirror
        db      $ed,$34,$00,$c0; add hl,-$4000+2
        add     hl,sp       ; HL = sp+32+bit_offset
        ld      e,d         ; DE = 0 when bit is clear
        and     (hl)
        ret     z
        ld      e,1         ; DE = 1 when bit is set
        ret

; Set index to offset
; Entry E index
; Exit DE offset of byte (D always 0), A correct bit set
__setoff:
        ld      e,a
        srl     e
        srl     e
        srl     e
;        inc     e
;        inc     e
        ld      d,a
        ld      a,1
        bit     0,d
        jr      z,__setoff1
        sla     a
__setoff1:
        bit     1,d
        jr      z,__setoff2
        sla     a
        sla     a
__setoff2:
        bit     2,d
        jr      z,__setoff3
        sla     a
        sla     a
        sla     a
        sla     a
__setoff3:
        ld      d,0
        ret

;
; Set membership test
;
; Entry: (SP+2) 32 bytes set, (SP+34) 1 byte element
; Exit:  DE=1 if element in set, 0 otherwise
; Uses:  AF, HL, DE, BC
;
__setmember:
        ld      hl,34
        add     hl,sp
        ld      a,(hl)
        call    __setoff
        ld      hl,2
        add     hl,de
        ld      de,0
        add     hl,sp
        and     (hl)
        ret     z
        ld      de,1
        ret

__setinclude:
        ld      a,e
        call    __setoff
        add     hl,de
        or      (hl)
        ld      (hl),a
        ret

__setexclude:
        ld      a,e
        call    __setoff
        add     hl,de
        xor     255
        and     (hl)
        ld      (hl),a
        ret

;
; Superset of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 2, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setadd:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setadd1:
        ld      a,(de)
        or      (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setadd1
        ret

;
; Difference of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 1, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setsub:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setsub1:
        ld      a,(de)
        xor     255
        and     (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setsub1
        ret

;
; Intersection of two sets
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  Result in set 1, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setmul:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setmul1:
        ld      a,(de)
        and     (hl)
        ld      (hl),a
        inc     hl
        inc     de
        djnz    __setmul1
        ret

;
; Set equality test (i.e. set 1 = set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if equal, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__seteq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__seteq1:
        ld      a,(de)
        cp      (hl)
        jr      nz,__seteq2
        inc     hl
        inc     de
        djnz    __seteq1
        ld      de,1
        ret
__seteq2:
        ld      de,0
        ret

;
; Subset-or-equal test (i.e. set 1 <= set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if set 1 <= set 2, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setleq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ld      b,c
__setleq1:
        ld      a,(de)
        ld      c,a
        or      (hl)
        cp      c
        jr      nz,__setleq2
        inc     hl
        inc     de
        djnz    __setleq1
        ld      de,1
        ret
__setleq2:
        ld      de,0
        ret

;
; Superset-or-equal test (i.e. set 1 >= set 2)
;
; Entry: (SP+2) 32 bytes set 2, (SP+34) 32 byte set 1
; Exit:  DE=1 if set 1 >= set 2, 0 otherwise, SP is unchanged
; Uses:  AF, HL, DE, BC
;
__setgeq:
        ld      hl,2
        add     hl,sp
        ld      de,hl
        ld      bc,32
        add     hl,bc
        ex      de,hl           ; Swap arguments
        ld      b,c
        jr      __setleq1       ; Let __setleq do the actual work

; +  ... a := a or b
; -  ... a := a and not b
; *  ... a := a and b

; =  ... a = b
; >= ... a or b = a 
; <= ... a or b = b

; Include shared with in
; Exclude shared with in
                

;
; Print character to screen
;
; Entry:  A (ASCII code)
; Exit:   -
; Uses:   C,E,IY
;
#if defined(CPM)
__putc:
                ld      e,a
                ld      c,2
                call    5
                ret
#endif

#if defined(NXT)
__putc:
                ld      iy,(__saved_iy)
                rst     16
                ret
#endif

__conout:       equ     __putc

;
; Print string to screen
;
; Entry:  HL (string address)
; Exit:   -
; Uses:   AF,BC
;
__puts:         ld      b,(hl)
                inc     b
                jr      __putschk
__putsloop:     ld      a,(hl)
                push    hl
                push    bc
                call    __putc
                pop     bc
                pop     hl
__putschk:      inc     hl
                djnz    __putsloop
                ret

;
; New line
;
; Entry:  -
; Exit:   -
; Uses:   -
;
__newline:
                ld      a,13
                call    __putc
#if defined(CPM)
                ld      a,10
                call    __putc
#endif
                ret

;
; Print number to screen
;
; Entry:  HL (number)
; Exit:   -
; Uses:   AF,BC,DE
;
__strn:         ex      de,hl
                push    hl
                push    af
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                pop     af
                pop     de
                call    __movestr
                ret

__strn_fmt:
                push    de
                ld      b,a
                push    bc
                call    __strn
                pop     de
                pop     hl
                call    __ralign
                ret

__strc:
                and     a
                ret     z
                ex      de,hl
                ld      (hl),1
                inc     hl
                ld      (hl),e
                ret

__strs:
                ld      hl,2
                add     hl,sp
                call    __movestr
                pop     de
                ld      hl,256
                add     hl,sp
                ld      sp,hl
                push    de
                ret

__strf:
                push    af
                exx
                push    de
                ld      hl,$090d
                exx
                call    __ftoa
                pop     de
                pop     af
                call    __movestr
                ret

__strf2:
        exx
        push    de
        ld      a,c
;        cp      $10
;        jp      c,__putf_fix_1
;        ld      a,$0f
__str_fix_1:
        or      $f0
        ld      h,a
        ld      l,$0a
        exx
        call    __ftoa
        pop     bc
        call    __puts_fmt
        ret

                push    af
                exx
                push    de
                ld      l,$09
                ld      h,c
                set     4,h
                exx
                call    __ftoa
                pop     de
                pop     af
                call    __movestr
                ret

__stre:
                add     hl,bc
                add     hl,bc
                ld      b,(hl)
                inc     hl
                ld      h,(hl)
                ld      l,b
                call    __movestr
                ret

;
; Right-align Pascal string, inserting spaces at the start.
;
; Pre:
;       HL: string address
;       D : maximum string length
;       E : desired string length
; Post:
;       AF / BC / DE / HL changed
;
__ralign:
        ld      a,d
        cp      e               ; Is desired length > maximum length?
        jp      nc,__ralign1
        ld      e,d

__ralign1:
        ld      a,(hl)
        cp      e               ; Do we already have desired length?
        ret     nc

        ld      b,0
        ld      c,a
        ld      a,e
        sub     (hl)
        ld      (hl),e          ; Set new length

        inc     hl
        add     hl,bc           ; Old end of string
        ld      e,a
        ld      d,0
        push    hl
        add     hl,de           ; New end of string
        ex      de,hl
        pop     hl
        inc     bc
        lddr                    ; Move string

        inc     hl
        ld      b,a
        ld      a,32

__ralign2:
        ld      (hl),a          ; Fill with spaces
        inc     hl
        djnz    __ralign2

        ret





;
; Print number to screen
;
; Entry:  HL (number)
; Exit:   -
; Uses:   AF,BC,DE
;
__putn:         ex      hl,de
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                call    __puts
                ret

;
; Print enum to screen
;
; Entry:  HL (value), DE (literal table)
; Exit:   -
; Uses:   AF,BC,DE
;
__pute:
                add     hl,hl
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                jp      __puts

;
; Formatted output. Similar to normal output, but BC contains field width.
;
__putc_fmt:
                ld      a,l
                ld      hl,__buffer+1
                ld      (hl),a
                dec     hl
                ld      (hl),1
                jp      __puts_fmt

__puts_fmt:
                push    hl
                ld      a,c
                sub     (hl)
                jr      z,__puts_fmt_1
                jr      c,__puts_fmt_1
                ld      b,a
__puts_fmt_loop:
                push    bc
                ld      a, ' '
                call    __putc
                pop     bc
                djnz    __puts_fmt_loop
__puts_fmt_1:
                pop     hl
                jp      __puts

__putn_fmt:     push    bc
                ex      hl,de
                ld      hl,__buffer+1
                call    __itoa
                ld      hl,__buffer
                ld      (hl),a
                pop     bc
                jp      __puts_fmt

__pute_fmt:
                add     hl,hl
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                jp      __puts_fmt

;
; Read number from keyboard
;
; Entry:  -
; Exit:   HL
; Uses:   AF,BC,DE
;
; TODO Separate input from string-to-integer functionality
;
#if defined(CPM)
__getline:
                ld      hl,127
                ld      (__linemax),hl
                ld      de,__linemax
                ld      c,10
                call    5
                ld      a,13
                call    __putc
                ld      a,10
                call    __putc
                ld      a,(__linelen)
                ld      d,0
                ld      e,a
                ld      hl,__linebuf
                add     hl,de
                ld      (hl),0
                and     a
                sbc     hl,de
                ld      (__lineptr),hl
                ret

__lineptr:      ds      2

__blanks:       ld      hl,(__lineptr)
__blanks1:      ld      a,(hl)
                cp      '!'
                ret     nc
                cp      0
                ret     z
                inc     hl
                ld      (__lineptr),hl
                jr      __blanks1

WORD:
__word:         ld      hl,(__lineptr)
                ld      de,__buffer + 1
                ld      b,30
                ld      c,0
__word1:        ld      a,(hl)
                ld      (de),a
                inc     de
                cp      '!'
                jr      c, __word2
                inc     hl
                inc     c
                djnz    __word1
__word2:        ld      (__lineptr),hl
                ld      a,c
                ld      (__buffer),a
                ret

__getn:         push    hl
                call    __blanks
                call    __word
                ld      hl,__buffer + 1
                ld      a,6
                call    __atoi
                pop     hl
                ld      (hl),de
                ret

__getr:         push    hl
                push    ix
                call    __blanks
                call    __word
                ld      ix,__buffer + 1
                call    CNVN
                pop     ix
                exx
                pop     hl
                call    __storefp
                ret

; hl address, de table, b=count
__gete:         push    hl
                push    de
                push    bc
                call    __blanks
                call    __word
                ld      hl,__buffer
                pop     bc
                pop     de
                call    __atoe
                pop     hl
                ld      a,d
                and     a
                ret     nz
                ld      (hl),e
                ret

__getc:         push    hl
                ld      hl,(__lineptr)
                ld      a,(hl)
                pop     de
                ld      (de),a
                cp      ' '
                ret     c
                inc     hl
                ld      (__lineptr),hl
                ret

__gets:         push    hl
                ld      hl,(__lineptr)
                ld      de,__linebuf
                and     a
                sbc     hl,de
                ex      de,hl
                ld      hl,(__linelen)
                ld      h,0
                and     a
                sbc     hl,de
                ex      de,hl
                ld      hl,(__lineptr)
                dec     hl
                ld      (hl),e
                pop     de
                call    __movestr
                ld      hl,(__lineptr)
                ld      e,a
                ld      d,0
                add     hl,de
                ld      (__lineptr),hl
                ret
#endif

#if defined(NXT)
__getn:
                push    ix
                ld      iy, (__saved_iy)
                ;    ld      a,1
                ;   rst $18
                ;   defw    $1601
                ld a,'>'
                call __putc
                ld      de,(23633)      ; save current channel
                push    de       
                ld      de,(__win_handle)        ; set current channel to magic window
                ld      (23633), de 
                ld      de,$01c3
                ld      c,7
                exx
                ld      hl,__buffer
                ld      e,0
                ld      a,10
                exx
                rst     8
                db      $94
                pop     bc
                ld      (23633), bc 
                pop ix
                push    de
                pop de
                ld      a,e
                ld      hl,__buffer
                call    __atoi
                ret
#endif

;
; Print assertion failed message
;
; Entry:  HL Source file
;         DE Source line
;         BC Value
; Exit:   -
; Uses:   ?
;
__assert:
                ld      a,c
                and     a
                jr      z,__assert1
                ld      hl,(__assertpassed);
                inc     hl
                ld      (__assertpassed), hl
                ret
__assert1:      push    de
                push    hl
                ld      hl, __assert_msg_1
                call    __puts
                pop     hl
                call    __puts
                ld      hl, __assert_msg_2
                call    __puts
                pop     hl
                call    __putn
                call    __newline
                ld      hl,(__assertfailed)
                inc     hl
                ld      (__assertfailed), hl
                ret
__assert_msg_1: db 24,"*** Assertion failed in "
__assert_msg_2: db 7,", line "

__assertpassed: dw 0
__assertfailed: dw 0

;
; Signed 16 bits integer to string
;
; Entry:  HL (buffer), DE (value)
; Exit:   A (length)
; Uses:   *
;
__itoa:         ld      bc,0
                bit     7,d                
                ex      de,hl
                jr      z,__itoa_loop1
                ex      de,hl
                ld      (hl),'-'
                inc     hl
                inc     c
                push    hl
                ld      hl,0
                and     a
                sbc     hl,de
                pop     de
__itoa_loop1:   push    bc              ; mod 10 and push
                call    __div10
                pop     bc
                add     a,'0'
                push    af
                inc     b
                ld      a,h
                or      l
                jr      nz,__itoa_loop1
                ex      de,hl
__itoa_loop2:   pop     af              ; pop and store
                ld      (hl),a
                inc     hl
                inc     c
                djnz    __itoa_loop2
                ld      a,c
                ret

;
; String to signed 16 bits integer
;
; Entry:    HL (buffer), A (length)
; Exit:     DE (value)
; Uses:     *
;
; TODO Report errors via carry or a register? 
;
__atoi:         ld      de,0
                and     a
                ret     z
                ld      b,a
                ld      a,(hl)
                ld      c,a
                cp      '-'
                jr      z,__atoi_skip   ; Skip minus sign
                cp      '+'
                jr      z,__atoi_skip   ; Skip plus sign
__atoi_loop:    sub     '0'
                jr      c,__atoi_done   ; Not a digit
                cp      10
                jr      nc,__atoi_done  ; Not a digit
                push    hl
                call    __mul10
                ld      l,a
                ld      h,0
                add     hl,de
                ex      hl,de
                pop     hl
__atoi_skip:    inc     hl
                ld      a,(hl)
                djnz    __atoi_loop
__atoi_done:    ld      a,c             ; Fix sign, if necessary
                cp      '-'
                ret     nz
                and     a
                push    hl
                ld      hl,0
                sbc     hl,de
                ex      de,hl
                pop     hl
                ret

; hl string, de table, b size, out d=0 if found, e contains code, otherwise d=1
__atoe:         ld      c,0
                ex      de,hl
__atoe1:        push    hl
                push    de
                push    bc
                ld      a,(hl)
                inc     hl
                ld      h,(hl)
                ld      l,a
                call    __streqnosp
                ld      a,e
                pop     bc
                pop     de
                pop     hl
                and     a
                jr      nz,__atoe2
                inc     hl
                inc     hl
                inc     c
                djnz    __atoe1
                ld      de,257
                ret
__atoe2:        ld      d,0
                ld      e,c
                ret

#if defined(CPM)
__textfg:     ld a,l
              add a,'0'
              ld  (__textfg_str+3),a
              ld hl,__textfg_str
              call  __puts
              ret
__textfg_str: db 3,27,'T',32
#endif

#if defined(NXT)
__textfg:     ld a,l
              ld  (__textfg_str+2),a
              ld hl,__textfg_str
              call  __puts
              ret
__textfg_str: db 2,16,0 ; No good in LAYER 2,1 - needs mapping
#endif

#if defined(CPM)
__textbg:     ld a,l
              add a,'0'
              ld  (__textbg_str+3),a
              ld hl,__textbg_str
              call  __puts
              ret
__textbg_str: db 3,27,'S',32
#endif

#if defined(NXT)
__textbg:     ld a,l
              ld  (__textbg_str+2),a
              ld hl,__textbg_str
              call  __puts
              ret
__textbg_str: db 2,17,0 ; No good in LAYER 2,1 - needs mapping
#endif

#if defined(CPM)
__gotoxy:     ld a,l
              add a,31
              ld  (__gotoxy_str+4),a
              ld a,e
              add a,31
              ld  (__gotoxy_str+3),a
              ld hl,__gotoxy_str
              call  __puts
              ret
__gotoxy_str: db 4,27,'Y',32,32
#endif

#if defined(NXT)
__gotoxy:     ld a,l
              dec   a
              ld  (__gotoxy_str+3),a
              ld a,e
              dec   a
              ld  (__gotoxy_str+2),a
              ld hl,__gotoxy_str
              call  __puts
              ret
__gotoxy_str: db 3,22,0,0
#endif

#if defined(CPM)
__clrscr:     ld hl,__clrscr_str
              call  __puts
              ret
__clrscr_str: db 4,27,'H',27,'J'
#endif

#if defined(NXT)
__clrscr:     ld hl,__clrscr_str
              call  __puts
              ret
__clrscr_str: db 1,14
#endif

#if defined(CPM)
__cursor_on:  ld hl,__cur_on_str
              call  __puts
              ret
__cur_on_str: db 2,27,'e'
#endif

#if defined(NXT)
__cursor_on:  ret
#endif

#if defined(CPM)
__cursor_off: ld hl,__cur_off_str
              call  __puts
              ret
__cur_off_str: db 2,27,'f'
#endif

#if defined(NXT)
__cursor_off: ret
#endif

#if defined(CPM)
__checkbreak:
                push    ix
                ld      c,11
                call    5
                pop     ix
                and     a
                ret     z
                push    ix
                ld      c,1
                call    5
                pop     ix
                cp      3
                ret     nz
                rst     0
#endif

;
; Fill Char
;
; In: HL address, DE count, C value.
;
__fillchar:
                ld      a,d             ; Check for zero length
                or      e
                ret     z               ; Return if this is the case
                
                ld      (hl),c          ; Set first byte

                dec     de              ; Decrement counter

                ld      a,d             ; Check for zero length
                or      e
                ret     z               ; Return if this is the case

                ld      bc,de           ; Let LDIR do the remaining work 
                ld      de,hl
                inc     de
                ldir

                ret

;
; Move
;
; In: HL source, DE destination, BC value.
;
__move:
                ld      a,b             ; Check for zero length
                or      c
                ret     z               ; Return if this is the case

                push    hl              ; Check if destination > source
                and     a
                sbc     hl,de
                pop     hl
                jr      c,__movedn      ; Move "downwards" if this is the case
__moveup:
                ldir
                ret
__movedn:
                add     hl,bc           ; Set HL to end of buffer
                dec     hl
                ex      de,hl           ; Set DE to end of buffer
                add     hl,bc
                dec     hl
                ex      de,hl
                lddr
                ret

;
; Poke
;
; Entry:  HL (addr), E (value)
; Exit:   -
; Uses:   -
;
__poke:         ld      (hl),e
                ret


#if defined(LORES)
;
;
;
;
;
;
__pixel_addr:   sla     l
                rr      e
                rr      l
                ld      h,e
                ld      a,h
                cp      $18
                jr      c,__pixel_addr1
                ld      de,$6000
                jr      __pixel_addr2
__pixel_addr1:  ld      de,$4000
__pixel_addr2:  add     hl,de
                ret
;
; Set a pixel in low-res mode
;
; Entry:    HL  x       (0..128)
;           DE  y       (0..95)
;           BC  color   (0..255)
;
__set_pixel:    call    __pixel_addr
                ld      (hl),c
                ret

;
; Get a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;
__get_pixel:    call    __pixel_addr
                ld      l,(hl)
                ld      h,0
                ret


#endif

#if defined(HIRES)
__back_buffer:  db      18


__set_frontbuf: ld      a,l
                srl     a
                db      $ed,$92,$12
                ret

__set_backbuf:  ld      a,l
                ld      (__back_buffer),a
                srl     a
                db      $ed,$92,$13

                ret

__wait_vsync:   halt
                ret
;
; Set a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;           BC  color   (0..255)
;
__set_pixel:    di
                ld      d,e
                srl     d
                srl     d
                srl     d
                srl     d
                srl     d
                ld      a,(__back_buffer)
                add     a,d

                db      $ed,$92,$56

                ld      a,e
                and     31
                ld      h,a

                ld      de,$c000
                add     hl,de
                ld      (hl),c

                db      $ed,$91,$56,$00

                ei
                ret

;
; Get a pixel in LAYER 2,1
;
; Entry:    HL  x       (0..255)
;           DE  y       (0..191)
;
__get_pixel:    di
                ld      d,e
                srl     d
                srl     d
                srl     d
                srl     d
                srl     d
                ld      a,(__back_buffer)
                add     a,d

                db      $ed,$92,$56

                ld      a,e
                and     31
                ld      h,a

                ld      de,$c000
                add     hl,de
                ld      a,(hl)
                ld      h,0
                ld      l,a

                db      $ed,$91,$56,$00

                ei
                ret


#endif

;__peek:
;__poke:

;__border:
;__setpixel:
;__getpixel:

__heapptr:
        dw      0

; In: HL pointer address, DE size
; Out: -
__getmem:
        push    ix
        push    hl
        call    __malloc
        pop     hl
        ld      a,ixl
        ld      (hl),a
        inc     hl
        ld      a,ixh
        ld      (hl),a
        pop     ix
        ret

; In: DE size
; Out: IX new block
__malloc:
;        db      $dd,01,00,00
        ld      bc,__heapptr
        ld      ix,(__heapptr)
__malloc_loop:
; Null pointer means heap exhausted
        ld      a,ixh
        or      ixl
        jr      z,__malloc_out_of_memory
; Check size of free block
        ld      l,(ix+2)
        ld      h,(ix+3)
        and     a
        sbc     hl,de
        jr      c,__malloc_next
        jr      nz,__malloc_check_larger
; Case 1: Block of exact size found, just remove if from list
        ld      a,(ix+0)
        ld      (bc),a
        inc     bc
        ld      a,(ix+1)
        ld      (bc),a
        ret
; Larger blocks can be split, if at least 4 bytes remain 
__malloc_check_larger:
        ld      a,252
        and     l
        or      h
        jr      z,__malloc_next
; Case 2: Suitable larger block found, split it and adjust pointers
        exx
        ld      c,(ix+0)
        ld      b,(ix+1)
        exx

        push    ix
        add     ix,de
        exx
        ld      (ix+0),c
        ld      (ix+1),b
        exx
        ld      (ix+2),l
        ld      (ix+3),h

        ld      a,ixl
        ld      (bc),a
        inc     bc
        ld      a,ixh
        ld      (bc),a

        pop     ix

        ret
; Try next block
__malloc_next:
        ld      bc,ix
        exx
        ld      e,(ix+0)
        ld      d,(ix+1)
        ld      ix,de
        exx
        jp      __malloc_loop
; Display error message and freeze
__malloc_out_of_memory:
        ld      hl,__malloc_error_message
        call    __puts
__malloc_infinite_loop:
        jp      __malloc_infinite_loop
__malloc_error_message:
        db      13,'Out of memory'

; In: HL pointer, DE size
__freemem:
;        db      $dd,01,00,00
        ld      bc,(__heapptr)
        ld      (hl),c
        inc     hl
        ld      (hl),b
        inc     hl
        ld      (hl),e
        inc     hl
        ld      (hl),d
        dec     hl
        dec     hl
        dec     hl
        ld      (__heapptr),hl
        ret

__get_heap_start:
                ld      hl, eof
                ret

__get_heap_bytes:
                ld      hl, 57344
                ld      de, eof
                and     a
                sbc     hl,de
                ret

;
; Startup (with some help from Melissa O'Neill for NXT case)
;
; Entry: -
; Exit: -
; Uses: *
;
#if defined(CPM)
__init:         pop     hl
                ld      sp, ($0006)
                jp      (hl)
#endif

#if defined(NXT)
__init:         ld      (__saved_iy),iy
                ld      de, $01d5
                ld      a,1
                exx
#if defined(LORES)
                ld      bc,$0100
#endif
#if defined(HIRES)
                ld      bc,$0201
#endif
                exx
                ld      c,7
                rst     $08
                db      $94
                exx
                ld   (__win_handle),hl
                exx
                ret
#endif

;
; Shutdown
;
; Entry: -
; Exit: -
; Uses: *
;
#if defined(CPM)
__done:         rst     0
#endif

#if defined(NXT)
__done:         ld      iy,(__saved_iy)
                ret
#endif
                jp      main
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] (* -------------------------------------------------------------------------- *)
; [3] (* --- String support ------------------------------------------------------- *)
; [4] (* -------------------------------------------------------------------------- *)
; [5] 
; [6] (* Built-in: procedure Val(S: String; var Scalar; var E: Integer); *)
; [7] (* Built-in: procedure Str(N: Scalar; var S: String);              *)
; [8] 
; [9] procedure Delete(var S: String; Start, Count: Integer);     external '__delete';
; [10] procedure Insert(S: String; var T: String; Start: Integer); external '__insert';
; [11] 
; [12] (* Built-in: function Concat(S: String, ...): String;              *)
; [13] 
; [14] function Copy(S: String; Start, Count: Integer): String;    external '__copy';
; [15] function Length(S: String): Integer;                        external '__length';
; [16] function Pos(S, T: String): Integer;                        external '__pos';
; [17] 
; [18] (* -------------------------------------------------------------------------- *)
; [19] (* --- Set support ---------------------------------------------------------- *)
; [20] (* -------------------------------------------------------------------------- *)
; [21] 
; [22] (* Built-in: procedure Include(var S: Set; E: Element);     *)
; [23] (* Built-in: procedure Exclude(var S: Set; E: Element);     *)
; [24] 
; [25] (* -------------------------------------------------------------------------- *)
; [26] (* --- File support --------------------------------------------------------- *)
; [27] (* -------------------------------------------------------------------------- *)
; [28] 
; [29] (* TBD *)
; [30] 
; [31] (* -------------------------------------------------------------------------- *)
; [32] (* --- Heap management ------------------------------------------------------ *)
; [33] (* -------------------------------------------------------------------------- *)
; [34] 
; [35] type
; [36]   PBlock = ^TBlock;
; [37]   TBlock = record
; [38]     Next: PBlock;
; [39]     Size: Integer;
; [40]   end;
; [41] 
; [42] var
; [43]   HeapPtr: PBlock absolute '__heapptr';
; [44] 
; [45] (* Built-in: procedure New(var P: Pointer);       *)
; [46] (* Built-in: procedure Dispose(P: Pointer);       *)
; [47] 
; [48] procedure FreeMem(P: Pointer; Size: Integer);     register; external '__freemem';
; [49] procedure GetMem(var P: Pointer; Size: Integer);  register; external '__getmem';
; [50] 
; [51] function MemAvail: Integer;
; [52] var
; [53]   P: PBlock;
; [54]   I: Integer;
; [55] begin
; var MemAvail(+6), P(-2), I(-4)
func7:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [56]   P := HeapPtr;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      hl,(__heapptr)  ; Get global HeapPtr
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [57]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [58]   while P <> nil do
while9:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [59]   begin
                bit     0,l
                jp      z,false10
; [60]     I := I + P^.Size;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [61]     P := P^.Next;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [62]   end;
                jp      while9
false10:
; [63] 
; [64]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [65] end;
exit8:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [66] 
; [67] function MaxAvail: Integer;
; [68] var
; [69]   P: PBlock;
; [70]   I: Integer;
; [71] begin
; var MaxAvail(+6), P(-2), I(-4)
func11:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [72]   P := HeapPtr;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      hl,(__heapptr)  ; Get global HeapPtr
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [73]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [74]   while P <> nil do
while13:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [75]   begin
                bit     0,l
                jp      z,false14
; [76]     if P^.Size > I then I := P^.Size;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,false15
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false15:
; [77]     P := P^.Next;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [78]   end;
                jp      while13
false14:
; [79] 
; [80]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [81] end;
exit12:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [82] 
; [83] procedure InitHeap(Bytes: Integer);
; [84] var
; [85]   P: Pointer;
; [86] begin
; var Bytes(+6), P(-2)
proc16:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [87]   HeapPtr := nil;
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [88]   P := Ptr(32768); (* GetHeapStart; *)
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,32768
                ld      (hl),e \ inc hl \ ld (hl),d
; [89]   FreeMem(P, Bytes);
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __freemem
; [90] end;
exit17:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [91] 
; [92] (* -------------------------------------------------------------------------- *)
; [93] (* --- Standard procedures -------------------------------------------------- *)
; [94] (* -------------------------------------------------------------------------- *)
; [95] 
; [96] (* Built-in: procedure Break;                   *)
; [97] (* Built-in: procedure Continue;                *)
; [98] (* Built-in: procedure Exit;                    *)
; [99] 
; [100] procedure ClrScr; register;                 external '__clrscr';
; [101] procedure GotoXY(X, Y: Integer); register;  external '__gotoxy';
; [102] procedure CursorOn; register;               external '__cursor_on';
; [103] procedure CursorOff; register;              external '__cursor_off';
; [104] 
; [105] procedure ConOut(C: Char); register;        external '__conout';
; [106] 
; [107] procedure ClrEol; register; inline
proc23:
; [108] (
; [109]   $2e /                       (* ld   l,27      *)
                db      46
; [110]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [111]   $3e / 'K' /                 (* ld   l,'K'     *)
                db      62,75
; [112]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [113]   $c9                         (* ret            *)
; [114] );
                db      201
                ret
; [115] 
; [116] procedure ClrEos; register; inline
proc24:
; [117] (
; [118]   $2e /                       (* ld   l,27      *)
                db      46
; [119]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [120]   $3e / 'J' /                 (* ld   l,'J'     *)
                db      62,74
; [121]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [122]   $c9                         (* ret            *)
; [123] );
                db      201
                ret
; [124] 
; [125] procedure InsLine; register; inline
proc25:
; [126] (
; [127]   $2e /                       (* ld   l,27      *)
                db      46
; [128]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [129]   $3e / 'L' /                 (* ld   l,'L'     *)
                db      62,76
; [130]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [131]   $c9                         (* ret            *)
; [132] );
                db      201
                ret
; [133] 
; [134] procedure DelLine; register; inline
proc26:
; [135] (
; [136]   $2e /                       (* ld   l,27      *)
                db      46
; [137]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [138]   $3e / 'M' /                 (* ld   l,'M'     *)
                db      62,77
; [139]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [140]   $c9                         (* ret            *)
; [141] );
                db      201
                ret
; [142] 
; [143] procedure TextColor(I: Integer); register;      external '__textfg';
; [144] procedure TextBackground(I: Integer); register; external '__textbg';
; [145] 
; [146] (* -------------------------------------------------------------------------- *)
; [147] (* --- Arithmetic functions ------------------------------------------------- *)
; [148] (* -------------------------------------------------------------------------- *)
; [149] 
; [150] {$A math48.z80}
; [151] 
; [152] const
; [153]   MaxInt = 32767;
; [154]   MinInt = -32768;
; [155] 
; [156] (* Built-in: function Abs(I: Integer): Integer  *)
; [157] (* Built-in: function Abs(R: Real): Real        *)
; [158] 
; [159] function ArcTan(R: Real): Real; register; external 'ATN';
; [160] function Cos(R: Real): Real; register;    external 'COS';
; [161] function Exp(R: Real): Real; register;    external 'EXP';
; [162] function Frac(R: Real): Real; register;   external 'FRAC';
; [163] function Int(R: Real): Real; register;    external 'INT';
; [164] function Ln(R: Real): Real; register;     external 'LN';
; [165] function Log(R: Real): Real; register;    external 'LOG';
; [166] function Sin(R: Real): Real; register;    external 'SIN';
; [167] function Sqr(R: Real): Real; register;    external '__fltpwr2';
; [168] function Sqrt(R: Real): Real; register;   external 'SQR';
; [169] function Tan(R: Real): Real; register;    external 'TAN';
; [170] 
; [171] function Pi: Real; register;              external 'ACPI';
; [172] 
; [173] function MaxReal: Real; register; inline
func41:
; [174] (
; [175]   $01 / $7FFF /
                db      1
                dw      32767
; [176]   $11 / $FFFF /
                db      17
                dw      65535
; [177]   $21 / $FFFF /
                db      33
                dw      65535
; [178]   $c9
; [179] );
                db      201
                ret
; [180] 
; [181] function MinReal: Real; register; inline
func42:
; [182] (
; [183]   $01 / $FFFF /
                db      1
                dw      65535
; [184]   $11 / $FFFF /
                db      17
                dw      65535
; [185]   $21 / $FFFF /
                db      33
                dw      65535
; [186]   $c9
; [187] );
                db      201
                ret
; [188] 
; [189] (* -------------------------------------------------------------------------- *)
; [190] (* --- Scalar functions ----------------------------------------------------- *)
; [191] (* -------------------------------------------------------------------------- *)
; [192] 
; [193] (* Built-in: function Pred(Ordinal): Ordinal;     *)
; [194] (* Built-in: function Succ(Ordinal): Ordinal;     *)
; [195] (* Built-in: function Odd(Ordinal): Boolean;      *)
; [196] (* Built-in: function Even(Ordinal): Boolean;     *)
; [197] 
; [198] (* -------------------------------------------------------------------------- *)
; [199] (* --- Transfer functions --------------------------------------------------- *)
; [200] (* -------------------------------------------------------------------------- *)
; [201] 
; [202] (* Built-in: function Ord(Ordinal): Integer;      *)
; [203] 
; [204] function Round(R: Real): Integer; register; external '__fltrnd';
; [205] function Trunc(R: Real): Integer; register; external 'FIX';
; [206] 
; [207] function Chr(B: Byte): Char; register; inline
func45:
; [208] (
; [209]   $c9         (* ret          *)
; [210] );
                db      201
                ret
; [211] 
; [212] (* -------------------------------------------------------------------------- *)
; [213] (* --- Miscellaneous standard functions ------------------------------------- *)
; [214] (* -------------------------------------------------------------------------- *)
; [215] 
; [216] (* Built-in: function KeyPressed: Boolean;        *)
; [217] (* Built-in: function SizeOf(XYZ): Integer;       *)
; [218] (* Built-in: function Addr(XYZ): Integer;         *)
; [219] (* Built-in: function Ptr(I: Integer): Pointer;   *)
; [220] 
; [221] function Hi(I: Integer): Byte; register; inline
func46:
; [222] (
; [223]   $6c /       (* ld   l,h     *)
                db      108
; [224]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [225]   $c9         (* ret          *)
; [226] );
                db      201
                ret
; [227] 
; [228] function Lo(I: Integer): Byte; register; inline
func47:
; [229] (
; [230]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [231]   $c9         (* ret          *)
; [232] );
                db      201
                ret
; [233] 
; [234] function Swap(I: Integer): Integer; register; inline
func48:
; [235] (
; [236]   $7c /       (* ld   a,h     *)
                db      124
; [237]   $65 /       (* ld   h,l     *)
                db      101
; [238]   $6f /       (* ld   l,a     *)
                db      111
; [239]   $c9         (* ret          *)
; [240] );
                db      201
                ret
; [241] 
; [242] function UpCase(C: Char): Char; register; inline
func49:
; [243] (
; [244]   $7d /       (* ld   a,l     *)
                db      125
; [245]   $fe / $61 / (* cp   'a'     *)
                db      254,97
; [246]   $d8 /       (* ret  c       *)
                db      216
; [247]   $fe / $7b / (* cp   'z' + 1 *)
                db      254,123
; [248]   $d0 /       (* ret  nc      *)
                db      208
; [249]   $cb / $ad / (* res  4,l     *)
                db      203,173
; [250]   $c9         (* ret          *)
; [251] );
                db      201
                ret
; [252] 
; [253] function LoCase(C: Char): Char; register; inline
func50:
; [254] (
; [255]   $7d /       (* ld   a,l     *)
                db      125
; [256]   $fe / $41 / (* cp   'A'     *)
                db      254,65
; [257]   $d8 /       (* ret  c       *)
                db      216
; [258]   $fe / $5b / (* cp   'Z' + 1 *)
                db      254,91
; [259]   $d0 /       (* ret  nc      *)
                db      208
; [260]   $cb / $ed / (* set  4,l     *)
                db      203,237
; [261]   $c9         (* ret          *)
; [262] );
                db      201
                ret
; [263] 
; [264] var
; [265]   CmdLine: String absolute $80;
; [266] 
; [267] function ParamCount: Byte;
; [268] var
; [269]   C, D: Boolean;
; [270]   I, J: Byte;
; [271] begin
; var ParamCount(+6), C(-2), D(-4), I(-6), J(-8)
func51:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [272]   C := True;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,1
                ld      (hl),e
; [273]   J := 0;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,0
                ld      (hl),e
; [274] 
; [275]   for I := 1 to Length(CmdLine) do
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak54
forloop53:
; [276]   begin
; [277]     D := CmdLine[I] > ' ';
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,128          ; Get global CmdLine
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [278]     if not C and D then Inc(J);
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false56
                ld      de,ix
                ld      hl,-8
                add     hl,de
                inc     (hl)
false56:
; [279]     C := D;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [280]   end;
fornext55:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak54
                ld      de,ix
                ld      hl,-6
                add     hl,de
                inc     (hl)
                jp      forloop53
forbreak54:     pop     de              ; Cleanup limit
; [281] 
; [282]   ParamCount := J;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [283] end;
exit52:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [284] 
; [285] function ParamStr(I: Byte): String;
; [286] var
; [287]   C, D: Boolean;
; [288]   J, K: Byte;
; [289] begin
; var ParamStr(+8), I(+6), C(-2), D(-4), J(-6), K(-8)
func57:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [290]   C := True;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,1
                ld      (hl),e
; [291]   K := 1;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,1
                ld      (hl),e
; [292] 
; [293]   for J := 1 to Length(CmdLine) do
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak60
forloop59:
; [294]   begin
; [295]     D := CmdLine[J] > ' ';
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,128          ; Get global CmdLine
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [296] 
; [297]     if not C and D then
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [298]       K := J
                bit     0,l
                jp      z,false62
                ld      de,ix
                ld      hl,-8
                add     hl,de
; [299]     else if C and not D then
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
                jp      endif63
false62:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [300]     begin
                bit     0,l
                jp      z,false64
; [301]       if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [302]       begin
                bit     0,l
                jp      z,false65
; [303]         Dec(J);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                dec     (hl)
; [304]         Break;
                jp      forbreak60      ; Break
; [305]       end;
false65:
; [306] 
; [307]       Dec(I);
                ld      de,ix
                ld      hl,6
                add     hl,de
                dec     (hl)
; [308]     end;
false64:
endif63:
; [309] 
; [310]     C := D;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [311]   end;
fornext61:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak60
                ld      de,ix
                ld      hl,-6
                add     hl,de
                inc     (hl)
                jp      forloop59
forbreak60:     pop     de              ; Cleanup limit
; [312] 
; [313]   if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [314]     ParamStr := Copy(CmdLine, K, J - K + 1)
                bit     0,l
                jp      z,false66
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                call    __mkstr
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                inc     hl
; [315]   else
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
                jp      endif67
false66:
; [316]     ParamStr := '';
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
endif67:
; [317] end;
exit58:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [318] 
; [319] var
; [320]   RandSeed1: Integer absolute 'seed1';
; [321]   RandSeed2: Integer absolute 'seed2';
; [322] 
; [323] function Random(Range: Integer): Integer; register; external '__random';
; [324] function RandomReal: Real; register;                external '__random48';
; [325] 
; [326] procedure CheckBreak; register; external '__checkbreak';
; [327] 
; [328] (* Built-in: procedure FillChar(var Dest; Length: Integer; Data); *)
; [329] 
; [330] procedure Move(var Source, Dest; Count: Integer); register; external '__move';
; [331] 
; [332] (* -------------------------------------------------------------------------- *)
; [333] (* --- Assertion support ---------------------------------------------------- *)
; [334] (* -------------------------------------------------------------------------- *)
; [335] 
; [336] (* Built-in: procedure Assert(B: Boolean); *)
; [337] 
; [338] var
; [339]   AssertPassed: Integer absolute '__assertpassed';
; [340]   AssertFailed: Integer absolute '__assertfailed';
; [0] program Day19;
; [1] 
; [2] {$a+}
; [3] 
; [4] {$I /Users/joerg/Projects/pl0/lib/files.pas}
; [0] type
; [1]   FileControlBlock = record
; [2]     DR: Byte;
; [3]     FN: array[0..7] of Char;
; [4]     TN: array[0..2] of Char;
; [5]     EX, S1, S2, RC: Byte;
; [6]     AL: array[0..15] of Byte;
; [7]     CR: Byte;
; [8]     RN: array[0..2] of Byte;
; [9]   end;
; [10] 
; [11]   Text = record
; [12]     Offset: Integer;
; [13]     Writing: Boolean;
; [14]     FCB: FileControlBlock;
; [15]     DMA: array[0..127] of Char;
; [16]   end;
; [17] 
; [18] procedure InitFCB(var F: FileControlBlock; S: String);
; [19] var
; [20]   I, L, P, Q: Integer;
global74:       ds      2               ; Global I
global75:       ds      2               ; Global L
global76:       ds      2               ; Global P
global77:       ds      2               ; Global Q
; [21] begin
; var F(+262), S(+6), I(-2), L(-4), P(-6), Q(-8)
proc73:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [22]   with F do
                push    hl
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [23]   begin
; [24]     L := Length(S);
                push    de
                ld      hl,global75     ; Get global L
                push    hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [25] 
; [26]     if (L > 1) and (S[2] = ':') then
                ld      hl,(global75)   ; Get global L
                ex      de,hl
                push    de
                ld      hl,1            ; Literal 1
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl \ inc hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,58           ; Literal 58
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [27]     begin
                bit     0,l
                jp      z,false79
; [28]       DR := Ord(UpCase(S[1])) - 64;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ld      de,64
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [29]       Delete(S, 1, 2);
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      de,2            ; Literal 2
                push    de
                call    __delete
; Post call cleanup 6 bytes
                pop     hl
                pop     hl
                pop     hl
; [30]       Dec(L, 2);
                ld      hl,global75     ; Get global L
                push    hl
                ld      bc,2            ; Literal 2
                pop     hl
                call    __dec16by
; [31]     end
; [32]     else DR := 0;
                jp      endif80
false79:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e
endif80:
; [33] 
; [34]     P := Pos('.', S);
                ld      hl,global76     ; Get global P
                push    hl
                push    hl
                ld      de,46           ; Literal 46
                call    __char2str
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [35]     if P = 0 then P := L + 1;
                ld      hl,(global76)   ; Get global P
                ld      de,0            ; Literal 0
                call    __int16_eq
                and     a
                jp      z,false81
                ld      hl,global76     ; Get global P
                push    hl
                ld      hl,(global75)   ; Get global L
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false81:
; [36] 
; [37]     Q := P - 1;
                ld      hl,global77     ; Get global Q
                push    hl
                ld      hl,(global76)   ; Get global P
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [38]     if Q > 8 then Q := 8;
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                ld      hl,8            ; Literal 8
                pop     de
                call    __int16_lt
                and     a
                jp      z,false82
                ld      hl,global77     ; Get global Q
                ld      de,8
                ld      (hl),e \ inc hl \ ld (hl),d
false82:
; [39] 
; [40]     for I := 1 to Q do FN[I - 1] := UpCase(S[I]);
                ld      hl,global74     ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak84
forloop83:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext85:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak84
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop83
forbreak84:     pop     de              ; Cleanup limit
; [41]     for I := Q + 1 to 8 do FN[I - 1] := ' ';
                ld      hl,global74     ; Get global I
                push    hl
                ld      hl,(global77)   ; Get global Q
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak87
forloop86:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext88:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak87
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop86
forbreak87:     pop     de              ; Cleanup limit
; [42] 
; [43]     Q := L - P;
                ld      hl,global77     ; Get global Q
                push    hl
                ld      hl,(global75)   ; Get global L
                ex      de,hl
                push    de
                ld      hl,(global76)   ; Get global P
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [44]     if Q > 3 then Q := 3;
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                ld      hl,3            ; Literal 3
                pop     de
                call    __int16_lt
                and     a
                jp      z,false89
                ld      hl,global77     ; Get global Q
                ld      de,3
                ld      (hl),e \ inc hl \ ld (hl),d
false89:
; [45] 
; [46]     for I := 1 to Q do TN[I - 1] := UpCase(S[P + I]);
                ld      hl,global74     ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak91
forloop90:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global76)   ; Get global P
                ex      de,hl
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext92:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak91
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop90
forbreak91:     pop     de              ; Cleanup limit
; [47]     for I := Q + 1 to 3 do TN[I - 1] := ' ';
                ld      hl,global74     ; Get global I
                push    hl
                ld      hl,(global77)   ; Get global Q
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,3            ; Literal 3
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak94
forloop93:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext95:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak94
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop93
forbreak94:     pop     de              ; Cleanup limit
; [48] (*
; [49]     Write(DR, ':');
; [50]     for I := 0 to 7 do Write(FN[I]);
; [51]     Write('.');
; [52]     for I := 0 to 2 do Write(TN[I]);
; [53]     WriteLn;
; [54] *)
; [55]   end;
                pop     bc
; [56] end;
exit78:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [57] 
; [58] procedure Assign(var T: Text; S: String);
; [59] begin
; var T(+262), S(+6)
proc96:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [60]   InitFCB(T.FCB, S);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc73
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [61] end;
exit97:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [62] 
; [63] procedure Reset(var T: Text);
; [64] var
; [65]   A: Integer;
global99:       ds      2               ; Global A
; [66] begin
; var T(+6), A(-2)
proc98:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [67]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [68]   begin
; [69]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [70]     begin
; [71]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [72]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [73]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [74]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [75]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [76]     end;
                pop     bc
; [77] 
; [78]     A := Bdos(15, Addr(T.FCB));
                ld      hl,global99     ; Get global A
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [79] 
; [80]     T.Offset := 128;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                ld      (hl),e \ inc hl \ ld (hl),d
; [81]     T.Writing := False;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      de,0
                ld      (hl),e
; [82]   end;
                pop     bc
; [83] end;
exit100:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure Rewrite(var T: Text);
; [86] var
; [87]   A: Integer;
global102:      ds      2               ; Global A
; [88] begin
; var T(+6), A(-2)
proc101:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [89]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [90]   begin
; [91]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [92]     begin
; [93]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [94]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [95]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [96]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [97]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [98]     end;
                pop     bc
; [99] 
; [100]     A := Bdos(19, Addr(FCB));
                ld      hl,global102    ; Get global A
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [101]     A := Bdos(22, Addr(FCB));
                ld      hl,global102    ; Get global A
                push    hl
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [102] 
; [103]     Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [104]     Writing := True;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl
                ld      de,1
                ld      (hl),e
; [105]   end;
                pop     bc
; [106] end;
exit103:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [107] 
; [108] procedure Append(var T: Text);
; [109] var
; [110]   A: Integer;
global105:      ds      2               ; Global A
; [111] begin
; var T(+6), A(-2)
proc104:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [112]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [113]   begin
; [114]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [115]     begin
; [116]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [117]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [118]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [119]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [120]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [121]     end;
                pop     bc
; [122] 
; [123]     A := Bdos(15, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [124]     A := Bdos(35, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,35           ; Literal 35
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [125]     A := Bdos(33, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,33           ; Literal 33
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [126] 
; [127]     Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [128]     while Offset < 128 do
while107:
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_lt
                ld      h,0
                ld      l,a
; [129]     begin
                bit     0,l
                jp      z,false108
; [130]       if DMA[Offset] = #26 then Exit;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false109
                jp      exit106         ; Exit
false109:
; [131]       Inc(Offset);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __inc16
; [132]     end;
                jp      while107
false108:
; [133] 
; [134]     (* Treat 128 as file format error? *)
; [135]   end;
                pop     bc
; [136] end;
exit106:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [137] 
; [138] procedure ReadRec(var T: Text);
; [139] var
; [140]   A: Integer;
global111:      ds      2               ; Global A
; [141] begin
; var T(+6), A(-2)
proc110:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [142]   A := Bdos(26, Addr(T.DMA));
                push    hl
                ld      hl,global111    ; Get global A
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [143]   A := Bdos(20, Addr(T.FCB));
                ld      hl,global111    ; Get global A
                push    hl
                ld      de,20           ; Literal 20
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [144]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [145] end;
exit112:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [146] 
; [147] function ReadChar(var T: Text): Char;
; [148] var
; [149]   C: Char;
global114:      ds      1               ; Global C
; [150] begin
; var ReadChar(+8), T(+6), C(-2)
func113:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [151]   if T.Offset > 127 then ReadRec(T);
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false116
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc110
; Post call cleanup 2 bytes
                pop     hl
false116:
; [152]   C := T.DMA[T.Offset];
                ld      hl,global114    ; Get global C
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [153]   if C <> #26 then T.Offset := T.Offset + 1;
                ld      hl,global114    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_neq
                and     a
                jp      z,false117
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false117:
; [154]   ReadChar := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,global114    ; Get global C
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [155] end;
exit115:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [156] 
; [157] procedure ReadLine(var T: Text; var S: String);
; [158] var
; [159]   C: Char;
global119:      ds      1               ; Global C
; [160] begin
; var T(+8), S(+6), C(-2)
proc118:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [161]   S := '';
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
; [162] 
; [163]   while Length(S) < 255 do
while121:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [164]   begin
                bit     0,l
                jp      z,false122
; [165]     C := ReadChar(T);
                ld      hl,global119    ; Get global C
                push    hl
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    func113
; Post call cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [166] 
; [167]     if C = #10 then Break;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false123
                jp      false122        ; Break
false123:
; [168]     if C = #26 then Break;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false124
                jp      false122        ; Break
false124:
; [169] 
; [170]     if C >= ' ' then S := S + C;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                and     a
                jp      z,false125
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
false125:
; [171]   end;
                jp      while121
false122:
; [172] end;
exit120:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [173] 
; [174] procedure WriteRec(var T: Text);
; [175] var
; [176]   A: Integer;
global127:      ds      2               ; Global A
; [177] begin
; var T(+6), A(-2)
proc126:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [178]   A := Bdos(26, Addr(T.DMA));
                push    hl
                ld      hl,global127    ; Get global A
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [179]   A := Bdos(21, Addr(T.FCB));
                ld      hl,global127    ; Get global A
                push    hl
                ld      de,21           ; Literal 21
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [180]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [181] end;
exit128:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [182] 
; [183] 
; [184] procedure WriteChar(var T: Text; C: Char);
; [185] begin
; var T(+8), C(+6)
proc129:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [186]   if T.Offset > 127 then WriteRec(T);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false131
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc126
; Post call cleanup 2 bytes
                pop     hl
false131:
; [187]   T.DMA[T.Offset] := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [188]   T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [189] end;
exit130:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [190] 
; [191] procedure WriteLine(var T: Text; S: String);
; [192] var
; [193]   I: Integer;
global133:      ds      2               ; Global I
; [194] begin
; var T(+262), S(+6), I(-2)
proc132:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [195]   for I := 1 to Length(S) do WriteChar(T, S[I]);
                push    hl
                ld      hl,global133    ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,(global133)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak136
forloop135:
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global133)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
fornext137:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global133)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak136
                ld      hl,global133    ; Get global I
                call    __inc16
                jp      forloop135
forbreak136:    pop     de              ; Cleanup limit
; [196] 
; [197]   WriteChar(T, #13);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [198]   WriteChar(T, #10);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [199] end;
exit134:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [200] 
; [201] function IsEof(var T: Text): Boolean;
; [202] begin
; var IsEof(+8), T(+6)
func138:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [203]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false140
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc110
; Post call cleanup 2 bytes
                pop     hl
false140:
; [204]   IsEof := T.DMA[T.Offset] = #26;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [205] end;        
exit139:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [206] 
; [207] procedure Close(var T: Text);
; [208] var
; [209]   A: Integer;
global142:      ds      2               ; Global A
; [210] begin
; var T(+6), A(-2)
proc141:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [211]   if T.Writing then
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      d,0
                ld      e,(hl)
; [212]   begin
                ex      de,hl
                bit     0,l
                jp      z,false144
; [213]     WriteChar(T, #26);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [214]     WriteRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc126
; Post call cleanup 2 bytes
                pop     hl
; [215]   end;
false144:
; [216] 
; [217]   A := Bdos(16, Addr(T.FCB));
                ld      hl,global142    ; Get global A
                push    hl
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [218] end;
exit143:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [219] 
; [220] procedure Erase(var T: Text);
; [221] var
; [222]   A: Integer;
global146:      ds      2               ; Global A
; [223] begin
; var T(+6), A(-2)
proc145:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [224]   A := Bdos(19, Addr(T.FCB));
                push    hl
                ld      hl,global146    ; Get global A
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [225] end;
exit147:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [226] 
; [227] procedure Rename(var T: Text; S: String);
; [228] var
; [229]   F: FileControlBlock;
; [230]   A: Integer;
global149:      ds      2               ; Global A
; [231] begin
; var T(+262), S(+6), F(-36), A(-38)
proc148:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-38          ; Space
                add     hl,sp
                ld      sp,hl
; [232]   InitFCB(F, S);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc73
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [233]   Move(F, T.FCB.AL, 12);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ld      de,16
                add     hl,de
                push    hl
                ld      bc,12           ; Literal 12
                pop     de
                pop     hl
                call    __move
; [234]   A := Bdos(23, Addr(T.FCB));
                ld      hl,global149    ; Get global A
                push    hl
                ld      de,23           ; Literal 23
                push    de
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [235] end;
exit150:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [5] {$I bigint.pas}
; [0] {$L bigint.asm}
                include "bigint.asm"
;
; Unsigned big integer math routines adapted from:
;
; Leventhal / Saville: Z80 Assembly Language Subroutines
;

;
; BigAdd: HL^ := HL^+ DE^
;
bigadd:
#local
        ld      b,8
        and     a
        ex      af,af'
bigadd1:
        ex      af,af'
        ld      a,(de)
        adc     (hl)
        ld      (hl),a
        ex      af,af'
        inc     hl
        inc     de
        djnz    bigadd1
        ret
#endlocal

;
; BigSub: HL^ := HL^ - DE^
;
bigsub:
#local
        ex      de,hl
        ld      b,8
        and     a
        ex      af,af'
bigsub1:
        ex      af,af'
        ld      a,(de)
        sbc     (hl)
        ld      (de),a
        ex      af,af'
        inc     hl
        inc     de
        djnz    bigsub1
        ret
#endlocal

;
; BigMul: HL^ := HL^ * DE^
;
bigmul:
#local
        ld      c,8
        ld      b,0
        add     hl,bc
        ex      de,hl
        ld      (mlier),hl
        ld      hl,hiprod
        add     hl,bc
        ld      (endhp),hl

        ld      l,c
        ld      h,b
        add     hl,hl
        add     hl,hl
        add     hl,hl
        inc     hl
        ld      (count),hl
zeropd:
        ld      b,c
        ld      hl,hiprod
zerolp:
        ld      (hl),0
        inc     hl
        djnz    zerolp

        and     a
loop:
        ld      b,c
        ld      hl,(endhp)
srplp:
        dec     hl
        rr      (hl)
        djnz    srplp

        ld      l,e
        ld      h,d
        ld      b,c
srailp:
        dec     hl
        rr      (hl)
        djnz    srailp

        jp      nc,deccnt

        push    de
        ld      de,(mlier)
        ld      hl,hiprod
        ld      b,c
        and     a
addlp:
        ld      a,(de)
        adc     a,(hl)
        ld      (hl),a
        inc     de
        inc     hl
        djnz    addlp
        pop     de

deccnt:
        ld      a,(count)
        dec     a
        ld      (count),a
        jp      nz,loop
        push    af
        ld      a,(count+1)
        and     a
        jp      z,exit
        dec     a
        ld      (count+1),a
        pop     af
        jp      loop
exit:
        pop     af
        ret

count:  ds      2
endhp:  ds      2
mlier:  ds      2
hiprod: ds      8
#endlocal

;
; BigDiv: HL^ := HL^ / DE^ and DE^ := HL^ % DE^
;
bigdiv:
#local
        ld      (dvend),hl
        ld      (dvsor),de
        push    bc
        ld      c,8

        ld      l,c
        ld      h,0
        add     hl,hl
        add     hl,hl
        add     hl,hl
        inc     hl
        ld      (count),hl

        ld      hl,hide1
        ld      de,hide2
        ld      b,c
        sub     a
zerolp:
        ld      (hl),a
        ld      (de),a
        inc     hl
        inc     de
        djnz    zerolp

        ld      hl,hide1
        ld      (hdeptr),hl

        ld      hl,hide2
        ld      (odeptr),hl

        ld      hl,(dvsor)
        ld      b,c
        sub     a
chkolp:
        or      (hl)
        inc     hl
        djnz    chkolp
        or      a
        jr      z,erexit

        or      a

loop:
        ld      b,c
        ld      hl,(dvend)
sllp1:
        rl      (hl)
        inc     hl
        djnz    sllp1

deccnt:
        ld      a,(count)
        dec     a
        ld      (count),a
        jr      nz,cont
        ld      a,(count+1)
        dec     a
        ld      (count+1),a
        jp      m,okexit

cont:
        ld      hl,(hdeptr)
        ld      b,c
sllp2:
        rl      (hl)
        inc     hl
        djnz    sllp2

        push    bc
        ld      a,c
        ld      (subcnt),a
        ld      bc,(odeptr)
        ld      de,(hdeptr)
        ld      hl,(dvsor)
        or      a
sublp:
        ld      a,(de)
        sbc     a,(hl)
        ld      (bc),a
        inc     hl
        inc     de
        inc     bc
        ld      a,(subcnt)
        dec     a
        ld      (subcnt),a
        jr      nz,sublp
        pop     bc

        ccf
        jr      nc,loop
        ld      hl,(hdeptr)
        ld      de,(odeptr)
        ld      (odeptr),hl
        ld      (hdeptr),de

        jp      loop

erexit:
        scf
        jp      exit

okexit:
        or      a

exit:
        ld      hl,(hdeptr)
        pop     de
        ld      bc,8
        ldir

        ret

dvend:  ds      2
dvsor:  ds      2
hdeptr: ds      2
odeptr: ds      2
count:  ds      2
subcnt: ds      1
hide1:  ds      8
hide2:  ds      8
#endlocal
; [1] 
; [2] type
; [3]   BigInt = array[0..7] of Byte;
; [4] 
; [5] const
; [6]   BigMin: BigInt = (0, 0, 0, 0, 0, 0, 0, 0);
const151:
                db      0,0,0,0,0,0,0,0
; [7]   BigMax: BigInt = (255, 255, 255, 255, 255, 255, 255, 127);
const152:
                db      255,255,255,255,255,255,255,127
; [8]   BigOne: BigInt = (1, 0, 0, 0, 0, 0, 0, 0);
const153:
                db      1,0,0,0,0,0,0,0
; [9]   BigTen: BigInt = (10, 0, 0, 0, 0, 0, 0, 0);
const154:
                db      10,0,0,0,0,0,0,0
; [10] 
; [11] procedure BigAdd(var X, Y: BigInt); register; external 'bigadd';
; [12] procedure BigSub(var X, Y: BigInt); register; external 'bigsub';
; [13] procedure BigMul(var X, Y: BigInt); register; external 'bigmul';
; [14] procedure BigDiv(var X, Y, Z: BigInt); register; external 'bigdiv';
; [15] 
; [16] function BigCmp(var X, Y: BigInt): Integer;
; [17] var
; [18]   I: Integer;
global160:      ds      2               ; Global I
; [19]   B: Byte;
global161:      ds      1               ; Global B
; [20] begin
; var BigCmp(+10), X(+8), Y(+6), I(-2), B(-4)
func159:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [21]   for B := 7 downto 0 do
                push    hl
                ld      hl,global161    ; Get global B
                ld      de,7
                ld      (hl),e
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      hl,global161    ; Get global B
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_geq
                and     a
                jp      z,forbreak164
forloop163:
; [22]   begin
; [23]     I := X[B] - Y[B];
                ld      hl,global160    ; Get global I
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global161    ; Get global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global161    ; Get global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [24]     if I <> 0 then
                ld      hl,(global160)  ; Get global I
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [25]     begin 
                bit     0,l
                jp      z,false166
; [26]       BigCmp := I; 
                ld      de,ix
                ld      hl,10
                add     hl,de
                push    hl
                ld      hl,(global160)  ; Get global I
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [27]       Exit;
                jp      exit162         ; Exit
; [28]     end;
false166:
; [29]   end;
fornext165:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global161    ; Get global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_lt
                and     a
                jp      z,forbreak164
                ld      hl,global161    ; Get global B
                dec     (hl)
                jp      forloop163
forbreak164:    pop     de              ; Cleanup limit
; [30] 
; [31]   BigCmp := 0;
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [32] end;
exit162:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [33] 
; [34] procedure BigVal(S: String; var X: BigInt);
; [35] var
; [36]   B: Byte;
global168:      ds      1               ; Global B
; [37]   Y: BigInt;
global169:      ds      8               ; Global Y
; [38]   I, J: Integer;
global170:      ds      2               ; Global I
global171:      ds      2               ; Global J
; [39] begin
; var S(+8), X(+6), B(-2), Y(-10), I(-12), J(-14)
proc167:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [40]   X := BigMin;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,const151     ; Get global BigMin
                ld      bc,8
                pop     de
                ldir
; [41] 
; [42]   if Length(S) < 3 then
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,3            ; Literal 3
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [43]   begin
                bit     0,l
                jp      z,false173
; [44]     Val(S, I, J);
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                ld      hl,global170    ; Get global I
                push    hl
                ld      hl,global171    ; Get global J
                push    hl
                call    __val_int
; [45]     X[0] := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                push    hl
                ld      hl,(global170)  ; Get global I
                ex      de,hl
                pop     hl
                ld      (hl),e
; [46]     Exit;
                jp      exit172         ; Exit
; [47]   end;
false173:
; [48] 
; [49]   Y := BigMin;
                ld      hl,global169    ; Get global Y
                push    hl
                ld      hl,const151     ; Get global BigMin
                ld      bc,8
                pop     de
                ldir
; [50] 
; [51]   for B := 1 to Length(S) do
                ld      hl,global168    ; Get global B
                ld      de,1
                ld      (hl),e
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global168    ; Get global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak175
forloop174:
; [52]   begin
; [53]     BigMul(X, BigTen);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,const154     ; Get global BigTen
                ex      de,hl
                pop     hl
                call    bigmul
; [54]     Y[0] := Ord(S[B]) - 48;
                ld      hl,global169    ; Get global Y
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,global168    ; Get global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,48           ; Literal 48
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [55]     BigAdd(X, Y); 
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global169    ; Get global Y
                ex      de,hl
                pop     hl
                call    bigadd
; [56]   end;
fornext176:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global168    ; Get global B
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak175
                ld      hl,global168    ; Get global B
                inc     (hl)
                jp      forloop174
forbreak175:    pop     de              ; Cleanup limit
; [57] end;
exit172:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [58] 
; [59] procedure BigStr(X: BigInt; var S: String);
; [60] var
; [61]   Y: BigInt;
global178:      ds      8               ; Global Y
; [62] begin
; var X(+8), S(+6), Y(-8)
proc177:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [63]   S := '';
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
; [64] 
; [65]   repeat
repeat180:
; [66]     BigDiv(X, BigTen, Y);
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,const154     ; Get global BigTen
                push    hl
                ld      hl,global178    ; Get global Y
                ld      bc,hl
                pop     de
                pop     hl
                call    bigdiv
; [67]     S := '' + Char(48 + Y[0]) + S;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string68
                call    __loadstr
                ld      de,48           ; Literal 48
                push    de
                ld      hl,global178    ; Get global Y
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
; [68]   until BigCmp(X, BigMin) = 0;
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,const151     ; Get global BigMin
                push    hl
                call    func159
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                and     a
                jp      z,repeat180
break181:
; [69] end;
exit179:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [6] 
; [7] type
; [8]   TowelPtr = ^Towel;
; [9]   Towel = record
; [10]     Pattern: String[10];
; [11]     Next: TowelPtr;
; [12]   end;
; [13] 
; [14] var
; [15]   Towels: array['a'..'z'] of TowelPtr;
global182:      ds      52              ; Global Towels
; [16] 
; [17]   Table: array[0..79] of BigInt;
global183:      ds      640             ; Global Table
; [18]   Used: array[0..79] of Boolean;
global184:      ds      80              ; Global Used
; [19] 
; [20]   Pattern: String;
global185:      ds      256             ; Global Pattern
; [21] 
; [22] procedure Init;
; [23] var
; [24]   C: Char;
global187:      ds      1               ; Global C
; [25] begin
; var C(-2)
proc186:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [26]   for C := 'a' to 'z' do
                push    hl
                ld      hl,global187    ; Get global C
                ld      de,97
                ld      (hl),e
                ld      de,122          ; Literal 122
                push    de
                push    de
                ld      hl,global187    ; Get global C
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak190
forloop189:
; [27]     Towels[C] := nil;
                ld      hl,global182    ; Get global Towels
                push    hl
                ld      hl,global187    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
fornext191:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global187    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak190
                ld      hl,global187    ; Get global C
                inc     (hl)
                jp      forloop189
forbreak190:    pop     de              ; Cleanup limit
; [28] end;
exit188:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [29] 
; [30] procedure Clear;
; [31] var
; [32]   I: Integer;
global193:      ds      2               ; Global I
; [33] begin
; var I(-2)
proc192:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [34]   for I := 0 to 79 do
                push    hl
                ld      hl,global193    ; Get global I
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,79           ; Literal 79
                push    de
                push    de
                ld      hl,(global193)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak196
forloop195:
; [35]   begin
; [36]     Used[I] := False;
                ld      hl,global184    ; Get global Used
                push    hl
                ld      hl,(global193)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,0
                ld      (hl),e
; [37]     Table[I] := BigMin;
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,(global193)  ; Get global I
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const151     ; Get global BigMin
                ld      bc,8
                pop     de
                ldir
; [38]   end;
fornext197:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global193)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak196
                ld      hl,global193    ; Get global I
                call    __inc16
                jp      forloop195
forbreak196:    pop     de              ; Cleanup limit
; [39] end;
exit194:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [40] 
; [41] procedure AddTowel(S: String);
; [42] var
; [43]   C: Char;
global199:      ds      1               ; Global C
; [44]   P: TowelPtr;
global200:      ds      2               ; Global P
; [45] begin
; var S(+6), C(-2), P(-4)
proc198:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [46]   C := S[1];
                push    hl
                ld      hl,global199    ; Get global C
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [47]   New(P);
                ld      hl,global200    ; Get global P
                ld      de,13
                call    __getmem
; [48]   P^.Pattern := S;
                ld      hl,global200    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                pop     de
                ld      a,10
                call    __movestr
; [49]   P^.Next := Towels[C];
                ld      hl,global200    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                push    hl
                ld      hl,global182    ; Get global Towels
                push    hl
                ld      hl,global199    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [50]   Towels[C] := P;
                ld      hl,global182    ; Get global Towels
                push    hl
                ld      hl,global199    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global200)  ; Get global P
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [51] end;
exit201:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [52] 
; [53] function StrEquals(var A, B: Char; Len: Integer): Boolean; register; inline
func202:
; [54] (
; [55]   $41 /               (*       ld b,c     *)
                db      65
; [56]   $1a /               (* loop: ld a, (de) *)
                db      26
; [57]   $be /               (*       cp (hl)    *)
                db      190
; [58]   $28 / $04 /         (*       jr z,pass  *)
                db      40,4
; [59]   $21 / $00 / $00 /   (*       ld hl, 0   *)
                db      33,0,0
; [60]   $c9 /               (*       ret        *)
                db      201
; [61]   $23 /               (* pass: inc hl     *)
                db      35
; [62]   $13 /               (*       inc de     *)
                db      19
; [63]   $10 / $f4 /         (*       djnz loop  *)
                db      16,244
; [64]   $21 / $01 / $00 /   (*       ld hl, 1   *)
                db      33,1,0
; [65]   $c9                 (*       ret        *)
; [66] );
                db      201
                ret
; [67] 
; [68] 
; [69] function NumberOfWays(Pattern: String): BigInt;
; [70] var
; [71]   I, J, LP, LT: Integer;
global204:      ds      2               ; Global I
global205:      ds      2               ; Global J
global206:      ds      2               ; Global LP
global207:      ds      2               ; Global LT
; [72]   C: Char;
global208:      ds      1               ; Global C
; [73]   P: TowelPtr;
global209:      ds      2               ; Global P
; [74] begin
; var NumberOfWays(+262), Pattern(+6), I(-2), J(-4), LP(-6), LT(-8), C(-10), P(-12)
func203:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [75]   for I := 0 to 79 do
                ld      hl,global204    ; Get global I
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,79           ; Literal 79
                push    de
                push    de
                ld      hl,(global204)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak212
forloop211:
; [76]     Table[I] := BigMin;
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,(global204)  ; Get global I
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const151     ; Get global BigMin
                ld      bc,8
                pop     de
                ldir
fornext213:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global204)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak212
                ld      hl,global204    ; Get global I
                call    __inc16
                jp      forloop211
forbreak212:    pop     de              ; Cleanup limit
; [77] 
; [78]   LP := Byte(Pattern[0]);
                ld      hl,global206    ; Get global LP
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [79] 
; [80]   Table[LP + 1] := BigOne;
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,(global206)  ; Get global LP
                inc     hl              ; Literal 1
                ld      de,8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,const153     ; Get global BigOne
                ld      bc,8
                pop     de
                ldir
; [81] 
; [82]   for J := LP downto 1 do
                ld      hl,global205    ; Get global J
                push    hl
                ld      hl,(global206)  ; Get global LP
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,1            ; Literal 1
                push    de
                push    de
                ld      hl,(global205)  ; Get global J
                pop     de
                call    __int16_geq
                and     a
                jp      z,forbreak215
forloop214:
; [83]   begin
; [84]     C := Pattern[J];
                ld      hl,global208    ; Get global C
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [85]     P := Towels[C];
                ld      hl,global209    ; Get global P
                push    hl
                ld      hl,global182    ; Get global Towels
                push    hl
                ld      hl,global208    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [86]     while P <> nil do
while217:
                ld      hl,(global209)  ; Get global P
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [87]     begin
                bit     0,l
                jp      z,false218
; [88]       LT := Byte(P^.Pattern[0]);
                ld      hl,global207    ; Get global LT
                push    hl
                ld      hl,global209    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [89]       if J + LT <= LP + 1 then
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                push    de
                ld      hl,(global207)  ; Get global LT
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global206)  ; Get global LP
                inc     hl              ; Literal 1
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
; [90]         if StrEquals(Pattern[J], P^.Pattern[1], LT) then
                bit     0,l
                jp      z,false219
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global209    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                ld      hl,(global207)  ; Get global LT
                ex      de,hl
                ld      bc,de
                pop     de
                pop     hl
                call    func202
; [91]         begin
                bit     0,l
                jp      z,false220
; [92]           GotoXY(J, 22);
                ld      hl,(global205)  ; Get global J
                ld      de,22           ; Literal 22
                call    __gotoxy
; [93]           Write(Copy(Pattern, J, LT));
                call    __mkstr
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                push    de
                ld      hl,(global207)  ; Get global LT
                ex      de,hl
                push    de
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,0
                add     hl,sp
                call    __puts
                call    __rmstr
; [94]           BigAdd(Table[J], Table[J + LT]);
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,(global205)  ; Get global J
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                push    de
                ld      hl,(global207)  ; Get global LT
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [95]           (*GotoXY(J, 22);
; [96]           Write(#27'q', Copy(Pattern, J, LT));*)
; [97]         end;
false220:
false219:
; [98] 
; [99]       P := P^.Next;
                ld      hl,global209    ; Get global P
                push    hl
                ld      hl,global209    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [100]     end;
                jp      while217
false218:
; [101]   end;
fornext216:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global205)  ; Get global J
                ex      de,hl
                pop     hl
                call    __int16_lt
                and     a
                jp      z,forbreak215
                ld      hl,global205    ; Get global J
                call    __dec16
                jp      forloop214
forbreak215:    pop     de              ; Cleanup limit
; [102] 
; [103]   NumberOfWays := Table[1];
                ld      de,ix
                ld      hl,262
                add     hl,de
                push    hl
                ld      hl,global183    ; Get global Table
                push    hl
                ld      hl,1            ; Literal 1
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      bc,8
                pop     de
                ldir
; [104] end;
exit210:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [105] 
; [106] procedure Explore(Index: Integer; var Count: BigInt);
; [107] var
; [108]   I, LT, LP: Integer;
global222:      ds      2               ; Global I
global223:      ds      2               ; Global LT
global224:      ds      2               ; Global LP
; [109]   P: TowelPtr;
global225:      ds      2               ; Global P
; [110] begin
; var Index(+8), Count(+6), I(-2), LT(-4), LP(-6), P(-8)
proc221:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [111]   LP := Byte(Pattern[0]);
                push    hl
                ld      hl,global224    ; Get global LP
                push    hl
                ld      hl,global185    ; Get global Pattern
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [112] 
; [113]   if Index = LP + 1 then
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,(global224)  ; Get global LP
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
; [114]   begin
                bit     0,l
                jp      z,false227
; [115]     BigAdd(Count, BigOne);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,const153     ; Get global BigOne
                ex      de,hl
                pop     hl
                call    bigadd
; [116]     Exit;
                jp      exit226         ; Exit
; [117]   end;
false227:
; [118] 
; [119]   if not Used[Index] then
                ld      hl,global184    ; Get global Used
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
; [120]   begin
                bit     0,l
                jp      z,false228
; [121]     P := Towels[Pattern[Index]];
                ld      hl,global225    ; Get global P
                push    hl
                ld      hl,global182    ; Get global Towels
                push    hl
                ld      hl,global185    ; Get global Pattern
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                xor     a
                sbc     hl,de
                add     hl,hl
                ex      de,hl
                pop     hl
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [122]     while P <> nil do
while229:
                ld      hl,(global225)  ; Get global P
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [123]     begin
                bit     0,l
                jp      z,false230
; [124]       LT := Byte(P^.Pattern[0]);
                ld      hl,global223    ; Get global LT
                push    hl
                ld      hl,global225    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [125] 
; [126]       if Index + LT <= LP + 1 then
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,(global223)  ; Get global LT
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global224)  ; Get global LP
                inc     hl              ; Literal 1
                pop     de
                call    __int16_geq
                ld      h,0
                ld      l,a
; [127]         if StrEquals(Pattern[Index], P^.Pattern[1], LT) then
                bit     0,l
                jp      z,false231
                ld      hl,global185    ; Get global Pattern
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global225    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                ld      hl,(global223)  ; Get global LT
                ex      de,hl
                ld      bc,de
                pop     de
                pop     hl
                call    func202
; [128]           Explore(Index + LT, Table[Index]);
                bit     0,l
                jp      z,false232
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,(global223)  ; Get global LT
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global183    ; Get global Table
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                call    proc221
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
false232:
false231:
; [129] 
; [130]       P := P^.Next;
                ld      hl,global225    ; Get global P
                push    hl
                ld      hl,global225    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,11           ; Literal 11
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [131]     end;
                jp      while229
false230:
; [132]     
; [133]     Used[Index] := True;
                ld      hl,global184    ; Get global Used
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      de,1
                ld      (hl),e
; [134]   end;
false228:
; [135] 
; [136]   BigAdd(Count, Table[Index]);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,global183    ; Get global Table
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,8            ; Literal 8
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [137] end;
exit226:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [138] 
; [139] procedure Solve(Path: String);
; [140] var
; [141]   T: Text;
; [142]   S: String;
; [143]   C: Char;
global234:      ds      1               ; Global C
; [144]   Part1: Integer;
global235:      ds      2               ; Global Part1
; [145]   Part2, Tmp: BigInt;
global236:      ds      8               ; Global Part2
global237:      ds      8               ; Global Tmp
; [146] begin
; var Path(+6), T(-167), S(-423), C(-425), Part1(-427), Part2(-435), Tmp(-443)
proc233:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-443         ; Space
                add     hl,sp
                ld      sp,hl
; [147]   Part1 := 0;
                ld      hl,global235    ; Get global Part1
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [148]   Part2 := BigMin;
                ld      hl,global236    ; Get global Part2
                push    hl
                ld      hl,const151     ; Get global BigMin
                ld      bc,8
                pop     de
                ldir
; [149] 
; [150]   Assign(T, Path);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc96
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [151]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc98
; Post call cleanup 2 bytes
                pop     hl
; [152] 
; [153]   S := '';
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
; [154]   C := ReadChar(T);
                ld      hl,global234    ; Get global C
                push    hl
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func113
; Post call cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [155]   while C >= ' ' do
while239:
                ld      hl,global234    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                ld      h,0
                ld      l,a
; [156]   begin
                bit     0,l
                jp      z,false240
; [157]     if C >= 'a' then
                ld      hl,global234    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,97           ; Literal 97
                call    __int16_geq
                ld      h,0
                ld      l,a
; [158]       S := S + C
                bit     0,l
                jp      z,false241
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
; [159]     else if C = ',' then
                ld      hl,global234    ; Get global C
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
                jp      endif242
false241:
                ld      hl,global234    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,44           ; Literal 44
                call    __int16_eq
                ld      h,0
                ld      l,a
; [160]     begin
                bit     0,l
                jp      z,false243
; [161]       AddTowel(S);
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    proc198
; Post call cleanup 256 bytes
                call    __rmstr
; [162]       S := '';
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
; [163]     end;
false243:
endif242:
; [164] 
; [165]     C := ReadChar(T);
                ld      hl,global234    ; Get global C
                push    hl
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func113
; Post call cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [166]   end;
                jp      while239
false240:
; [167] 
; [168]   AddTowel(S);
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                call    proc198
; Post call cleanup 256 bytes
                call    __rmstr
; [169] 
; [170]   ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [171]   while not IsEof(T) do
while244:
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func138
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [172]   begin
                bit     0,l
                jp      z,false245
; [173]     ReadLine(T, Pattern);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      hl,global185    ; Get global Pattern
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [174]     GotoXY(1, 6);
                ld      hl,1            ; Literal 1
                ld      de,6            ; Literal 6
                call    __gotoxy
; [175]     Write(#27'M');
                ld      hl,string246
                call    __puts
; [176]     GotoXY(1, 22);
                ld      hl,1            ; Literal 1
                ld      de,22           ; Literal 22
                call    __gotoxy
; [177]     Write(#27'p', Pattern, #27'q');
                ld      hl,string247
                call    __puts
                ld      hl,global185    ; Get global Pattern
                call    __puts
                ld      hl,string248
                call    __puts
; [178]     (*Clear;*)
; [179]     Tmp := NumberOfWays(Pattern);
                ld      hl,global237    ; Get global Tmp
                push    hl
                push    hl
                push    hl
                push    hl
                push    hl
                ld      hl,global185    ; Get global Pattern
                call    __loadstr
                call    func203
; Post call cleanup 256 bytes
                call    __rmstr
                ld      bc,8
                call    __store16
; [180]     if BigCmp(Tmp, BigMin) <> 0 then
                push    hl
                ld      hl,global237    ; Get global Tmp
                push    hl
                ld      hl,const151     ; Get global BigMin
                push    hl
                call    func159
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [181]       Inc(Part1);
                bit     0,l
                jp      z,false249
                ld      hl,global235    ; Get global Part1
                call    __inc16
false249:
; [182] 
; [183]     BigStr(Tmp, S);
                ld      hl,global237    ; Get global Tmp
                ld      bc,8
                call    __load16
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc177
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [184]     GotoXY(60, 22); Write(' -> ', S:15);
                ld      hl,60           ; Literal 60
                ld      de,22           ; Literal 22
                call    __gotoxy
                ld      hl,string250
                call    __puts
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      bc,15           ; Literal 15
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                call    __rmstr
; [185] 
; [186]     BigAdd(Part2, Tmp);
                ld      hl,global236    ; Get global Part2
                push    hl
                ld      hl,global237    ; Get global Tmp
                ex      de,hl
                pop     hl
                call    bigadd
; [187] 
; [188]     GotoXY(9, 3);
                ld      hl,9            ; Literal 9
                ld      de,3            ; Literal 3
                call    __gotoxy
; [189]     Write(Part1:15);
                ld      hl,(global235)  ; Get global Part1
                ex      de,hl
                push    de
                ld      bc,15           ; Literal 15
                pop     hl
                call    __putn_fmt
; [190]     GotoXY(9, 4);
                ld      hl,9            ; Literal 9
                ld      de,4            ; Literal 4
                call    __gotoxy
; [191]     BigStr(Part2, S);
                ld      hl,global236    ; Get global Part2
                ld      bc,8
                call    __load16
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc177
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [192]     Write(S: 15);
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      bc,15           ; Literal 15
                ld      hl,0
                add     hl,sp
                call    __puts_fmt
                call    __rmstr
; [193]   end;
                jp      while244
false245:
; [194] end;
exit238:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [195]     
; [196] var
; [197]   S, T: String;
global251:      ds      256             ; Global S
global252:      ds      256             ; Global T
; [198] 
; [199] begin
; var BigMin(0), BigMax(0), BigOne(0), BigTen(0), Towels(0), Table(0), Used(0), Pattern(0), S(0), T(0)
main:           call    __init
                ld      ix,0
                add     ix,sp
; [200]   Write(#27'E'#27'f');
                ld      hl,string254
                call    __puts
; [201]   WriteLn('*** AoC 2024.19 Linen Layout ***');
                ld      hl,string255
                call    __puts
                call    __newline
; [202]   WriteLn;
                call    __newline
; [203]   WriteLn('Part 1:');
                ld      hl,string256
                call    __puts
                call    __newline
; [204]   WriteLn('Part 2:');
                ld      hl,string257
                call    __puts
                call    __newline
; [205] (*
; [206]   S := 'HALLO';
; [207]   T := 'HAILO';
; [208]   WriteLn(StrEquals(S[1], T[1], 5));
; [209] *)
; [210]   InitHeap(32768);
                ld      de,32768        ; Literal 32768
                push    de
                call    proc16
; Post call cleanup 2 bytes
                pop     hl
; [211]   Init;
                call    proc186
; [212]   Solve('INPUT   .TXT');
                ld      hl,string258
                call    __loadstr
                call    proc233
; Post call cleanup 256 bytes
                call    __rmstr
; [213] 
; [214]   GotoXY(1, 23);
                ld      hl,1            ; Literal 1
                ld      de,23           ; Literal 23
                call    __gotoxy
; [215]   Write(#27'e');
                ld      hl,string259
                call    __puts
; [216] end.
exit253:        call    __done
                ret
string68:       db      0
string246:      db      2,27,"M"
string247:      db      2,27,"p"
string248:      db      2,27,"q"
string250:      db      4," -> "
string254:      db      4,27,"E",27,"f"
string255:      db      32,"*** AoC 2024.19 Linen Layout ***"
string256:      db      7,"Part 1:"
string257:      db      7,"Part 2:"
string258:      db      12,"INPUT   .TXT"
string259:      db      2,27,"e"
display:        ds      32              ; Display
eof:                                    ; End of file
; HEAP:
; end


; +++ segments +++

#CODE          = $0100 =   256,  size = $3991 = 14737

; +++ global symbols +++

AAC1         = $0845 =  2117          math48.z80:382 (unused)
AC1          = $1040 =  4160          math48.z80:1913
ACLN2        = $0C78 =  3192          math48.z80:1210
ACPI         = $0C6E =  3182          math48.z80:1203
ADD1         = $06B8 =  1720          math48.z80:52
ADD10        = $0723 =  1827          math48.z80:134
ADD2         = $06CB =  1739          math48.z80:71
ADD3         = $06E0 =  1760          math48.z80:89
ADD4         = $06EB =  1771          math48.z80:98
ADD5         = $06FF =  1791          math48.z80:111
ADD6         = $0709 =  1801          math48.z80:117
ADD7         = $070C =  1804          math48.z80:118
ADD8         = $071D =  1821          math48.z80:129
ADD9         = $071E =  1822          math48.z80:130
ADD9A        = $0722 =  1826          math48.z80:132
ADDAC        = $0842 =  2114          math48.z80:379
ADDZ         = $071A =  1818          math48.z80:127
ARCTAN       = $0C16 =  3094          math48.z80:1137
ARCTK        = $0BF8 =  3064          math48.z80:1124
ATN          = $0B27 =  2855          math48.z80:1002
ATN1         = $0B3C =  2876          math48.z80:1019
ATN2         = $0B4A =  2890          math48.z80:1029
ATN3         = $0B5F =  2911          math48.z80:1040
ATN4         = $0B65 =  2917          math48.z80:1043
ATN5         = $0B80 =  2944          math48.z80:1060
ATN6         = $0BAE =  2990          math48.z80:1084
ATN7         = $0BBC =  3004          math48.z80:1095
ATN8         = $0BC4 =  3012          math48.z80:1099
ATNK         = $0BC8 =  3016          math48.z80:1105
CALC1        = $0C35 =  3125          math48.z80:1166
CALCS        = $0C31 =  3121          math48.z80:1164
CMP          = $088F =  2191          math48.z80:466
CMP1         = $0899 =  2201          math48.z80:475
CMP2         = $08A3 =  2211          math48.z80:483
CMPAC        = $0876 =  2166          math48.z80:437
CNV1         = $0F9E =  3998          math48.z80:1798
CNV2         = $0FB3 =  4019          math48.z80:1811
CNV3         = $0FD7 =  4055          math48.z80:1833
CNV4         = $0FDA =  4058          math48.z80:1836
CNV4A        = $0FEF =  4079          math48.z80:1846
CNV4B        = $0FF1 =  4081          math48.z80:1848
CNV4C        = $1009 =  4105          math48.z80:1866
CNV4D        = $1011 =  4113          math48.z80:1871
CNV5         = $1012 =  4114          math48.z80:1873
CNV6         = $101F =  4127          math48.z80:1881
CNV6A        = $0FF5 =  4085          math48.z80:1850
CNVN         = $0F80 =  3968          math48.z80:1779
COMSER       = $0C1C =  3100          math48.z80:1145
CON10        = $0F1A =  3866          math48.z80:1722
COS          = $094F =  2383          math48.z80:653
CPM          = $0001 =     1          day19.z80:2 (unused)
DIGI1        = $0D61 =  3425          math48.z80:1428
DIGI2        = $0D6D =  3437          math48.z80:1434
DIGITS       = $0D17 =  3351          math48.z80:1374
DIGTST       = $1039 =  4153          math48.z80:1905
DIVI1        = $075B =  1883          math48.z80:192
DIVI2        = $0764 =  1892          math48.z80:197
DIVI3        = $0777 =  1911          math48.z80:211
DIVI4        = $0783 =  1923          math48.z80:219
DIVI5        = $078C =  1932          math48.z80:224
DIVI6        = $0798 =  1944          math48.z80:233
DZERO        = $0D11 =  3345          math48.z80:1371
EQUAL        = $0C82 =  3202          math48.z80:1217
EXP          = $0AB6 =  2742          math48.z80:920
EXP1         = $0ADA =  2778          math48.z80:945 (unused)
EXP3         = $0AE7 =  2791          math48.z80:951 (unused)
EXP4         = $0AEC =  2796          math48.z80:956
EXP5         = $0AEE =  2798          math48.z80:958
EXP6         = $0AF1 =  2801          math48.z80:960
EXPK         = $0AFD =  2813          math48.z80:969
EXPN         = $0080 =   128          math48.z80:39
EXPS1        = $0805 =  2053          math48.z80:324
EXPS2        = $0809 =  2057          math48.z80:327
EXPS3        = $0820 =  2080          math48.z80:343
EXPSGN       = $07FD =  2045          math48.z80:319
FIX          = $0C8A =  3210          math48.z80:1229
FIX1         = $0C94 =  3220          math48.z80:1236
FIX2         = $0CA0 =  3232          math48.z80:1244
FIX3         = $0CAD =  3245          math48.z80:1252
FIX4         = $0CB0 =  3248          math48.z80:1256
FLOAT        = $0CB4 =  3252          math48.z80:1262
FLT1         = $0CC4 =  3268          math48.z80:1274
FLT2         = $0CCD =  3277          math48.z80:1280
FLT3         = $0CD7 =  3287          math48.z80:1286
FPADD        = $06B1 =  1713          math48.z80:47
FPDIV        = $0740 =  1856          math48.z80:165
FPMUL        = $079F =  1951          math48.z80:242
FPNEG        = $0736 =  1846          math48.z80:152
FPSUB        = $0729 =  1833          math48.z80:144
FRAC         = $08E1 =  2273          math48.z80:546
FSTRR        = $0CDC =  3292          math48.z80:1325
FSTRS        = $0CE3 =  3299          math48.z80:1338
FWIDTH       = $000F =    15          math48.z80:42
GDTST        = $1036 =  4150          math48.z80:1904
GETCIX       = $0C5B =  3163          math48.z80:1193
GTNCIX       = $0C56 =  3158          math48.z80:1191
INT          = $08AD =  2221          math48.z80:495
INT1         = $08BD =  2237          math48.z80:508
INT2         = $08DE =  2270          math48.z80:539
IWIDTH       = $00F0 =   240          math48.z80:41
LEFT         = $0837 =  2103          math48.z80:370
LN           = $0A1A =  2586          math48.z80:806
LN1          = $0A6F =  2671          math48.z80:864
LNK          = $0A87 =  2695          math48.z80:880
LOG          = $0A03 =  2563          math48.z80:783
M10A         = $0F79 =  3961          math48.z80:1771
MFACT        = $1022 =  4130          math48.z80:1885
MOD          = $08F3 =  2291          math48.z80:564
MORED        = $0ED7 =  3799          math48.z80:1679
MUL1         = $07BB =  1979          math48.z80:267
MUL10        = $0F56 =  3926          math48.z80:1746
MUL2         = $07C2 =  1986          math48.z80:271
MUL3         = $07CA =  1994          math48.z80:276
MUL4         = $07E6 =  2022          math48.z80:296
MUL5         = $07E9 =  2025          math48.z80:300
MUL5A        = $07EA =  2026          math48.z80:301
OEX1         = $0E98 =  3736          math48.z80:1636
OEX2         = $0E9E =  3742          math48.z80:1639
OM1          = $0DF5 =  3573          math48.z80:1536
OM10         = $0E4E =  3662          math48.z80:1592
OM11         = $0E57 =  3671          math48.z80:1598
OM12         = $0E5E =  3678          math48.z80:1602
OM13         = $0E6E =  3694          math48.z80:1612
OM14         = $0E77 =  3703          math48.z80:1618
OM15         = $0E83 =  3715          math48.z80:1624
OM2          = $0E0D =  3597          math48.z80:1552
OM3          = $0E0E =  3598          math48.z80:1553
OM4          = $0E13 =  3603          math48.z80:1556
OM5          = $0E1E =  3614          math48.z80:1565
OM6          = $0E28 =  3624          math48.z80:1571
OM7          = $0E38 =  3640          math48.z80:1579
OM8          = $0E44 =  3652          math48.z80:1585
OM9          = $0E47 =  3655          math48.z80:1587
OUTM         = $0DED =  3565          math48.z80:1530
OUTN1        = $0CF2 =  3314          math48.z80:1346
POPA1        = $0EAD =  3757          math48.z80:1647
POPALL       = $0EAE =  3758          math48.z80:1648
PWR          = $0AAB =  2731          math48.z80:898
RIGHT        = $082B =  2091          math48.z80:360
ROU1         = $0DB9 =  3513          math48.z80:1490
ROU2         = $0DBF =  3519          math48.z80:1494
ROU3         = $0DC7 =  3527          math48.z80:1501
ROU4         = $0DCE =  3534          math48.z80:1506
ROU5         = $0DDD =  3549          math48.z80:1517
ROU6         = $0DE6 =  3558          math48.z80:1524
ROUND        = $0DAC =  3500          math48.z80:1481 (unused)
SAC1         = $085F =  2143          math48.z80:411 (unused)
SC1          = $0D23 =  3363          math48.z80:1387
SC2          = $0D3D =  3389          math48.z80:1409
SC3          = $0D50 =  3408          math48.z80:1418
SC4          = $0D59 =  3417          math48.z80:1423
SIGN         = $0080 =   128          math48.z80:38
SIN          = $095D =  2397          math48.z80:677
SIN1A        = $0976 =  2422          math48.z80:695 (unused)
SIN2         = $097D =  2429          math48.z80:699
SIN3         = $0989 =  2441          math48.z80:707
SIN4         = $0996 =  2454          math48.z80:716
SIN7         = $09E1 =  2529          math48.z80:762
SIN7A        = $09D6 =  2518          math48.z80:754
SINC         = $0961 =  2401          math48.z80:681
SINK         = $09E5 =  2533          math48.z80:767
SLEFT        = $0836 =  2102          math48.z80:369
SQR          = $08FD =  2301          math48.z80:580
SQR1         = $0918 =  2328          math48.z80:603
SQR2         = $0938 =  2360          math48.z80:629
SRIGHT       = $082A =  2090          math48.z80:359
STOA         = $0ED1 =  3793          math48.z80:1673
STODIG       = $0EC5 =  3781          math48.z80:1667
STOZ         = $0ECF =  3791          math48.z80:1672
SUB1         = $0730 =  1840          math48.z80:149
SUBAC        = $085C =  2140          math48.z80:408
TAN          = $093B =  2363          math48.z80:636
TENF         = $0EDF =  3807          math48.z80:1687
TF1          = $0EE6 =  3814          math48.z80:1691
TF2          = $0EF2 =  3826          math48.z80:1697
TF3          = $0F07 =  3847          math48.z80:1708
TF4          = $0F11 =  3857          math48.z80:1714
WORD         = $13A6 =  5030          pl0.z80:1904 (unused)
ZERO         = $0822 =  2082          math48.z80:348
__abs16      = $029E =   670          pl0.z80:295 (unused)
__assert     = $143E =  5182          pl0.z80:2038 (unused)
__assert1    = $144A =  5194          pl0.z80:2046
__assert_msg_1 = $146B =  5227          pl0.z80:2061
__assert_msg_2 = $1484 =  5252          pl0.z80:2062
__assertfailed = $148E =  5262          pl0.z80:2065
__assertpassed = $148C =  5260          pl0.z80:2064
__atoe       = $14EF =  5359          pl0.z80:2150
__atoe1      = $14F2 =  5362          pl0.z80:2152
__atoe2      = $150C =  5388          pl0.z80:2172
__atof       = $10D7 =  4311          pl0.z80:1239
__atoi       = $14BB =  5307          pl0.z80:2114
__atoi_done  = $14E1 =  5345          pl0.z80:2138
__atoi_loop  = $14CB =  5323          pl0.z80:2124
__atoi_skip  = $14DD =  5341          pl0.z80:2135
__begcmp     = $02F1 =   753          pl0.z80:389
__blanks     = $1396 =  5014          pl0.z80:1894
__blanks1    = $1399 =  5017          pl0.z80:1895
__boolean0   = $01AA =   426          pl0.z80:35
__boolean1   = $01A5 =   421          pl0.z80:34
__boolean_enum = $01B0 =   432          pl0.z80:36 (unused)
__buffer     = $0103 =   259          pl0.z80:19
__char2str   = $0609 =  1545          pl0.z80:1055
__checkbreak = $156A =  5482          pl0.z80:2277 (unused)
__chkde      = $0229 =   553          pl0.z80:185
__chklen     = $0401 =  1025          pl0.z80:604 (unused)
__clrscr     = $154A =  5450          pl0.z80:2241 (unused)
__clrscr_str = $1551 =  5457          pl0.z80:2244
__cmplen     = $02FD =   765          pl0.z80:401
__cmplp      = $02F6 =   758          pl0.z80:394
__cmplp2     = $038F =   911          pl0.z80:502
__cnt1ok     = $03D5 =   981          pl0.z80:563
__cnt2ok     = $03E1 =   993          pl0.z80:570
__cntok      = $0476 =  1142          pl0.z80:703
__conout     = $125D =  4701          pl0.z80:1596
__copy       = $04EE =  1262          pl0.z80:830
__count      = $0280 =   640          pl0.z80:250 (unused)
__cpyerr     = $03F5 =  1013          pl0.z80:589
__cur_off_str = $1567 =  5479          pl0.z80:2269
__cur_on_str = $155D =  5469          pl0.z80:2258
__cursor_off = $1560 =  5472          pl0.z80:2266 (unused)
__cursor_on  = $1556 =  5462          pl0.z80:2255 (unused)
__dec16      = $0652 =  1618          pl0.z80:1110
__dec16by    = $065A =  1626          pl0.z80:1118
__delerr     = $048B =  1163          pl0.z80:723
__delete     = $0515 =  1301          pl0.z80:862
__div10      = $028A =   650          pl0.z80:276
__div10a     = $0294 =   660          pl0.z80:285
__div10b     = $029B =   667          pl0.z80:291
__divide     = $025C =   604          pl0.z80:223
__docat      = $0342 =   834          pl0.z80:449
__dodiv      = $0234 =   564          pl0.z80:194
__done       = $165B =  5723          pl0.z80:2655
__dorem      = $0245 =   581          pl0.z80:205
__drop       = $0272 =   626          pl0.z80:237
__dvloop     = $0264 =   612          pl0.z80:228
__erexit     = $03F2 =  1010          pl0.z80:584
__exit       = $034E =   846          pl0.z80:457
__fillchar   = $1582 =  5506          pl0.z80:2298 (unused)
__flteq      = $107F =  4223          pl0.z80:1179 (unused)
__flteq0     = $1084 =  4228          pl0.z80:1182 (unused)
__flteq1     = $1088 =  4232          pl0.z80:1185
__fltleq     = $10A6 =  4262          pl0.z80:1209 (unused)
__fltleq0    = $10AD =  4269          pl0.z80:1213 (unused)
__fltleq1    = $10B1 =  4273          pl0.z80:1216
__fltlt      = $1099 =  4249          pl0.z80:1199 (unused)
__fltlt0     = $109E =  4254          pl0.z80:1202 (unused)
__fltlt1     = $10A2 =  4258          pl0.z80:1205
__fltneq     = $108C =  4236          pl0.z80:1189 (unused)
__fltneq0    = $1091 =  4241          pl0.z80:1192 (unused)
__fltneq1    = $1095 =  4245          pl0.z80:1195
__fltpwr2    = $10B5 =  4277          pl0.z80:1220 (unused)
__fltrnd     = $10BC =  4284          pl0.z80:1225 (unused)
__fltrnd_neg = $10D1 =  4305          pl0.z80:1235
__found      = $039E =   926          pl0.z80:514
__freemem    = $1635 =  5685          pl0.z80:2586
__ftoa       = $10E7 =  4327          pl0.z80:1248
__ftoaerr    = $1133 =  4403          pl0.z80:1272
__ftoalp     = $10FE =  4350          pl0.z80:1259
__ftoaok     = $10F8 =  4344          pl0.z80:1256
__ftoatmp    = $1112 =  4370          pl0.z80:1270
__get_heap_bytes = $164B =  5707          pl0.z80:2606 (unused)
__get_heap_start = $1647 =  5703          pl0.z80:2602 (unused)
__getc       = $1407 =  5127          pl0.z80:1961 (unused)
__gete       = $13F0 =  5104          pl0.z80:1945 (unused)
__getline    = $1369 =  4969          pl0.z80:1871 (unused)
__getmem     = $15AC =  5548          pl0.z80:2499
__getn       = $13C3 =  5059          pl0.z80:1922 (unused)
__getr       = $13D8 =  5080          pl0.z80:1932 (unused)
__gets       = $1416 =  5142          pl0.z80:1972 (unused)
__gotoxy     = $1532 =  5426          pl0.z80:2215
__gotoxy_str = $1545 =  5445          pl0.z80:2224
__heapptr    = $15AA =  5546          pl0.z80:2494
__idx0       = $03FD =  1021          pl0.z80:599 (unused)
__idxl1      = $0425 =  1061          pl0.z80:635
__idxlen     = $0415 =  1045          pl0.z80:620
__inc16      = $0643 =  1603          pl0.z80:1093
__inc16by    = $0648 =  1608          pl0.z80:1099 (unused)
__index      = $03AA =   938          pl0.z80:528
__init       = $1655 =  5717          pl0.z80:2621
__inserr     = $0450 =  1104          pl0.z80:670
__insert     = $0501 =  1281          pl0.z80:845 (unused)
__int16_case = $01D8 =   472          pl0.z80:100 (unused)
__int16_eq   = $01B4 =   436          pl0.z80:44
__int16_geq  = $01CC =   460          pl0.z80:87
__int16_geq_of = $01D5 =   469          pl0.z80:94
__int16_lt   = $01C0 =   448          pl0.z80:70
__int16_lt_of = $01C9 =   457          pl0.z80:77
__int16_neq  = $01BA =   442          pl0.z80:57
__int_shl    = $01EA =   490          pl0.z80:118 (unused)
__int_shl1   = $01EE =   494          pl0.z80:122
__int_shr    = $01F5 =   501          pl0.z80:132 (unused)
__int_shr1   = $01F9 =   505          pl0.z80:136
__itoa       = $1490 =  5264          pl0.z80:2074
__itoa_loop1 = $14A5 =  5285          pl0.z80:2087
__itoa_loop2 = $14B3 =  5299          pl0.z80:2097
__length     = $05B8 =  1464          pl0.z80:982
__lenok      = $033B =   827          pl0.z80:445
__lenok2     = $042C =  1068          pl0.z80:639
__lens1      = $0305 =   773          pl0.z80:406
__lens2      = $0306 =   774          pl0.z80:408
__linebuf    = $0125 =   293          pl0.z80:30
__linelen    = $0124 =   292          pl0.z80:29
__linemax    = $0123 =   291          pl0.z80:28
__lineptr    = $1394 =  5012          pl0.z80:1892
__load16     = $0615 =  1557          pl0.z80:1065
__load16ret  = $0628 =  1576          pl0.z80:1077
__loadfp     = $104A =  4170          pl0.z80:1151 (unused)
__loadstr    = $05C5 =  1477          pl0.z80:994
__malloc     = $15BD =  5565          pl0.z80:2514
__malloc_check_larger = $15E1 =  5601          pl0.z80:2538
__malloc_error_message = $1627 =  5671          pl0.z80:2582
__malloc_infinite_loop = $1624 =  5668          pl0.z80:2580
__malloc_loop = $15C4 =  5572          pl0.z80:2518
__malloc_next = $160B =  5643          pl0.z80:2568
__malloc_out_of_memory = $161E =  5662          pl0.z80:2577
__maxlen     = $03F4 =  1012          pl0.z80:587
__mkstr      = $05F9 =  1529          pl0.z80:1041
__move       = $1592 =  5522          pl0.z80:2323
__movedn     = $159F =  5535          pl0.z80:2336
__movestr    = $05E8 =  1512          pl0.z80:1025
__movestr_1  = $05EE =  1518          pl0.z80:1030
__moveup     = $159C =  5532          pl0.z80:2333 (unused)
__mul10      = $0281 =   641          pl0.z80:259
__mul16      = $0200 =   512          pl0.z80:149
__mul16a     = $0207 =   519          pl0.z80:153
__mul16b     = $020E =   526          pl0.z80:157
__mvesub     = $0445 =  1093          pl0.z80:662
__neg16      = $02A1 =   673          pl0.z80:300 (unused)
__newline    = $1274 =  4724          pl0.z80:1625
__notfnd     = $03A2 =   930          pl0.z80:517
__okexit     = $03F0 =  1008          pl0.z80:581 (unused)
__okexit2    = $0489 =  1161          pl0.z80:720 (unused)
__poke       = $15A8 =  5544          pl0.z80:2353 (unused)
__pos        = $04DB =  1243          pl0.z80:815
__putc       = $125D =  4701          pl0.z80:1582
__putc_fmt   = $132F =  4911          pl0.z80:1820 (unused)
__pute       = $1325 =  4901          pl0.z80:1810 (unused)
__pute_fmt   = $135F =  4959          pl0.z80:1854 (unused)
__putf       = $1139 =  4409          pl0.z80:1275 (unused)
__putf_exp   = $1145 =  4421          pl0.z80:1283 (unused)
__putf_exp_0 = $1150 =  4432          pl0.z80:1291
__putf_exp_1 = $1159 =  4441          pl0.z80:1297
__putf_fix   = $1165 =  4453          pl0.z80:1306 (unused)
__putf_fix_1 = $1168 =  4456          pl0.z80:1313 (unused)
__putn       = $1316 =  4886          pl0.z80:1795
__putn_fmt   = $134F =  4943          pl0.z80:1845
__puts       = $1264 =  4708          pl0.z80:1605
__puts_fmt   = $133A =  4922          pl0.z80:1828
__puts_fmt_1 = $134B =  4939          pl0.z80:1841
__puts_fmt_loop = $1342 =  4930          pl0.z80:1835
__putschk    = $1270 =  4720          pl0.z80:1614
__putsloop   = $1268 =  4712          pl0.z80:1608
__ralign     = $12F2 =  4850          pl0.z80:1745
__ralign1    = $12F8 =  4856          pl0.z80:1751
__ralign2    = $1311 =  4881          pl0.z80:1777
__rand16     = $02C7 =   711          pl0.z80:337
__random     = $02A8 =   680          pl0.z80:314 (unused)
__random48   = $02B2 =   690          pl0.z80:322 (unused)
__recalc     = $03CC =   972          pl0.z80:556
__rmstr      = $0601 =  1537          pl0.z80:1048
__s1adr      = $035A =   858          pl0.z80:464
__s1len      = $035C =   860          pl0.z80:466
__s2len      = $035D =   861          pl0.z80:468
__sdiv16     = $0216 =   534          pl0.z80:172
__setadd     = $11DC =  4572          pl0.z80:1426 (unused)
__setadd1    = $11E7 =  4583          pl0.z80:1433
__seteq      = $1217 =  4631          pl0.z80:1496 (unused)
__seteq1     = $1222 =  4642          pl0.z80:1503
__seteq2     = $122E =  4654          pl0.z80:1512
__setexclude = $11D2 =  4562          pl0.z80:1410 (unused)
__setgeq     = $124F =  4687          pl0.z80:1552 (unused)
__setin_new  = $1176 =  4470          pl0.z80:1334 (unused)
__setinclude = $11CA =  4554          pl0.z80:1402 (unused)
__setleq     = $1232 =  4658          pl0.z80:1523 (unused)
__setleq1    = $123D =  4669          pl0.z80:1530
__setleq2    = $124B =  4683          pl0.z80:1541
__setmember  = $11B4 =  4532          pl0.z80:1388 (unused)
__setmul     = $1204 =  4612          pl0.z80:1473 (unused)
__setmul1    = $120F =  4623          pl0.z80:1480
__setoff     = $118D =  4493          pl0.z80:1353
__setoff1    = $119D =  4509          pl0.z80:1365
__setoff2    = $11A5 =  4517          pl0.z80:1370
__setoff3    = $11B1 =  4529          pl0.z80:1377
__setsub     = $11EF =  4591          pl0.z80:1449 (unused)
__setsub1    = $11FA =  4602          pl0.z80:1456
__slen       = $03A8 =   936          pl0.z80:524 (unused)
__slp1       = $037C =   892          pl0.z80:493
__slp2       = $039A =   922          pl0.z80:511
__squot      = $027E =   638          pl0.z80:248
__srem       = $027F =   639          pl0.z80:249
__store16    = $062A =  1578          pl0.z80:1079
__store16ret = $0641 =  1601          pl0.z80:1091
__storefp    = $1064 =  4196          pl0.z80:1165
__storestr   = $05D4 =  1492          pl0.z80:1009
__str_fix_1  = $12C8 =  4808          pl0.z80:1702 (unused)
__str_int    = $0527 =  1319          pl0.z80:878 (unused)
__stradd     = $04CE =  1230          pl0.z80:806
__strc       = $129E =  4766          pl0.z80:1663 (unused)
__strcat     = $0307 =   775          pl0.z80:413
__strcmp     = $02E5 =   741          pl0.z80:381
__strcpy     = $03AB =   939          pl0.z80:533
__strdel     = $0451 =  1105          pl0.z80:674
__stre       = $12E8 =  4840          pl0.z80:1725 (unused)
__streq      = $048C =  1164          pl0.z80:732 (unused)
__streq0     = $049C =  1180          pl0.z80:743
__streq1     = $04A0 =  1184          pl0.z80:748
__streqnosp  = $0493 =  1171          pl0.z80:737
__strf       = $12B5 =  4789          pl0.z80:1683 (unused)
__strf2      = $12C5 =  4805          pl0.z80:1695 (unused)
__strgov     = $035E =   862          pl0.z80:470
__string     = $03A4 =   932          pl0.z80:520
__strins     = $03F6 =  1014          pl0.z80:593
__strleq     = $04B8 =  1208          pl0.z80:786 (unused)
__strleq0    = $04C6 =  1222          pl0.z80:794 (unused)
__strleq1    = $04CA =  1226          pl0.z80:799
__strlt      = $04A4 =  1188          pl0.z80:761 (unused)
__strlt0     = $04B0 =  1200          pl0.z80:768 (unused)
__strlt1     = $04B4 =  1204          pl0.z80:773
__strn       = $127F =  4735          pl0.z80:1641
__strn_fmt   = $1292 =  4754          pl0.z80:1653 (unused)
__strpos     = $035F =   863          pl0.z80:474
__strs       = $12A6 =  4774          pl0.z80:1672 (unused)
__sublen     = $03A9 =   937          pl0.z80:526
__substg     = $03A6 =   934          pl0.z80:522
__textbg     = $1521 =  5409          pl0.z80:2196 (unused)
__textbg_str = $152E =  5422          pl0.z80:2202
__textfg     = $1510 =  5392          pl0.z80:2177 (unused)
__textfg_str = $151D =  5405          pl0.z80:2183
__toolng     = $0326 =   806          pl0.z80:433
__trunc      = $040B =  1035          pl0.z80:612
__trunc2     = $046E =  1134          pl0.z80:696
__udiv16     = $0251 =   593          pl0.z80:215
__val_enum   = $0574 =  1396          pl0.z80:930 (unused)
__val_enum1  = $058E =  1422          pl0.z80:946
__val_enum2  = $05A4 =  1444          pl0.z80:962 (unused)
__val_float  = $055E =  1374          pl0.z80:911 (unused)
__val_int    = $053F =  1343          pl0.z80:893
__word       = $13A6 =  5030          pl0.z80:1905
__word1      = $13B0 =  5040          pl0.z80:1909
__word2      = $13BB =  5051          pl0.z80:1917
_end         = $3A91 = 14993          pl0.z80:3 (unused)
_size        = $3991 = 14737          pl0.z80:3 (unused)
bigadd       = $27D5 = 10197          bigint.asm:10
bigdiv       = $2865 = 10341          bigint.asm:136
bigmul       = $27F2 = 10226          bigint.asm:51
bigsub       = $27E3 = 10211          bigint.asm:30 (unused)
break181     = $2BD5 = 11221          day19.z80:3281 (unused)
const151     = $2924 = 10532          day19.z80:2887
const152     = $292C = 10540          day19.z80:2890 (unused)
const153     = $2934 = 10548          day19.z80:2893
const154     = $293C = 10556          day19.z80:2896
display      = $3A71 = 14961          day19.z80:4590
endif242     = $3645 = 13893          day19.z80:4306
endif63      = $1AAD =  6829          day19.z80:914
endif67      = $1B5D =  7005          day19.z80:1012
endif80      = $1C34 =  7220          day19.z80:1186
eof          = $3A91 = 14993          day19.z80:4591
exit100      = $1F7A =  8058          day19.z80:1669 (unused)
exit103      = $2091 =  8337          day19.z80:1825 (unused)
exit106      = $2223 =  8739          day19.z80:2049
exit112      = $22A5 =  8869          day19.z80:2123 (unused)
exit115      = $235A =  9050          day19.z80:2224 (unused)
exit12       = $17D2 =  6098          day19.z80:270 (unused)
exit120      = $2435 =  9269          day19.z80:2347 (unused)
exit128      = $24B7 =  9399          day19.z80:2421 (unused)
exit130      = $254D =  9549          day19.z80:2502 (unused)
exit134      = $25F9 =  9721          day19.z80:2602 (unused)
exit139      = $2678 =  9848          day19.z80:2671 (unused)
exit143      = $26FA =  9978          day19.z80:2751 (unused)
exit147      = $2740 = 10048          day19.z80:2794 (unused)
exit150      = $27CC = 10188          day19.z80:2873 (unused)
exit162      = $29FC = 10748          day19.z80:3017
exit17       = $181C =  6172          day19.z80:311 (unused)
exit172      = $2B24 = 11044          day19.z80:3188
exit179      = $2BD5 = 11221          day19.z80:3283 (unused)
exit188      = $3043 = 12355          day19.z80:3369 (unused)
exit194      = $30B9 = 12473          day19.z80:3441 (unused)
exit201      = $314D = 12621          day19.z80:3535 (unused)
exit210      = $3370 = 13168          day19.z80:3884 (unused)
exit226      = $351E = 13598          day19.z80:4145
exit238      = $37BC = 14268          day19.z80:4516 (unused)
exit253      = $3A18 = 14872          day19.z80:4577 (unused)
exit52       = $198E =  6542          day19.z80:736 (unused)
exit58       = $1B5D =  7005          day19.z80:1014 (unused)
exit78       = $1E50 =  7760          day19.z80:1502 (unused)
exit8        = $1709 =  5897          day19.z80:154 (unused)
exit97       = $1E8D =  7821          day19.z80:1536 (unused)
false10      = $16F1 =  5873          day19.z80:140
false108     = $2222 =  8738          day19.z80:2043
false109     = $2210 =  8720          day19.z80:2033
false116     = $22EB =  8939          day19.z80:2163
false117     = $2349 =  9033          day19.z80:2212
false122     = $2435 =  9269          day19.z80:2345
false123     = $23DE =  9182          day19.z80:2301
false124     = $23F2 =  9202          day19.z80:2312
false125     = $2432 =  9266          day19.z80:2342
false131     = $24FB =  9467          day19.z80:2458
false14      = $17BA =  6074          day19.z80:256
false140     = $263D =  9789          day19.z80:2638
false144     = $26D0 =  9936          day19.z80:2725
false15      = $179D =  6045          day19.z80:238
false166     = $29D5 = 10709          day19.z80:2992
false173     = $2A89 = 10889          day19.z80:3095
false218     = $3338 = 13112          day19.z80:3850
false219     = $331F = 13087          day19.z80:3833
false220     = $331F = 13087          day19.z80:3832
false227     = $33D7 = 13271          day19.z80:3948
false228     = $34F4 = 13556          day19.z80:4121
false230     = $34DF = 13535          day19.z80:4107
false231     = $34C6 = 13510          day19.z80:4090
false232     = $34C6 = 13510          day19.z80:4089
false240     = $3660 = 13920          day19.z80:4325
false241     = $360D = 13837          day19.z80:4275
false243     = $3645 = 13893          day19.z80:4305
false245     = $37BC = 14268          day19.z80:4514
false249     = $371C = 14108          day19.z80:4431
false56      = $193F =  6463          day19.z80:688
false62      = $1A59 =  6745          day19.z80:859
false64      = $1AAD =  6829          day19.z80:913
false65      = $1AA4 =  6820          day19.z80:905
false66      = $1B4B =  6987          day19.z80:1002
false79      = $1C24 =  7204          day19.z80:1178
false81      = $1C71 =  7281          day19.z80:1219
false82      = $1C9C =  7324          day19.z80:1243
false89      = $1D86 =  7558          day19.z80:1377
forbreak136  = $25CE =  9678          day19.z80:2575
forbreak164  = $29ED = 10733          day19.z80:3008
forbreak175  = $2B23 = 11043          day19.z80:3186
forbreak190  = $3042 = 12354          day19.z80:3367
forbreak196  = $30B8 = 12472          day19.z80:3439
forbreak212  = $31D3 = 12755          day19.z80:3632
forbreak215  = $3350 = 13136          day19.z80:3865
forbreak54   = $1977 =  6519          day19.z80:721
forbreak60   = $1AE5 =  6885          day19.z80:948
forbreak84   = $1D02 =  7426          day19.z80:1302
forbreak87   = $1D56 =  7510          day19.z80:1349
forbreak91   = $1DF7 =  7671          day19.z80:1443
forbreak94   = $1E4E =  7758          day19.z80:1491
forloop135   = $2593 =  9619          day19.z80:2542
forloop163   = $2974 = 10612          day19.z80:2935
forloop174   = $2AC0 = 10944          day19.z80:3127
forloop189   = $300E = 12302          day19.z80:3335
forloop195   = $3079 = 12409          day19.z80:3401
forloop211   = $31A2 = 12706          day19.z80:3605
forloop214   = $321E = 12830          day19.z80:3676
forloop53    = $18E7 =  6375          day19.z80:635
forloop59    = $19F1 =  6641          day19.z80:795
forloop83    = $1CB7 =  7351          day19.z80:1259
forloop86    = $1D21 =  7457          day19.z80:1320
forloop90    = $1DA1 =  7585          day19.z80:1393
forloop93    = $1E16 =  7702          day19.z80:1461
fornext137   = $25B7 =  9655          day19.z80:2563 (unused)
fornext165   = $29D5 = 10709          day19.z80:2994 (unused)
fornext176   = $2B0A = 11018          day19.z80:3171 (unused)
fornext191   = $3029 = 12329          day19.z80:3352 (unused)
fornext197   = $30A1 = 12449          day19.z80:3427 (unused)
fornext213   = $31BC = 12732          day19.z80:3620 (unused)
fornext216   = $3338 = 13112          day19.z80:3852 (unused)
fornext55    = $1954 =  6484          day19.z80:702 (unused)
fornext61    = $1AC2 =  6850          day19.z80:929 (unused)
fornext85    = $1CEB =  7403          day19.z80:1290 (unused)
fornext88    = $1D3F =  7487          day19.z80:1337 (unused)
fornext92    = $1DE0 =  7648          day19.z80:1431 (unused)
fornext95    = $1E37 =  7735          day19.z80:1479 (unused)
func11       = $1712 =  5906          day19.z80:166 (unused)
func113      = $22AF =  8879          day19.z80:2135
func138      = $2602 =  9730          day19.z80:2611
func159      = $2947 = 10567          day19.z80:2912
func202      = $3156 = 12630          day19.z80:3542
func203      = $3173 = 12659          day19.z80:3583
func41       = $1851 =  6225          day19.z80:435 (unused)
func42       = $185C =  6236          day19.z80:452 (unused)
func45       = $1867 =  6247          day19.z80:487 (unused)
func46       = $1869 =  6249          day19.z80:504 (unused)
func47       = $186E =  6254          day19.z80:516 (unused)
func48       = $1872 =  6258          day19.z80:526 (unused)
func49       = $1877 =  6263          day19.z80:540
func50       = $1882 =  6274          day19.z80:560 (unused)
func51       = $188D =  6285          day19.z80:588 (unused)
func57       = $1997 =  6551          day19.z80:748 (unused)
func7        = $165F =  5727          day19.z80:62 (unused)
global102    = $1F83 =  8067          day19.z80:1678
global105    = $209A =  8346          day19.z80:1834
global111    = $222C =  8748          day19.z80:2058
global114    = $22AE =  8878          day19.z80:2132
global119    = $2363 =  9059          day19.z80:2233
global127    = $243E =  9278          day19.z80:2356
global133    = $2556 =  9558          day19.z80:2511
global142    = $2681 =  9857          day19.z80:2680
global146    = $2703 =  9987          day19.z80:2760
global149    = $2749 = 10057          day19.z80:2804
global160    = $2944 = 10564          day19.z80:2907
global161    = $2946 = 10566          day19.z80:2909
global168    = $2A05 = 10757          day19.z80:3026
global169    = $2A06 = 10758          day19.z80:3028
global170    = $2A0E = 10766          day19.z80:3030
global171    = $2A10 = 10768          day19.z80:3031
global178    = $2B2D = 11053          day19.z80:3197
global182    = $2BDE = 11230          day19.z80:3298
global183    = $2C12 = 11282          day19.z80:3301
global184    = $2E92 = 11922          day19.z80:3303
global185    = $2EE2 = 12002          day19.z80:3306
global187    = $2FE2 = 12258          day19.z80:3311
global193    = $304C = 12364          day19.z80:3378
global199    = $30C2 = 12482          day19.z80:3450
global200    = $30C3 = 12483          day19.z80:3452
global204    = $3168 = 12648          day19.z80:3573
global205    = $316A = 12650          day19.z80:3574
global206    = $316C = 12652          day19.z80:3575
global207    = $316E = 12654          day19.z80:3576
global208    = $3170 = 12656          day19.z80:3578
global209    = $3171 = 12657          day19.z80:3580
global222    = $3379 = 13177          day19.z80:3893 (unused)
global223    = $337B = 13179          day19.z80:3894
global224    = $337D = 13181          day19.z80:3895
global225    = $337F = 13183          day19.z80:3897
global234    = $3527 = 13607          day19.z80:4156
global235    = $3528 = 13608          day19.z80:4158
global236    = $352A = 13610          day19.z80:4160
global237    = $3532 = 13618          day19.z80:4161
global251    = $37C5 = 14277          day19.z80:4524 (unused)
global252    = $38C5 = 14533          day19.z80:4525 (unused)
global74     = $1B66 =  7014          day19.z80:1068
global75     = $1B68 =  7016          day19.z80:1069
global76     = $1B6A =  7018          day19.z80:1070
global77     = $1B6C =  7020          day19.z80:1071
global99     = $1E96 =  7830          day19.z80:1545
main         = $39C5 = 14789          day19.z80:4529
proc101      = $1F85 =  8069          day19.z80:1681 (unused)
proc104      = $209C =  8348          day19.z80:1837 (unused)
proc110      = $222E =  8750          day19.z80:2061
proc118      = $2364 =  9060          day19.z80:2236
proc126      = $2440 =  9280          day19.z80:2359
proc129      = $24C0 =  9408          day19.z80:2431
proc132      = $2558 =  9560          day19.z80:2514 (unused)
proc141      = $2683 =  9859          day19.z80:2683 (unused)
proc145      = $2705 =  9989          day19.z80:2763 (unused)
proc148      = $274B = 10059          day19.z80:2807 (unused)
proc16       = $17DB =  6107          day19.z80:281
proc167      = $2A12 = 10770          day19.z80:3034 (unused)
proc177      = $2B35 = 11061          day19.z80:3200
proc186      = $2FE3 = 12259          day19.z80:3314
proc192      = $304E = 12366          day19.z80:3381 (unused)
proc198      = $30C5 = 12485          day19.z80:3455
proc221      = $3381 = 13185          day19.z80:3900
proc23       = $1825 =  6181          day19.z80:333 (unused)
proc233      = $353A = 13626          day19.z80:4164
proc24       = $1830 =  6192          day19.z80:351 (unused)
proc25       = $183B =  6203          day19.z80:369 (unused)
proc26       = $1846 =  6214          day19.z80:387 (unused)
proc73       = $1B6E =  7022          day19.z80:1074
proc96       = $1E59 =  7769          day19.z80:1511
proc98       = $1E98 =  7832          day19.z80:1548
repeat180    = $2B5E = 11102          day19.z80:3222
seed1        = $02E1 =   737          pl0.z80:369
seed2        = $02E3 =   739          pl0.z80:370
string246    = $3A1D = 14877          day19.z80:4580
string247    = $3A20 = 14880          day19.z80:4581
string248    = $3A23 = 14883          day19.z80:4582
string250    = $3A26 = 14886          day19.z80:4583
string254    = $3A2B = 14891          day19.z80:4584
string255    = $3A30 = 14896          day19.z80:4585
string256    = $3A51 = 14929          day19.z80:4586
string257    = $3A59 = 14937          day19.z80:4587
string258    = $3A61 = 14945          day19.z80:4588
string259    = $3A6E = 14958          day19.z80:4589
string68     = $3A1C = 14876          day19.z80:4579
while107     = $21BF =  8639          day19.z80:1993
while121     = $238A =  9098          day19.z80:2255
while13      = $1742 =  5954          day19.z80:190
while217     = $3256 = 12886          day19.z80:3713
while229     = $3423 = 13347          day19.z80:3995
while239     = $35B8 = 13752          day19.z80:4233
while244     = $3688 = 13960          day19.z80:4350
while9       = $168F =  5775          day19.z80:86

; +++ local symbols +++

bigadd1 = $27D9 = 10201          bigint.asm:15

; +++ local symbols +++

bigsub1 = $27E8 = 10216          bigint.asm:36

; +++ local symbols +++

addlp   = $2833 = 10291          bigint.asm:101
count   = $2857 = 10327          bigint.asm:127
deccnt  = $283B = 10299          bigint.asm:110
endhp   = $2859 = 10329          bigint.asm:128
exit    = $2855 = 10325          bigint.asm:123
hiprod  = $285D = 10333          bigint.asm:130
loop    = $2815 = 10261          bigint.asm:78
mlier   = $285B = 10331          bigint.asm:129
srailp  = $2821 = 10273          bigint.asm:89
srplp   = $2819 = 10265          bigint.asm:81
zerolp  = $280F = 10255          bigint.asm:72
zeropd  = $280B = 10251          bigint.asm:69 (unused)

; +++ local symbols +++

chkolp  = $2898 = 10392          bigint.asm:171
cont    = $28BC = 10428          bigint.asm:198
count   = $2911 = 10513          bigint.asm:254
deccnt  = $28A9 = 10409          bigint.asm:188 (unused)
dvend   = $2909 = 10505          bigint.asm:250
dvsor   = $290B = 10507          bigint.asm:251
erexit  = $28FA = 10490          bigint.asm:235
exit    = $28FF = 10495          bigint.asm:242
hdeptr  = $290D = 10509          bigint.asm:252
hide1   = $2914 = 10516          bigint.asm:256
hide2   = $291C = 10524          bigint.asm:257
loop    = $28A0 = 10400          bigint.asm:180
odeptr  = $290F = 10511          bigint.asm:253
okexit  = $28FE = 10494          bigint.asm:239
sllp1   = $28A4 = 10404          bigint.asm:183
sllp2   = $28C0 = 10432          bigint.asm:201
subcnt  = $2913 = 10515          bigint.asm:255
sublp   = $28D6 = 10454          bigint.asm:213
zerolp  = $2881 = 10369          bigint.asm:155


total time: 0.0382 sec.
no errors
