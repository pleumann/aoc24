package day17;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.List;

/**
 * Day 17 "Chronospatial Computer".
 */
public class Puzzle {

    /**
     * Opcode menmonics.
     */
    static final String[] OPS = {"adv", "bxl", "bst", "jnz", "bxc", "out", "bdv", "cdv"};
    
    /**
     * The three reigsters.
     */
    long regA;
    long regB;
    long regC;
    
    /**
     * The "memory" holding the program.
     */
    int[] code;
    
    /**
     * The program counter.
     */
    int pc;

    /**
     * The next element to compare against (for part 2).
     */
    int next;

    /**
     * The output generated by the running program.
     */
    StringBuilder output = new StringBuilder();

    /**
     * Helper for combo operands that "does the right thing".
     */
    long combo(int literal) {
        switch (literal) {
            case 4  -> { return regA;    }
            case 5  -> { return regB;    }
            case 6  -> { return regC;    }
            default -> { return literal; }
        }
    }
    
    /**
     * Executes a single opcode and updates PC, registers and output
     * accordingly. For part 2, checks whether a digit output by the "out"
     * instruction matches the next expected digit and return false if not. In
     * all other cases true is returned to signal that the execution should
     * continue.
     */
    boolean execute(int part) {
        int opcode = code[pc++];

        int literal = 0;
        if (pc < code.length) {
            literal = code[pc++];
        }

        if (part == 1) {
            System.out.printf("pc=%2d  a=%8d  b=%8d  c=%8d  --> %s %d\n", 
                    pc, regA, regB, regC, OPS[opcode], literal);
        }
        
        switch (opcode) {
            case 0 /* adv */ -> {
                regA = regA / (1 << combo(literal));
            }
            case 1 /* bxl */ -> {
                regB = regB ^ literal;
            }
            case 2 /* bst */ -> {
                regB = combo(literal) % 8;
            }
            case 3 /* jnz */ -> {
                if (regA != 0) {
                    pc = literal;
                }
            }
            case 4 /* bxc */ -> {
                regB = regB ^ regC;
            }
            case 5 /* out */ -> {
                if (output.length() != 0) {
                    output.append(',');
                }
                int i = (int)(combo(literal) % 8);
                output.append(i);
                if (part == 2) {
                    if (code[next] != i) {
                        return false;
                    }
                }
                next++;
            }
            case 6 /* bdv */ -> {
                regB = regA / (1 << combo(literal));
            }
            case 7 /* cdv */ -> {
                regC = regA / (1 << combo(literal));
            }
        }
        
        return true;
    }
    
    /**
     * Runs the program for a given starting value and until a certain number of
     * digits has been output.
     */
    boolean run(long a, int end, int part) throws IOException {
        regA = a;
        regB = 0;
        regC = 0;
        
        pc = 0;
        
        next = 0;
        
        output.setLength(0);
        
        while (pc < code.length && next < end) {
            if (!execute(part)) {
                return false;
            }
        }
        
        return next == end;
    }
    
    /**
     * Solves the whole puzzle.
     */
    void load(String path) throws IOException {
        List<String> lines = Files.readAllLines(Path.of(path));
        
        for (String s: lines) {
            System.out.println(s);
        }
        
        regA = Integer.parseInt(lines.get(0).substring(12));
        regB = Integer.parseInt(lines.get(1).substring(12));
        regC = Integer.parseInt(lines.get(2).substring(12));
        
        String prog = lines.get(4).substring(9);
        String[] arr = lines.get(4).split(" |,");
        
        code = new int[arr.length - 1];
        for (int i = 0; i < code.length; i++) {
            code[i] = Integer.parseInt(arr[i + 1]);
        }
        
        System.out.println();
        System.out.println("Number of instructions is " + code.length + ".");
        System.out.println();
        
        /*
         * Part 1 is easy: Just run the program once and collect its output.
         */
        run(regA, 16, 1);
        String part1 = output.toString();

        /*
         * Part 2 is a bit more tricky: To avoid combinatorial explosion we
         * cannot simply try all Long numbers starting from 0 and run the
         * program on each. So what we do is a bit similar to "cracking" a
         * combination lock for a bike or a safe. We try the digits one at a
         * time and provide just enough additional bits for A that the next
         * digit can be produced. All successful prefixes become seeds for the
         * next round.
         */
        HashSet<Long> seeds = new HashSet();
        seeds.add(0l);
                
        long part2 = 0;

        System.out.println();
        System.out.println("Part 1: " + part1);
        System.out.println();
        System.out.println("  Digits    Seeds    Required output");
        System.out.println("----------------------------------------------------");
        for (int digits = 0; digits < 16; digits++) {
            System.out.printf("%8d %8d    %s\n", digits, seeds.size(),
                    digits == 15 ? prog : prog.substring(0, 2 * digits + 2));
            HashSet<Long> newSeeds = new HashSet();
            part2 = Long.MAX_VALUE;
            for (long start: seeds) {
                for (long i = 0; i < 4095; i++) {
                    long j = i << (3 * digits) | start;
                    if (run(j, digits + 1, 2)) {
                        long k = (i & 7) << (3 * digits) | start;
                        newSeeds.add(k);
                        part2 = Math.min(part2, j);
                    }
                }
            }
            seeds = newSeeds;
        }
        
        System.out.println();
        System.out.println("Part 2: " + part2);
    }
    
    /**
     * The canonical entry point.
     */
    public static void main(String[] args) throws IOException {
        System.out.println();
        System.out.println("*** AoC 2025.17 Chronospatial Computer ***");
        System.out.println();
        
        new Puzzle().load(args[0]);
    }
    
}
