; program pebbles.pas
CPM:            equ     1               ; Target is CP/M
                device  NOSLOT64K
; [0] (* ===================================================================== *)
; [1] (* === CP/M run-time library =========================================== *)
; [2] (* ===================================================================== *)
; [3] 
; [4] {$a org 0x0100  }
                org     0x0100
; [5] {$a             }
; [6] {$a jp __init   }
                jp      __init
; [7] 
; [8] {$i system.pas  }
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] {$a+}
; [3] 
; [4] {$l system.asm}
                include "/Users/joerg/Projects/pasta80/rtl/system.asm"
; [5] 
; [6] (* -------------------------------------------------------------------------- *)
; [7] (* --- String support ------------------------------------------------------- *)
; [8] (* -------------------------------------------------------------------------- *)
; [9] 
; [10] (* Built-in: procedure Val(S: String; var Scalar; var E: Integer); *)
; [11] (* Built-in: procedure Str(N: Scalar; var S: String);              *)
; [12] 
; [13] procedure Delete(var S: String; Start, Count: Integer);     external '__delete';
; [14] procedure Insert(S: String; var T: String; Start: Integer); external '__insert';
; [15] 
; [16] (* Built-in: function Concat(S: String, ...): String;              *)
; [17] 
; [18] function Copy(S: String; Start, Count: Integer): String;    external '__copy';
; [19] function Length(S: String): Integer;                        external '__length';
; [20] function Pos(S, T: String): Integer;                        external '__pos';
; [21] 
; [22] (* -------------------------------------------------------------------------- *)
; [23] (* --- Set support ---------------------------------------------------------- *)
; [24] (* -------------------------------------------------------------------------- *)
; [25] 
; [26] (* Built-in: procedure Include(var S: Set; E: Element);     *)
; [27] (* Built-in: procedure Exclude(var S: Set; E: Element);     *)
; [28] 
; [29] (* -------------------------------------------------------------------------- *)
; [30] (* --- File support --------------------------------------------------------- *)
; [31] (* -------------------------------------------------------------------------- *)
; [32] 
; [33] (* TBD *)
; [34] 
; [35] (* -------------------------------------------------------------------------- *)
; [36] (* --- Heap management ------------------------------------------------------ *)
; [37] (* -------------------------------------------------------------------------- *)
; [38] 
; [39] type
; [40]   PBlock = ^TBlock;
; [41]   TBlock = record
; [42]     Next: PBlock;
; [43]     Size: Integer;
; [44]   end;
; [45] 
; [46] var
; [47]   HeapPtr: PBlock absolute '__heapptr';
; [48] 
; [49] (* Built-in: procedure New(var P: Pointer);       *)
; [50] (* Built-in: procedure Dispose(P: Pointer);       *)
; [51] 
; [52] procedure FreeMem(P: Pointer; Size: Integer);     register; external '__freemem';
; [53] procedure GetMem(var P: Pointer; Size: Integer);  register; external '__getmem';
; [54] 
; [55] function MemAvail: Integer;
; [56] var
                if      __USE__MemAvail7
; [57]   P: PBlock;
global8:        ds      2,0             ; Global P
; [58]   I: Integer;
global9:        ds      2,0             ; Global I
; [59] begin
; var MemAvail(@RESULT), P(@global8), I(@global9)
__MemAvail7:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [60]   P := HeapPtr;
                push    hl
                ld      hl,global8 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [61]   I := 0;
                ld      hl,global9 + 0
                ld      de,0
                ld      (hl),de
; [62]   while P <> nil do
while11:
                ld      hl,(global8 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [63]   begin
                bit     0,l
                jp      z,false12
; [64]     I := I + P^.Size;
                ld      hl,global9 + 0
                push    hl
                ld      hl,(global9 + 0)
                push    hl
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [65]     P := P^.Next;
                ld      hl,global8 + 0
                push    hl
                ld      hl,global8 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [66]   end;
                jp      while11
false12:
; [67] 
; [68]   MemAvail := I;
                ld      hl,(display+2)  ; Local MemAvail
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global9 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [69] end;
exit10:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [70] 
; [71] function MaxAvail: Integer;
; [72] var
                if      __USE__MaxAvail13
; [73]   P: PBlock;
global14:       ds      2,0             ; Global P
; [74]   I: Integer;
global15:       ds      2,0             ; Global I
; [75] begin
; var MaxAvail(@RESULT), P(@global14), I(@global15)
__MaxAvail13:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [76]   P := HeapPtr;
                push    hl
                ld      hl,global14 + 0
                push    hl
                ld      hl,(__heapptr + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [77]   I := 0;
                ld      hl,global15 + 0
                ld      de,0
                ld      (hl),de
; [78]   while P <> nil do
while17:
                ld      hl,(global14 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [79]   begin
                bit     0,l
                jp      z,false18
; [80]     if P^.Size > I then I := P^.Size;
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                ld      hl,(global15 + 0)
                call    __int16_lt
                and     a
                jp      z,false19
                ld      hl,global15 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 2
                inc     hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
false19:
; [81]     P := P^.Next;
                ld      hl,global14 + 0
                push    hl
                ld      hl,global14 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [82]   end;
                jp      while17
false18:
; [83] 
; [84]   MaxAvail := I;
                ld      hl,(display+2)  ; Local MaxAvail
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global15 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [85] end;
exit16:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [86] 
; [87] procedure InitHeap;
; [88] var
                if      __USE__InitHeap20
; [89]   EofMarker: Integer absolute 'eof';
; [90]   HeapStart, HeapBytes: Integer;
global21:       ds      2,0             ; Global HeapStart
global22:       ds      2,0             ; Global HeapBytes
; [91] begin
; var EofMarker(@eof), HeapStart(@global21), HeapBytes(@global22)
__InitHeap20:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
; [92]   HeapStart := Addr(EofMarker);
                push    hl
                ld      hl,global21 + 0
                push    hl
                ld      hl,eof + 0
                ex      de,hl
                pop     hl
                ld      (hl),de
; [93]   if (HeapStart >= 0) and (HeapStart < 24576) then HeapStart := 24576;
                ld      hl,(global21 + 0)
                ld      de,0
                call    __int16_geq
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(global21 + 0)
                ld      de,24576
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false24
                ld      hl,global21 + 0
                ld      de,24576
                ld      (hl),de
false24:
; [94]   HeapBytes := 57343 - HeapStart;
                ld      hl,global22 + 0
                push    hl
                ld      de,57343        ; Literal 57343
                push    de
                ld      hl,(global21 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [95]   HeapPtr := nil;
                ld      hl,__heapptr + 0
                ld      de,0
                ld      (hl),de
; [96] 
; [97]   if HeapBytes > 0 then
                ld      hl,(global22 + 0)
                push    hl
                ld      hl,0            ; Literal 0
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [98]     FreeMem(Ptr(HeapStart), HeapBytes);
                bit     0,l
                jp      z,false25
                ld      hl,(global21 + 0)
                push    hl
                ld      hl,(global22 + 0)
                ex      de,hl
                pop     hl
                call    __freemem
false25:
; [99] end;
exit23:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [100] 
; [101] (* -------------------------------------------------------------------------- *)
; [102] (* --- Standard procedures -------------------------------------------------- *)
; [103] (* -------------------------------------------------------------------------- *)
; [104] 
; [105] (* Built-in: procedure Break;                   *)
; [106] (* Built-in: procedure Continue;                *)
; [107] (* Built-in: procedure Exit;                    *)
; [108] 
; [109] const
; [110]   Black   = 0;
; [111]   Blue    = 1;
; [112]   Red     = 2;
; [113]   Magenta = 3;
; [114]   Green   = 4;
; [115]   Cyan    = 5;
; [116]   Yellow  = 6;
; [117]   White   = 7;
; [118] 
; [119] 
; [120] 
; [121] (* -------------------------------------------------------------------------- *)
; [122] (* --- Arithmetic functions ------------------------------------------------- *)
; [123] (* -------------------------------------------------------------------------- *)
; [124] 
; [125] const
; [126]   MaxInt = 32767;
; [127]   MinInt = -32768;
; [128] 
; [129] (* Built-in: function Abs(I: Integer): Integer  *)
; [130] (* Built-in: function Abs(R: Real): Real        *)
; [131] 
; [132] function ArcTan(R: Real): Real; register; external 'ATN';
; [133] function Cos(R: Real): Real; register;    external 'COS';
; [134] function Exp(R: Real): Real; register;    external 'EXP';
; [135] function Frac(R: Real): Real; register;   external 'FRAC';
; [136] function Int(R: Real): Real; register;    external 'INT';
; [137] function Ln(R: Real): Real; register;     external 'LN';
; [138] function Log(R: Real): Real; register;    external 'LOG';
; [139] function Sin(R: Real): Real; register;    external 'SIN';
; [140] function Sqr(R: Real): Real; register;    external '__fltpwr2';
; [141] function Sqrt(R: Real): Real; register;   external 'SQR';
; [142] function Tan(R: Real): Real; register;    external 'TAN';
; [143] 
; [144] function Pi: Real; register;              external 'ACPI';
; [145] 
; [146] function MaxReal: Real; register; inline
__MaxReal38:
; [147] (
; [148]   $01 / $7FFF /
                db      1
                dw      32767
; [149]   $11 / $FFFF /
                db      17
                dw      65535
; [150]   $21 / $FFFF /
                db      33
                dw      65535
; [151]   $c9
; [152] );
                db      201
                ret
; [153] 
; [154] function MinReal: Real; register; inline
__MinReal39:
; [155] (
; [156]   $01 / $FFFF /
                db      1
                dw      65535
; [157]   $11 / $FFFF /
                db      17
                dw      65535
; [158]   $21 / $FFFF /
                db      33
                dw      65535
; [159]   $c9
; [160] );
                db      201
                ret
; [161] 
; [162] (* -------------------------------------------------------------------------- *)
; [163] (* --- Scalar functions ----------------------------------------------------- *)
; [164] (* -------------------------------------------------------------------------- *)
; [165] 
; [166] (* Built-in: function Pred(Ordinal): Ordinal;     *)
; [167] (* Built-in: function Succ(Ordinal): Ordinal;     *)
; [168] (* Built-in: function Odd(Ordinal): Boolean;      *)
; [169] (* Built-in: function Even(Ordinal): Boolean;     *)
; [170] 
; [171] (* -------------------------------------------------------------------------- *)
; [172] (* --- Transfer functions --------------------------------------------------- *)
; [173] (* -------------------------------------------------------------------------- *)
; [174] 
; [175] (* Built-in: function Ord(Ordinal): Integer;      *)
; [176] 
; [177] function Round(R: Real): Integer; register; external '__fltrnd';
; [178] function Trunc(R: Real): Integer; register; external 'FIX';
; [179] 
; [180] function Chr(B: Byte): Char; register; inline
__Chr42:
; [181] (
; [182]   $c9         (* ret          *)
; [183] );
                db      201
                ret
; [184] 
; [185] (* -------------------------------------------------------------------------- *)
; [186] (* --- Miscellaneous standard functions ------------------------------------- *)
; [187] (* -------------------------------------------------------------------------- *)
; [188] 
; [189] (* Built-in: function KeyPressed: Boolean;        *)
; [190] (* Built-in: function SizeOf(XYZ): Integer;       *)
; [191] (* Built-in: function Addr(XYZ): Integer;         *)
; [192] (* Built-in: function Ptr(I: Integer): Pointer;   *)
; [193] 
; [194] function Hi(I: Integer): Byte; register; inline
__Hi43:
; [195] (
; [196]   $6c /       (* ld   l,h     *)
                db      108
; [197]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [198]   $c9         (* ret          *)
; [199] );
                db      201
                ret
; [200] 
; [201] function Lo(I: Integer): Byte; register; inline
__Lo44:
; [202] (
; [203]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [204]   $c9         (* ret          *)
; [205] );
                db      201
                ret
; [206] 
; [207] function Swap(I: Integer): Integer; register; inline
__Swap45:
; [208] (
; [209]   $7c /       (* ld   a,h     *)
                db      124
; [210]   $65 /       (* ld   h,l     *)
                db      101
; [211]   $6f /       (* ld   l,a     *)
                db      111
; [212]   $c9         (* ret          *)
; [213] );
                db      201
                ret
; [214] 
; [215] function UpCase(C: Char): Char; register; inline
__UpCase46:
; [216] (
; [217]   $7d /       (* ld   a,l     *)
                db      125
; [218]   $fe / $61 / (* cp   'a'     *)
                db      254,97
; [219]   $d8 /       (* ret  c       *)
                db      216
; [220]   $fe / $7b / (* cp   'z' + 1 *)
                db      254,123
; [221]   $d0 /       (* ret  nc      *)
                db      208
; [222]   $cb / $ad / (* res  4,l     *)
                db      203,173
; [223]   $c9         (* ret          *)
; [224] );
                db      201
                ret
; [225] 
; [226] function LoCase(C: Char): Char; register; inline
__LoCase47:
; [227] (
; [228]   $7d /       (* ld   a,l     *)
                db      125
; [229]   $fe / $41 / (* cp   'A'     *)
                db      254,65
; [230]   $d8 /       (* ret  c       *)
                db      216
; [231]   $fe / $5b / (* cp   'Z' + 1 *)
                db      254,91
; [232]   $d0 /       (* ret  nc      *)
                db      208
; [233]   $cb / $ed / (* set  4,l     *)
                db      203,237
; [234]   $c9         (* ret          *)
; [235] );
                db      201
                ret
; [236] 
; [237] 
; [238] 
; [239] var
; [240]   RandSeed1: Integer absolute 'seed1';
; [241]   RandSeed2: Integer absolute 'seed2';
; [242] 
; [243] function Random(Range: Integer): Integer; register; external '__random';
; [244] function RandomReal: Real; register;                external '__random48';
; [245] 
; [246] procedure Randomize; register; inline
__Randomize50:
; [247] (
; [248]   $ed / $5f /             (* ld   a,r             *)
                db      237,95
; [249]   $2a / RandSeed1 /       (* ld   hl,(RandSeed1)  *)
                db      42
                dw      seed1
; [250]   $ed / $5b / RandSeed2 / (* ld   de,(RandSeed2)  *)
                db      237,91
                dw      seed2
; [251]   $53 /                   (* ld   d,e             *)
                db      83
; [252]   $5c /                   (* ld   e,h             *)
                db      92
; [253]   $65 /                   (* ld   h,l             *)
                db      101
; [254]   $6f /                   (* ld   l,a             *)
                db      111
; [255]   $22 / RandSeed1 /       (* ld   (RandSeed1),hl  *)
                db      34
                dw      seed1
; [256]   $ed / $53 / RandSeed2 / (* ld   (RandSeed2),de  *)
                db      237,83
                dw      seed2
; [257]   $c9                     (* ret                  *)
; [258] );
                db      201
                ret
; [259] 
; [260] procedure CheckBreak; register; external '__checkbreak';
; [261] 
; [262] procedure CheckStack; register; external '__checkstack';
; [263] 
; [264] (* Built-in: procedure FillChar(var Dest; Length: Integer; Data); *)
; [265] 
; [266] procedure Move(var Source, Dest; Count: Integer); register; external '__move';
; [267] 
; [268] (* Built-in: procedure Halt([ExitCode: Byte]) *)
; [269] 
; [270] 
; [271] 
; [272] (* -------------------------------------------------------------------------- *)
; [273] (* --- Assertion support ---------------------------------------------------- *)
; [274] (* -------------------------------------------------------------------------- *)
; [275] 
; [276] (* Built-in: procedure Assert(B: Boolean); *)
; [277] 
; [278] var
; [279]   AssertPassed: Integer absolute '__assertpassed';
; [280]   AssertFailed: Integer absolute '__assertfailed';
; [9] 
; [10] {$l cpm.asm     }
                include "/Users/joerg/Projects/pasta80/rtl/cpm.asm"
; [11] 
; [12] (* --------------------------------------------------------------------- *)
; [13] (* --- VT52 terminal support ------------------------------------------- *)
; [14] (* --------------------------------------------------------------------- *)
; [15] 
; [16] const
; [17]   (**
; [18]    * Defines the default with of the CP/M screen in characters.
; [19]    *)
; [20]   ScreenWidth = 80;
; [21] 
; [22]   (**
; [23]    * Defines the default height of the CP/M screen in characters.
; [24]    *)
; [25]   ScreenHeight = 24;
; [26] 
; [27]   (**
; [28]    * Defines the line break convention used by CP/M.
; [29]    *)
; [30]   LineBreak = #13#10;
; [31] 
; [32] procedure ConOut(C: Char); register;        external '__conout';
; [33] 
; [34] (**
; [35]  * Clears the screen. Uses the most recently defined text color and
; [36]  * background for the attribute area.
; [37]  *)
; [38] procedure ClrScr; register;                 external '__clrscr';
; [39] 
; [40] (**
; [41]  * Moves the the cursor (aka printing position) to a given location. Note
; [42]  * that Pascal expects the screen column (X) first, followed by the screen
; [43]  * row (Y).
; [44]  *)
; [45] procedure GotoXY(X, Y: Integer); register;  external '__gotoxy';
; [46] 
; [47] (**
; [48]  * Shows the cursor.
; [49]  *)
; [50] procedure CursorOn; register;               external '__cursor_on';
; [51] 
; [52] (**
; [53]  * Hides the cursor.
; [54]  *)
; [55] procedure CursorOff; register;              external '__cursor_off';
; [56] 
; [57] (**
; [58]  * Clear everything from the current cursor position to the end of the
; [59]  * line.
; [60]  *)
; [61] procedure ClrEol; register; inline
__ClrEol60:
; [62] (
; [63]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [64]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [65]   $3e / 'K' /                 (* ld   a,'K'     *)
                db      62,75
; [66]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [67]   $c9                         (* ret            *)
; [68] );
                db      201
                ret
; [69] 
; [70] (**
; [71]  * Clear everything from the current cursor position to the end of the
; [72]  * screen.
; [73]  *)
; [74] procedure ClrEos; register; inline
__ClrEos61:
; [75] (
; [76]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [77]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [78]   $3e / 'J' /                 (* ld   a,'J'     *)
                db      62,74
; [79]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [80]   $c9                         (* ret            *)
; [81] );
                db      201
                ret
; [82] 
; [83] (**
; [84]  * Inserts an empty line at the current cursor position, scrolling
; [85]  * everything that follows down.
; [86]  *)
; [87] procedure InsLine; register; inline
__InsLine62:
; [88] (
; [89]   $3e / 27 /                  (* ld   a,27      *)
                db      62,27
; [90]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [91]   $3e / 'L' /                 (* ld   a,'L'     *)
                db      62,76
; [92]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [93]   $c9                         (* ret            *)
; [94] );
                db      201
                ret
; [95] 
; [96] (**
; [97]  * Deletes a line at the current cursor position, scrolling everything that
; [98]  * follows up.
; [99]  *)
; [100] procedure DelLine; register; inline
__DelLine63:
; [101] (
; [102]   $2e / 27 /                  (* ld   l,27      *)
                db      46,27
; [103]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [104]   $3e / 'M' /                 (* ld   l,'M'     *)
                db      62,77
; [105]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [106]   $c9                         (* ret            *)
; [107] );
                db      201
                ret
; [108] 
; [109] (**
; [110]  * Sets the text color (0..7).
; [111]  *)
; [112] procedure TextColor(I: Integer); register;      external '__textfg';
; [113] 
; [114] (**
; [115]  * Sets the text background (0..7).
; [116]  *)
; [117] procedure TextBackground(I: Integer); register; external '__textbg';
; [118] 
; [119] (**
; [120]  * Sets the video to "high", whatever that is supposed be. Currently a
; [121]  * no-op and just defined to allow other code to build.
; [122]  *)
; [123] procedure HighVideo; register; inline
__HighVideo66:
; [124] (
; [125]   $c9 (* TODO implement me! *)
; [126] );
                db      201
                ret
; [127] 
; [128] (**
; [129]  * Sets the video to "low", whatever that is supposed be. Currently a
; [130]  * no-op and just defined to allow other code to build.
; [131]  *)
; [132] procedure LowVideo; register; inline
__LowVideo67:
; [133] (
; [134]   $c9 (* TODO implement me! *)
; [135] );
                db      201
                ret
; [136] 
; [137] (**
; [138]  * Sets the video to "norm", whatever that is supposed be. Currently a
; [139]  * no-op and just defined to allow other code to build.
; [140]  *)
; [141] procedure NormVideo; register; inline
__NormVideo68:
; [142] (
; [143]   $c9 (* TODO implement me! *)
; [144] );
                db      201
                ret
; [145] 
; [146] (* -------------------------------------------------------------------------- *)
; [147] (* --- Keyboard support ----------------------------------------------------- *)
; [148] (* -------------------------------------------------------------------------- *)
; [149] 
; [150] (**
; [151]  * Returns True if a key has been pressed (and can be queried using the
; [152]  * ReadKey function), False if not.
; [153]  *)
; [154] function KeyPressed: Boolean;
; [155] begin
                if      __USE__KeyPressed69
; var KeyPressed(@RESULT)
__KeyPressed69:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [156]   KeyPressed := BDOS(11, 0) <> 0;
                ld      hl,(display+2)  ; Local KeyPressed
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,11           ; Literal 11
                ld      de,0            ; Literal 0
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                call    __int16_neq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [157] end;
exit70:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [158] 
; [159] (**
; [160]  * Reads a key press and returns the corresponding ASCII character. Does
; [161]  * echo the character to the screen. Waits for a key press, if necessary,
; [162]  * so use KeyPressed first if you don't want your program to be delayed.
; [163]  *)
; [164] function ReadKey: CHar;
; [165] begin
                if      __USE__ReadKey71
; var ReadKey(@RESULT)
__ReadKey71:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [166]   repeat until KeyPressed;
repeat73:
                ld      de,0            ; Literal 0
                push    de
                call    __KeyPressed69
                pop     hl
                bit     0,l
                jp      z,repeat73
break74:
; [167]   ReadKey := Chr(BDOS(6, 255));
                ld      hl,(display+2)  ; Local ReadKey
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,6            ; Literal 6
                ld      de,255          ; Literal 255
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                call    __Chr42
                ex      de,hl
                pop     hl
                ld      (hl),e
; [168] end;
exit72:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [169] 
; [170] (**
; [171]  * Waits for the given interval in milliseconds. Assumes a CP/M platform
; [172]  * with BDOS call 141 (i.e. normally CP/M 3, but tnylpo has this as an
; [173]  * extension) and a "tick" value of 20 ms (which is the case for both the
; [174]  * Spectrum Next's CP/M and tnylpo).
; [175]  *)
; [176] procedure Delay(Duration: Integer);
; [177] var
                if      __USE__Delay75
; [178]   A: Byte;
global76:       ds      1,0             ; Global A
; [179] begin
; var Duration(+4), A(@global76)
__Delay75:                              ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [180]   A := BDos(141, Duration div 20);
                push    hl
                ld      hl,global76 + 0
                push    hl
                ld      de,141          ; Literal 141
                push    de
                ld      hl,(display+2)  ; Local Duration
                ld      de,4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,20           ; Literal 20
                call    __sdiv16        ; Div
                ex      de,hl
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [181] end;
exit77:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [182] 
; [183] (* -------------------------------------------------------------------------- *)
; [184] (* --- Command-line parameters ---------------------------------------------- *)
; [185] (* -------------------------------------------------------------------------- *)
; [186] 
; [187] (**
; [188]  * Returns the number of command line parameters.
; [189]  *)
; [190] function ParamCount: Byte;
; [191] var
                if      __USE__ParamCount78
; [192]   CmdLine: String absolute $80;
; [193]   C, D: Boolean;
global79:       ds      1,0             ; Global C
global80:       ds      1,0             ; Global D
; [194]   I, J: Byte;
global81:       ds      1,0             ; Global I
global82:       ds      1,0             ; Global J
; [195] begin
; var ParamCount(@RESULT), CmdLine(@128), C(@global79), D(@global80), I(@global81), J(@global82)
__ParamCount78:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-264         ; Space
                add     hl,sp
                ld      sp,hl
; [196]   C := True;
                ld      hl,global79 + 0
                ld      de,1
                ld      (hl),e
; [197]   J := 0;
                ld      hl,global82 + 0
                ld      de,0
                ld      (hl),e
; [198] 
; [199]   for I := 1 to Length(CmdLine) do
                ld      hl,global81     ; Global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global81     ; Global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak85
forloop84:
; [200]   begin
; [201]     D := CmdLine[I] > ' ';
                ld      hl,global80 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global81 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [202]     if not C and D then Inc(J);
                ld      hl,global79 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global80 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false87
                ld      hl,global82 + 0
                inc     (hl)
false87:
; [203]     C := D;
                ld      hl,global79 + 0
                push    hl
                ld      hl,global80 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [204]   end;
fornext86:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global81     ; Global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak85
                ld      hl,global81     ; Global I
                inc     (hl)
                jp      forloop84
forbreak85:     pop     de              ; Cleanup limit
; [205] 
; [206]   ParamCount := J;
                ld      hl,(display+2)  ; Local ParamCount
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,global82 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [207] end;
exit83:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [208] 
; [209] (**
; [210]  * Returns the I'th command line parameter, if it exists, or an empty
; [211]  * string otherwise.
; [212]  *)
; [213] function ParamStr(I: Byte): String;
; [214] var
                if      __USE__ParamStr88
; [215]   CmdLine: String absolute $80;
; [216]   C, D: Boolean;
global89:       ds      1,0             ; Global C
global90:       ds      1,0             ; Global D
; [217]   J, K: Byte;
global91:       ds      1,0             ; Global J
global92:       ds      1,0             ; Global K
; [218] begin
; var ParamStr(@RESULT), I(+4), CmdLine(@128), C(@global89), D(@global90), J(@global91), K(@global92)
__ParamStr88:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-264         ; Space
                add     hl,sp
                ld      sp,hl
; [219]   C := True;
                ld      hl,global89 + 0
                ld      de,1
                ld      (hl),e
; [220]   K := 1;
                ld      hl,global92 + 0
                ld      de,1
                ld      (hl),e
; [221] 
; [222]   for J := 1 to Length(CmdLine) do
                ld      hl,global91     ; Global J
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global91     ; Global J
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak95
forloop94:
; [223]   begin
; [224]     D := CmdLine[J] > ' ';
                ld      hl,global90 + 0
                push    hl
                ld      hl,128 + 0
                push    hl
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [225] 
; [226]     if not C and D then
                ld      hl,global89 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [227]       K := J
                bit     0,l
                jp      z,false97
                ld      hl,global92 + 0
; [228]     else if C and not D then
                push    hl
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
                jp      endif98
false97:
                ld      hl,global89 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [229]     begin
                bit     0,l
                jp      z,false99
; [230]       if I = 0 then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_eq0     ; Literal 0
                ld      h,0
                ld      l,a
; [231]       begin
                bit     0,l
                jp      z,false100
; [232]         Dec(J);
                ld      hl,global91 + 0
                dec     (hl)
; [233]         Break;
                jp      forbreak95      ; Break
; [234]       end;
false100:
; [235] 
; [236]       Dec(I);
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                dec     (hl)
; [237]     end;
false99:
endif98:
; [238] 
; [239]     C := D;
                ld      hl,global89 + 0
                push    hl
                ld      hl,global90 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [240]   end;
fornext96:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global91     ; Global J
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak95
                ld      hl,global91     ; Global J
                inc     (hl)
                jp      forloop94
forbreak95:     pop     de              ; Cleanup limit
; [241] 
; [242]   if I = 0 then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_eq0     ; Literal 0
                ld      h,0
                ld      l,a
; [243]     ParamStr := Copy(CmdLine, K, J - K + 1)
                bit     0,l
                jp      z,false101
                ld      hl,(display+2)  ; Local ParamStr
                ld      de,6
                add     hl,de
                push    hl
                call    __mkstr
                ld      hl,128 + 0
                call    __loadstr
                ld      hl,global92 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global91 + 0
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,global92 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                inc     hl
; [244]   else
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
                jp      endif102
false101:
; [245]     ParamStr := '';
                ld      hl,(display+2)  ; Local ParamStr
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,string103
                pop     de
                ld      a,255
                call    __movestr
endif102:
; [246] end;
exit93:         ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [247] 
; [248] (* -------------------------------------------------------------------------- *)
; [249] (* --- CP/M BDOS interface including error handling ------------------------- *)
; [250] (* -------------------------------------------------------------------------- *)
; [251] 
; [252] const
; [253]   (**
; [254]    * The last error that occurred during file IO. Most file functions will
; [255]    * be disabled as long as this value is non-zero.
; [256]    *)
; [257]   LastError: Byte = 0;
const104:
                db      0
; [258] 
; [259] (**
; [260]  * Queries the last error that happened during an esxDOS call and resets
; [261]  * the value to zero, so that further esxDOS calls can be made.
; [262]  *)
; [263] function IOResult: Byte;
; [264] begin
                if      __USE__IOResult105
; var IOResult(@RESULT)
__IOResult105:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [265]   IOResult := LastError;
                ld      hl,(display+2)  ; Local IOResult
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [266]   LastError := 0;
                ld      hl,const104 + 0
                ld      de,0
                ld      (hl),e
; [267] end;
exit106:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [268] 
; [269] (**
; [270]  * Performs a BDOS call for the given function number and parameter value.
; [271]  * TODO Check if we can merge this with the built-in BDos and BDosHL
; [272]  * functions.
; [273]  *)
; [274] procedure BDosCatch(Func: Byte; Param: Integer);
; [275] var
                if      __USE__BDosCatch107
; [276]   A: Byte;
global108:      ds      1,0             ; Global A
; [277] begin
; var Func(+6), Param(+4), A(@global108)
__BDosCatch107:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [278]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false110
                jp      exit109         ; Exit
false110:
; [279]   A := BDos(Func, Param);
                ld      hl,global108 + 0
                push    hl
                ld      hl,(display+2)  ; Local Func
                ld      de,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local Param
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [280]   (* WriteLn('BDos(', Func, ') returned A=' , A); *)
; [281]   if A <> 0 then LastError := A;
                ld      hl,global108 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false111
                ld      hl,const104 + 0
                push    hl
                ld      hl,global108 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
false111:
; [282] end;
exit109:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [283] 
; [284] (**
; [285]  * Checks the last BDOS error and terminates the program if it is <> 0.
; [286]  * Calls to this function are automatically generated by the compiler in
; [287]  * {$i+} mode.
; [288]  *)
; [289] procedure BDosThrow;
; [290] begin
                if      __USE__BDosThrow112
__BDosThrow112:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [291]   if LastError <> 0 then
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [292]   begin
                bit     0,l
                jp      z,false114
; [293]     WriteLn('BDos error ', LastError);
                ld      hl,string115
                call    __puts
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [294]     Halt;
                jp      __done
; [295]   end;
false114:
; [296] end;
exit113:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [297] 
; [298] (* --------------------------------------------------------------------- *)
; [299] (* --- Internal implementation of "raw" untyped files ------------------ *)
; [300] (* --------------------------------------------------------------------- *)
; [301] 
; [302] type
; [303]   (**
; [304]    * Represents a CP/M file control block.
; [305]    *)
; [306]   FileControlBlock = record             
; [307]     DR: Byte;                           (* Drive number                       *)
; [308]     FN: array[0..7] of Char;            (* File name, 8 chars, space-padded   *)
; [309]     TN: array[0..2] of Char;            (* Extension, 3 chars, space-padded   *)
; [310]     EX, S1, S2, RC: Byte;               (* CP/M internal stuff                *)
; [311]     AL: array[0..15] of Byte;           (* CP/M internal stuff                *)
; [312]     CR: Byte;                           (* CP/M internal stuff                *)
; [313]     RL: Integer; RH: Byte;              (* 24 bit random record number        *)
; [314]   end;
; [315] 
; [316] procedure BlockAssign(var F: FileControlBlock; S: String);
; [317] var
                if      __USE__BlockAssign116
; [318]   I, L, P, Q: Integer;
global117:      ds      2,0             ; Global I
global118:      ds      2,0             ; Global L
global119:      ds      2,0             ; Global P
global120:      ds      2,0             ; Global Q
; [319] begin
; var F(+260), S(+4), I(@global117), L(@global118), P(@global119), Q(@global120)
__BlockAssign116:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
                push    hl
; [320]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false122
                jp      exit121         ; Exit
false122:
; [321] 
; [322]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [323]   begin
; [324]     L := Length(S);
                push    de
                ld      hl,global118 + 0
                push    hl
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de
                pop     hl
                ld      (hl),de
; [325] 
; [326]     if (L > 1) and (S[2] = ':') then
                ld      hl,(global118 + 0)
                push    hl
                ld      hl,1            ; Literal 1
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                inc     hl
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,58           ; Literal 58
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [327]     begin
                bit     0,l
                jp      z,false123
; [328]       DR := Ord(UpCase(S[1])) - 64;
                ld      hl,(display+2)  ; Local DR
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ld      de,64
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [329]       Delete(S, 1, 2);
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      de,2            ; Literal 2
                push    de
                call    __delete
; Post call cleanup 6 bytes
                pop     hl
                pop     hl
                pop     hl
; [330]       Dec(L, 2);
                ld      hl,global118 + 0
                push    hl
                ld      bc,2            ; Literal 2
                pop     hl
                call    __dec16by
; [331]     end
; [332]     else DR := 0;
                jp      endif124
false123:
                ld      hl,(display+2)  ; Local DR
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e
endif124:
; [333] 
; [334]     P := Pos('.', S);
                ld      hl,global119 + 0
                push    hl
                push    hl
                ld      de,46           ; Literal 46
                call    __char2str
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [335]     if P = 0 then P := L + 1;
                ld      hl,(global119 + 0)
                call    __int16_eq0
                and     a
                jp      z,false125
                ld      hl,global119 + 0
                push    hl
                ld      hl,(global118 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
false125:
; [336] 
; [337]     Q := P - 1;
                ld      hl,global120 + 0
                push    hl
                ld      hl,(global119 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [338]     if Q > 8 then Q := 8;
                ld      hl,(global120 + 0)
                push    hl
                ld      hl,8            ; Literal 8
                pop     de
                call    __int16_lt
                and     a
                jp      z,false126
                ld      hl,global120 + 0
                ld      de,8
                ld      (hl),de
false126:
; [339] 
; [340]     for I := 1 to Q do FN[I - 1] := UpCase(S[I]);
                ld      hl,global117    ; Global I
                ld      de,1
                ld      (hl),de
                ld      hl,(global120 + 0)
                push    hl
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak128
forloop127:
                ld      hl,(display+2)  ; Local FN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext129:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak128
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop127
forbreak128:    pop     de              ; Cleanup limit
; [341]     for I := Q + 1 to 8 do FN[I - 1] := ' ';
                ld      hl,global117    ; Global I
                push    hl
                ld      hl,(global120 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak131
forloop130:
                ld      hl,(display+2)  ; Local FN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext132:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak131
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop130
forbreak131:    pop     de              ; Cleanup limit
; [342] 
; [343]     Q := L - P;
                ld      hl,global120 + 0
                push    hl
                ld      hl,(global118 + 0)
                push    hl
                ld      hl,(global119 + 0)
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [344]     if Q > 3 then Q := 3;
                ld      hl,(global120 + 0)
                push    hl
                ld      hl,3            ; Literal 3
                pop     de
                call    __int16_lt
                and     a
                jp      z,false133
                ld      hl,global120 + 0
                ld      de,3
                ld      (hl),de
false133:
; [345] 
; [346]     for I := 1 to Q do TN[I - 1] := UpCase(S[P + I]);
                ld      hl,global117    ; Global I
                ld      de,1
                ld      (hl),de
                ld      hl,(global120 + 0)
                push    hl
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak135
forloop134:
                ld      hl,(display+2)  ; Local TN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,(global119 + 0)
                push    hl
                ld      hl,(global117 + 0)
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __UpCase46
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext136:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak135
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop134
forbreak135:    pop     de              ; Cleanup limit
; [347]     for I := Q + 1 to 3 do TN[I - 1] := ' ';
                ld      hl,global117    ; Global I
                push    hl
                ld      hl,(global120 + 0)
                inc     hl
                ex      de,hl
                pop     hl
                ld      (hl),de
                ld      de,3            ; Literal 3
                push    de
                push    de
                ld      hl,(global117)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak138
forloop137:
                ld      hl,(display+2)  ; Local TN
                ld      de,-10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global117 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext139:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global117)
                call    __int16_lt
                and     a
                jp      z,forbreak138
                ld      hl,global117    ; Global I
                call    __inc16
                jp      forloop137
forbreak138:    pop     de              ; Cleanup limit
; [348] (*
; [349]     Write(DR, ':');
; [350]     for I := 0 to 7 do Write(FN[I]);
; [351]     Write('.');
; [352]     for I := 0 to 2 do Write(TN[I]);
; [353]     WriteLn;
; [354] *)
; [355]   end;
                pop     bc
; [356] end;
exit121:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [357] 
; [358] procedure BlockErase(var F: FileControlBlock);
; [359] var
                if      __USE__BlockErase140
; [360]   A: Byte;
global141:      ds      1,0             ; Global A
; [361] begin
; var F(+4), A(@global141)
__BlockErase140:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [362]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false143
                jp      exit142         ; Exit
false143:
; [363]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global141 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [364] end;
exit142:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [365] 
; [366] procedure BlockRename(var F: FileControlBlock; S: String);
; [367] var
                if      __USE__BlockRename144
; [368]   G: FileControlBlock;
; [369]   A: Byte;
global145:      ds      1,0             ; Global A
; [370] begin
; var F(+260), S(+4), G(-36), A(@global145)
__BlockRename144:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-38          ; Space
                add     hl,sp
                ld      sp,hl
; [371]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false147
                jp      exit146         ; Exit
false147:
; [372]   BlockAssign(G, S);
                ld      hl,(display+2)  ; Local G
                ld      de,-36
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [373]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false148
                jp      exit146         ; Exit
false148:
; [374]   Move(G, F.AL, 12);
                ld      hl,(display+2)  ; Local G
                ld      de,-36
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,16           ; Literal 16
                add     hl,de
                push    hl
                ld      bc,12           ; Literal 12
                pop     de
                pop     hl
                call    __move
; [375]   BDosCatch(23, Addr(F));
                ld      de,23           ; Literal 23
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [376] end;
exit146:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [377] 
; [378] procedure BlockReset(var F: FileControlBlock);
; [379] var
                if      __USE__BlockReset149
; [380]   A: Byte;
global150:      ds      1,0             ; Global A
; [381] begin
; var F(+4), A(@global150)
__BlockReset149:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [382]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false152
                jp      exit151         ; Exit
false152:
; [383] 
; [384]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [385]   begin
; [386]     EX := 0;
                push    de
                ld      hl,(display+2)  ; Local EX
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [387]     S1 := 0;
                ld      hl,(display+2)  ; Local S1
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [388]     S2 := 0;
                ld      hl,(display+2)  ; Local S2
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [389]     RC := 0;
                ld      hl,(display+2)  ; Local RC
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [390]     CR := 0;
                ld      hl,(display+2)  ; Local CR
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [391] 
; [392]     RL := 0;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),de
; [393]     RH := 0;
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [394]   end;
                pop     bc
; [395] 
; [396]   BDosCatch(15, Addr(F));
                ld      de,15           ; Literal 15
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [397] end;
exit151:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [398] 
; [399] procedure BlockRewrite(var F: FileControlBlock);
; [400] var
                if      __USE__BlockRewrite153
; [401]   A: Byte;
global154:      ds      1,0             ; Global A
; [402] begin
; var F(+4), A(@global154)
__BlockRewrite153:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [403]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false156
                jp      exit155         ; Exit
false156:
; [404] 
; [405]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [406]   begin
; [407]     EX := 0;
                push    de
                ld      hl,(display+2)  ; Local EX
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [408]     S1 := 0;
                ld      hl,(display+2)  ; Local S1
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [409]     S2 := 0;
                ld      hl,(display+2)  ; Local S2
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [410]     RC := 0;
                ld      hl,(display+2)  ; Local RC
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [411]     CR := 0;
                ld      hl,(display+2)  ; Local CR
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [412] 
; [413]     RL := 0;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,0
                ld      (hl),de
; [414]     RH := 0;
                ld      hl,(display+2)  ; Local RH
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,35
                add     hl,de
                ld      de,0
                ld      (hl),e
; [415]   end;
                pop     bc
; [416] 
; [417]   A := BDos(*Catch*)(19, Addr(F));
                ld      hl,global154 + 0
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      c,l
                call    5
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e
; [418]   BDosCatch(22, Addr(F));
                ld      de,22           ; Literal 22
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [419] end;
exit155:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [420] 
; [421] procedure BlockClose(var F: FileControlBlock);
; [422] begin
                if      __USE__BlockClose157
; var F(+4)
__BlockClose157:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [423]   BDosCatch(16, Addr(F));
                ld      de,16           ; Literal 16
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [424] end;
exit158:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [425] 
; [426] function BlockFilePos(var F: FileControlBlock): Integer;
; [427] begin
                if      __USE__BlockFilePos159
; var BlockFilePos(@RESULT), F(+4)
__BlockFilePos159:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [428]   BlockFilePos := F.RL;
                ld      hl,(display+2)  ; Local BlockFilePos
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [429] end;
exit160:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [430] 
; [431] function BlockFileSize(var F: FileControlBlock): Integer;
; [432] var
                if      __USE__BlockFileSize161
; [433]   I: Integer;
global162:      ds      2,0             ; Global I
; [434] begin
; var BlockFileSize(@RESULT), F(+4), I(@global162)
__BlockFileSize161:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [435]   with F do
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [436]   begin
; [437]     I := RL;
                push    de
                ld      hl,global162 + 0
                push    hl
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [438]     BDosCatch(35, Addr(F));
                ld      de,35           ; Literal 35
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [439]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false164
                jp      exit163         ; Exit
false164:
; [440]     BlockFileSize := RL;
                ld      hl,(display+2)  ; Local BlockFileSize
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [441]     RL := I;
                ld      hl,(display+2)  ; Local RL
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33
                add     hl,de
                push    hl
                ld      hl,(global162 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [442]   end;
                pop     bc
; [443] end;
exit163:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [444] 
; [445] function BlockEof(var F: FileControlBlock): Boolean;
; [446] begin
                if      __USE__BlockEof165
; var BlockEof(@RESULT), F(+4)
__BlockEof165:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [447]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false167
                jp      exit166         ; Exit
false167:
; [448] 
; [449]   BlockEof := BlockFilePos(F) = BlockFileSize(F);
                ld      hl,(display+2)  ; Local BlockEof
                ld      de,6
                add     hl,de
                push    hl
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockFilePos159
; Post call cleanup 2 bytes
                pop     hl
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockFileSize161
; Post call cleanup 2 bytes
                pop     hl
                pop     de              ; RelOp 9
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [450] end;
exit166:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [451] 
; [452] procedure BlockSeek(var F: FileControlBlock; I: Integer);
; [453] begin
                if      __USE__BlockSeek168
; var F(+6), I(+4)
__BlockSeek168:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [454]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false170
                jp      exit169         ; Exit
false170:
; [455] 
; [456]   F.RL := I;
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [457] end;
exit169:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [458] 
; [459] procedure BlockBlockRead(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
; [460] var
                if      __USE__BlockBlockRead171
; [461]   DMA: Integer;
global172:      ds      2,0             ; Global DMA
; [462] begin
; var F(+10), Buffer(+8), Count(+6), Actual(+4), DMA(@global172)
__BlockBlockRead171:                    ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [463]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false174
                jp      exit173         ; Exit
false174:
; [464] 
; [465]   DMA := Addr(Buffer);
                ld      hl,global172 + 0
                push    hl
                ld      hl,(display+2)  ; Local Buffer
                ld      de,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [466]   Actual := 0;
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),de
; [467] 
; [468]   while Count > 0 do
while175:
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ld      hl,0
                call    __int16_lt
                ld      h,0
                ld      l,a
; [469]   begin
                bit     0,l
                jp      z,false176
; [470]     WriteLn('Reading record #', F.RL, ' of FCB ', Addr(F));
                ld      hl,string177
                call    __puts
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string178
                call    __puts
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [471]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global172 + 0)
                push    hl
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [472]     BDosCatch(33, Addr(F));
                ld      de,33           ; Literal 33
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [473] 
; [474]     if LastError = 1 then
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                call    __int16_eq
                ld      h,0
                ld      l,a
; [475]     begin
                bit     0,l
                jp      z,false179
; [476]       LastError := 0;
                ld      hl,const104 + 0
                ld      de,0
                ld      (hl),e
; [477]       Exit;
                jp      exit173         ; Exit
; [478]     end;
false179:
; [479] 
; [480]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false180
                jp      exit173         ; Exit
false180:
; [481] 
; [482]     Inc(F.RL);
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [483]     Inc(DMA, 128);
                ld      hl,global172 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [484]     Inc(Actual);
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __inc16
; [485]     Dec(Count);
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                call    __dec16
; [486]   end;
                jp      while175
false176:
; [487] end;
exit173:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [488] 
; [489] procedure BlockBlockWrite(var F: FileControlBlock; var Buffer; Count: Integer; var Actual: Integer);
; [490] var
                if      __USE__BlockBlockWrite181
; [491]   DMA: Integer;
global182:      ds      2,0             ; Global DMA
; [492] begin
; var F(+10), Buffer(+8), Count(+6), Actual(+4), DMA(@global182)
__BlockBlockWrite181:                   ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [493]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false184
                jp      exit183         ; Exit
false184:
; [494] 
; [495]   DMA := Addr(Buffer);
                ld      hl,global182 + 0
                push    hl
                ld      hl,(display+2)  ; Local Buffer
                ld      de,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [496]   Actual := 0;
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),de
; [497] 
; [498]   while Count > 0 do
while185:
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ld      hl,0
                call    __int16_lt
                ld      h,0
                ld      l,a
; [499]   begin
                bit     0,l
                jp      z,false186
; [500]     WriteLn('Writing record #', F.RL, ' of FCB ', Addr(F));
                ld      hl,string187
                call    __puts
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string178
                call    __puts
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [501]     BDosCatch(26, DMA);
                ld      de,26           ; Literal 26
                push    de
                ld      hl,(global182 + 0)
                push    hl
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [502]     BDosCatch(34, Addr(F));
                ld      de,34           ; Literal 34
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BDosCatch107
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [503]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false188
                jp      exit183         ; Exit
false188:
; [504] 
; [505]     Inc(F.RL);
                ld      hl,(display+2)  ; Local F
                ld      de,10
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                call    __inc16
; [506]     Inc(DMA, 128);
                ld      hl,global182 + 0
                push    hl
                ld      bc,128          ; Literal 128
                pop     hl
                call    __inc16by
; [507]     Inc(Actual);
                ld      hl,(display+2)  ; Local Actual
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __inc16
; [508]     Dec(Count);
                ld      hl,(display+2)  ; Local Count
                ld      de,6
                add     hl,de
                call    __dec16
; [509]   end;
                jp      while185
false186:
; [510] end;
exit183:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [511] 
; [512] {$i files.pas}
; [0] (* --- Text file routines, use TextRec as representation -------------------- *)
; [1] 
; [2] type
; [3]   TextRec = record                      (* Internal text file representation  *)
; [4]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [5]     Readable: Boolean;                  (* File is open for reading           *)
; [6]     Writable: Boolean;                  (* File is open for writing           *)
; [7]     EndOfFile: Boolean;
; [8]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [9]     DMA: array[0..127] of Char;         (* Internal sector buffer             *)
; [10]   end;
; [11] 
; [12]   FileRec = record                      (* Internal typed file representation *)
; [13]     FCB: FileControlBlock;              (* FCB, *must* start at offset 0      *)
; [14]     CompSize: Integer;                  (* Size of component type             *)
; [15]     CompCount: Integer;                 (* Number of components in file       *)
; [16]     CompIndex: Integer;                 (* Index of current component         *)
; [17]     Offset: Integer;                    (* Offset within 128 byte buffer      *)
; [18]     Modified: Boolean;                  (* Current record has been modified   *)
; [19]     case Boolean of
; [20]       False: (DMA: array[0..127] of Char;); (* Internal sector buffer         *)
; [21]       True:  (HdrCount, HdrSize: Integer;); (* Typed file header              *)
; [22]   end;
; [23] 
; [24] procedure TextAssign(var T: TextRec; Name: String);
; [25] begin
                if      __USE__TextAssign189
; var T(+260), Name(+4)
__TextAssign189:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [26]   BlockAssign(T.FCB, Name);
                ld      hl,(display+2)  ; Local T
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Name
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [27] end;
exit190:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [28] 
; [29] procedure TextReset(var T: TextRec);
; [30] var
                if      __USE__TextReset191
; [31]   E: Integer;
global192:      ds      2,0             ; Global E
; [32] begin
; var T(+4), E(@global192)
__TextReset191:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [33]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [34]   begin
; [35]     BlockReset(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockReset149
; Post call cleanup 2 bytes
                pop     hl
; [36]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global192 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [37] 
; [38]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false194
                jp      exit193         ; Exit
false194:
; [39] 
; [40]     Readable := True;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,1
                ld      (hl),e
; [41]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [42] 
; [43]     Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),de
; [44]     EndOfFile := E = 0;
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                push    hl
                ld      hl,(global192 + 0)
                call    __int16_eq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [45]   end;
                pop     bc
; [46] end;
exit193:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [47] 
; [48] procedure TextRewrite(var T: TextRec);
; [49] begin
                if      __USE__TextRewrite195
; var T(+4)
__TextRewrite195:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [50]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [51]   begin
; [52]     BlockRewrite(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockRewrite153
; Post call cleanup 2 bytes
                pop     hl
; [53] 
; [54]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false197
                jp      exit196         ; Exit
false197:
; [55] 
; [56]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [57]     Writable := True;
                ld      hl,(display+2)  ; Local Writable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,1
                ld      (hl),e
; [58] 
; [59]     Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),de
; [60]   end;
                pop     bc
; [61] end;
exit196:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [62] 
; [63] procedure TextReadChar(var T: TextRec; var C: Char);
; [64] var
                if      __USE__TextReadChar198
; [65]   E: Integer;
global199:      ds      2,0             ; Global E
; [66] begin
; var T(+6), C(+4), E(@global199)
__TextReadChar198:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [67]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [68]   begin
; [69]     if EndOfFile then
                push    de
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [70]     begin
                ex      de,hl
                bit     0,l
                jp      z,false201
; [71]       C := #26;
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                ld      (hl),e
; [72]       Exit;
                jp      exit200         ; Exit
; [73]     end;
false201:
; [74] 
; [75]     C := DMA[Offset];
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [76]     if C <> #26 then
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_neq
                ld      h,0
                ld      l,a
; [77]     begin
                bit     0,l
                jp      z,false202
; [78]       Inc(Offset);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                call    __inc16
; [79]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [80]       begin
                bit     0,l
                jp      z,false203
; [81]         BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global199 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [82]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false204
                jp      exit200         ; Exit
false204:
; [83]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),de
; [84]         EndOfFile := E = 0;
                ld      hl,(display+2)  ; Local EndOfFile
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                push    hl
                ld      hl,(global199 + 0)
                call    __int16_eq0
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [85]       end;
false203:
; [86]     end;
false202:
; [87]   end;
                pop     bc
; [88] end;
exit200:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [89] 
; [90] procedure TextReadStr(var T: TextRec; var S: String);
; [91] var
                if      __USE__TextReadStr205
; [92]   C: Char;
global206:      ds      1,0             ; Global C
; [93] begin
; var T(+6), S(+4), C(@global206)
__TextReadStr205:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [94]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [95] 
; [96]   while Length(S) < 255 do
while208:
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [97]   begin
                bit     0,l
                jp      z,false209
; [98]     TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global206 + 0
                push    hl
                call    __TextReadChar198
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [99]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false210
                jp      exit207         ; Exit
false210:
; [100] 
; [101]     if C = #10 then Break;
                ld      hl,global206 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false211
                jp      false209        ; Break
false211:
; [102]     if C = #13 then
                ld      hl,global206 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_eq
                ld      h,0
                ld      l,a
; [103]     begin
                bit     0,l
                jp      z,false212
; [104]       if T.DMA[T.Offset] = #10 then TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41           ; Literal 41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false213
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global206 + 0
                push    hl
                call    __TextReadChar198
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
false213:
; [105]       Break;
                jp      false209        ; Break
; [106]     end;
false212:
; [107]     if C = #26 then Break;
                ld      hl,global206 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false214
                jp      false209        ; Break
false214:
; [108] 
; [109]     if C >= ' ' then S := S + C;
                ld      hl,global206 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                and     a
                jp      z,false215
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global206 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
false215:
; [110]   end;
                jp      while208
false209:
; [111] end;
exit207:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [112] 
; [113] procedure TextReadWord(var T: TextRec; var S: String);
; [114] var
                if      __USE__TextReadWord216
; [115]   C: Char;
global217:      ds      1,0             ; Global C
; [116] begin
; var T(+6), S(+4), C(@global217)
__TextReadWord216:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [117]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [118] 
; [119]   while Length(S) < 255 do
while219:
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [120]   begin
                bit     0,l
                jp      z,false220
; [121]     TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global217 + 0
                push    hl
                call    __TextReadChar198
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [122]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false221
                jp      exit218         ; Exit
false221:
; [123] 
; [124]     if C > ' ' then S := S + C else Break;
                ld      hl,global217 + 0
                ld      d,0
                ld      e,(hl)
                ld      hl,32
                call    __int16_lt
                and     a
                jp      z,false222
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global217 + 0
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
                jp      endif223
false222:
                jp      false220        ; Break
endif223:
; [125]   end;
                jp      while219
false220:
; [126] end;
exit218:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [127] 
; [128] procedure TextReadInt(var T: TextRec; var I: Integer);
; [129] var
                if      __USE__TextReadInt224
; [130]   S: String;
; [131]   E: Integer;
global225:      ds      2,0             ; Global E
; [132] begin
; var T(+6), I(+4), S(-256), E(@global225)
__TextReadInt224:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [133]   TextReadWord(T, S);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextReadWord216
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [134]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false227
                jp      exit226         ; Exit
false227:
; [135]   Val(S, I, E);
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                call    __loadstr
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global225 + 0
                push    hl
                call    __val_int
; [136] end;
exit226:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [137] 
; [138] procedure TextReadFloat(var T: TextRec; var R: Real);
; [139] var
                if      __USE__TextReadFloat228
; [140]   S: String;
; [141]   E: Integer;
global229:      ds      2,0             ; Global E
; [142] begin
; var T(+6), R(+4), S(-256), E(@global229)
__TextReadFloat228:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-258         ; Space
                add     hl,sp
                ld      sp,hl
; [143]   TextReadWord(T, S);
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                push    hl
                call    __TextReadWord216
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [144]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false231
                jp      exit230         ; Exit
false231:
; [145]   Val(S, R, E);
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                call    __loadstr
                ld      hl,(display+2)  ; Local R
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global229 + 0
                push    hl
                call    __val_float
; [146] end;
exit230:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [147] 
; [148] procedure TextWriteChar(var T: TextRec; C: Char);
; [149] var
                if      __USE__TextWriteChar232
; [150]   E: Integer;
global233:      ds      2,0             ; Global E
; [151] begin
; var T(+6), C(+4), E(@global233)
__TextWriteChar232:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [152]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [153]   begin
; [154]     DMA[Offset] := C;
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local C
                ld      de,4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [155]     Inc(Offset);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                call    __inc16
; [156]     if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [157]     begin
                bit     0,l
                jp      z,false235
; [158]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global233 + 0
                push    hl
                call    __BlockBlockWrite181
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [159]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false236
                jp      exit234         ; Exit
false236:
; [160]       Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,0
                ld      (hl),de
; [161]     end;
false235:
; [162]   end;
                pop     bc
; [163] end;
exit234:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [164] 
; [165] procedure TextFlush(var T: TextRec);
; [166] var
                if      __USE__TextFlush237
; [167]   E: Integer;
global238:      ds      2,0             ; Global E
; [168] begin
; var T(+4), E(@global238)
__TextFlush237:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [169]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [170]   begin
; [171]     (* FIXME !!! *)
; [172]     TextWriteChar(T, #26);
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    __TextWriteChar232
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [173] 
; [174]     if Offset <> 0 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                ld      h,0
                ld      l,a
; [175]       BlockBlockWrite(FCB, DMA, 1, E);
                bit     0,l
                jp      z,false240
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global238 + 0
                push    hl
                call    __BlockBlockWrite181
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
false240:
; [176] 
; [177]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false241
                jp      exit239         ; Exit
false241:
; [178] 
; [179]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [180]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [181]   end;
                pop     bc
; [182] end;
exit239:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [183] 
; [184] procedure TextClose(var T: TextRec);
; [185] var
                if      __USE__TextClose242
; [186]   E: Integer;
global243:      ds      2,0             ; Global E
; [187] begin
; var T(+4), E(@global243)
__TextClose242:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [188]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [189]   begin
; [190]     if Writable then TextFlush(T);
                push    de
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                bit     0,l
                jp      z,false245
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextFlush237
; Post call cleanup 2 bytes
                pop     hl
false245:
; [191] 
; [192]     BlockClose(FCB);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockClose157
; Post call cleanup 2 bytes
                pop     hl
; [193] 
; [194]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false246
                jp      exit244         ; Exit
false246:
; [195] 
; [196]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [197]     Writable := False;
                ld      hl,(display+2)  ; Local Writable
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,0
                ld      (hl),e
; [198]   end;
                pop     bc
; [199] end;
exit244:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [200] 
; [201] procedure TextWriteStr(var T: TextRec; S: String);
; [202] var
                if      __USE__TextWriteStr247
; [203]   I: Byte;
global248:      ds      1,0             ; Global I
; [204] begin
; var T(+260), S(+4), I(@global248)
__TextWriteStr247:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [205]   for I := 1 to Length(S) do
                push    hl
                ld      hl,global248    ; Global I
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global248    ; Global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak251
forloop250:
; [206]   begin
; [207]     TextWriteChar(T, S[I]);
                ld      hl,(display+2)  ; Local T
                ld      de,260
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                push    hl
                ld      hl,global248 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    __TextWriteChar232
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [208]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false253
                jp      exit249         ; Exit
false253:
; [209]   end;
fornext252:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global248    ; Global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak251
                ld      hl,global248    ; Global I
                inc     (hl)
                jp      forloop250
forbreak251:    pop     de              ; Cleanup limit
; [210] end;
exit249:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [211] 
; [212] procedure TextWriteEoln(var T: TextRec);
; [213] begin
                if      __USE__TextWriteEoln254
; var T(+4)
__TextWriteEoln254:                     ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [214]   TextWriteStr(T, LineBreak);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,string54
                call    __loadstr
                call    __TextWriteStr247
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [215] end;
exit255:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [216] 
; [217] function TextEoln(var T: TextRec): Boolean;
; [218] begin
                if      __USE__TextEoln256
; var TextEoln(@RESULT), T(+4)
__TextEoln256:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [219]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [220]     TextEoln := DMA[Offset] = #13;
                push    de
                ld      hl,(display+2)  ; Local TextEoln
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local DMA
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [221] end;
exit257:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [222] 
; [223] function TextEof(var T: TextRec): Boolean;
; [224] begin
                if      __USE__TextEof258
; var TextEof(@RESULT), T(+4)
__TextEof258:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [225]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [226]     TextEof := EndOfFile or (DMA[Offset] = #26);
                push    de
                ld      hl,(display+2)  ; Local TextEof
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local EndOfFile
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                or      e
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [227] end;
exit259:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [228] 
; [229] procedure TextSeekEof(var T: TextRec);
; [230] var
                if      __USE__TextSeekEof260
; [231]   E: Integer;
global261:      ds      2,0             ; Global E
; [232]   C: Char;
global262:      ds      1,0             ; Global C
; [233] begin
; var T(+4), E(@global261), C(@global262)
__TextSeekEof260:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [234]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [235]   begin
; [236]     BlockSeek(FCB, BlockFileSize(FCB) - 1);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                push    hl
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockFileSize161
; Post call cleanup 2 bytes
                pop     hl
                ld      de,1            ; Literal 1
                pop     hl
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [237]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global261 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [238] 
; [239]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false264
                jp      exit263         ; Exit
false264:
; [240] 
; [241]     while not TextEof(T) do
while265:
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextEof258
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [242]       TextReadChar(T, C);
                bit     0,l
                jp      z,false266
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global262 + 0
                push    hl
                call    __TextReadChar198
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                jp      while265
false266:
; [243]   end;
                pop     bc
; [244] end;
exit263:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [245] 
; [246] procedure TextSeekEoln(var T: TextRec);
; [247] var
                if      __USE__TextSeekEoln267
; [248]   C: Char;
global268:      ds      1,0             ; Global C
; [249] begin
; var T(+4), C(@global268)
__TextSeekEoln267:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [250]   with T do
                push    hl
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [251]   begin
; [252]     while DMA[Offset] <> #13 do
                push    de
while270:
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,41
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,13           ; Literal 13
                call    __int16_neq
                ld      h,0
                ld      l,a
; [253]     begin
                bit     0,l
                jp      z,false271
; [254]       TextReadChar(T, C);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global268 + 0
                push    hl
                call    __TextReadChar198
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [255]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false272
                jp      exit269         ; Exit
false272:
; [256]     end;
                jp      while270
false271:
; [257]   end;
                pop     bc
; [258] end;
exit269:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [259] 
; [260] procedure TextAppend(var T: TextRec);
; [261] begin
                if      __USE__TextAppend273
; var T(+4)
__TextAppend273:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [262]   with T do
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [263]   begin
; [264]     TextReset(T);
                push    de
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextReset191
; Post call cleanup 2 bytes
                pop     hl
; [265]     TextSeekEof(T);
                ld      hl,(display+2)  ; Local T
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __TextSeekEof260
; Post call cleanup 2 bytes
                pop     hl
; [266] 
; [267]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false275
                jp      exit274         ; Exit
false275:
; [268] 
; [269]     BlockSeek(FCB, FCB.RL - 1);
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [270] 
; [271]     Readable := False;
                ld      hl,(display+2)  ; Local Readable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,0
                ld      (hl),e
; [272]     Writable := True;
                ld      hl,(display+2)  ; Local Writable
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,37
                add     hl,de
                ld      de,1
                ld      (hl),e
; [273]   end;
                pop     bc
; [274] end;
exit274:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [275] 
; [276] (* --- Typed file routines, use FileRec as representation ------------------- *)
; [277] 
; [278] procedure FileAssign(var F: FileRec; Name: String; Size: Integer);
; [279] begin
                if      __USE__FileAssign276
; var F(+262), Name(+6), Size(+4)
__FileAssign276:                        ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [280]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false278
                jp      exit277         ; Exit
false278:
; [281] 
; [282]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,262
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [283]   begin
; [284]     BlockAssign(FCB, Name);
                push    de
                ld      hl,(display+2)  ; Local FCB
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Name
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __BlockAssign116
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [285]     CompSize := Size;
                ld      hl,(display+2)  ; Local CompSize
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Size
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [286]   end;
                pop     bc
; [287] end;
exit277:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [288] 
; [289] procedure FileReset(var F: FileRec);
; [290] var
                if      __USE__FileReset279
; [291]   E: Integer;
global280:      ds      2,0             ; Global E
; [292] begin
; var F(+4), E(@global280)
__FileReset279:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [293]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false282
                jp      exit281         ; Exit
false282:
; [294] 
; [295]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [296]   begin
; [297]     BlockReset(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockReset149
; Post call cleanup 2 bytes
                pop     hl
; [298]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global280 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [299] 
; [300]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false283
                jp      exit281         ; Exit
false283:
; [301] 
; [302]     if CompSize <> HdrSize then
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local HdrSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [303]     begin
                bit     0,l
                jp      z,false284
; [304]       WriteLn('Invalid file type');
                ld      hl,string285
                call    __puts
                call    __newline
; [305]       Halt;
                jp      __done
; [306]     end;
false284:
; [307] 
; [308]     CompCount := HdrCount;
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [309]     CompIndex := 0;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),de
; [310] 
; [311]     Offset := 4;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,4
                ld      (hl),de
; [312]     Modified := False;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,0
                ld      (hl),e
; [313] 
; [314]     (*WriteLn('Opened existing file, size=', CompSize, ' count=', CompCount);
; [315]     ReadLn;*)
; [316]   end;
                pop     bc
; [317] end;
exit281:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [318] 
; [319] procedure FileRewrite(var F: FileRec);
; [320] var
                if      __USE__FileRewrite286
; [321]   E: Integer;
global287:      ds      2,0             ; Global E
; [322] begin
; var F(+4), E(@global287)
__FileRewrite286:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [323]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false289
                jp      exit288         ; Exit
false289:
; [324] 
; [325]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [326]   begin
; [327]     BlockRewrite(FCB);
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockRewrite153
; Post call cleanup 2 bytes
                pop     hl
; [328] 
; [329]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false290
                jp      exit288         ; Exit
false290:
; [330] 
; [331]     HdrSize := CompSize;
                ld      hl,(display+2)  ; Local HdrSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,47
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [332]     HdrCount := 0;
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                ld      de,0
                ld      (hl),de
; [333] 
; [334]     CompCount := 0;
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,0
                ld      (hl),de
; [335]     CompIndex := 0;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,0
                ld      (hl),de
; [336] 
; [337]     Offset := 4;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,4
                ld      (hl),de
; [338]     Modified := True;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,1
                ld      (hl),e
; [339] 
; [340]     BlockBlockWrite(FCB, DMA, 1, E); (* TODO Delay this until Flush/Close? *)
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global287 + 0
                push    hl
                call    __BlockBlockWrite181
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [341] 
; [342]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false291
                jp      exit288         ; Exit
false291:
; [343] 
; [344]     (*WriteLn('Created new file, size=', CompSize, ' count=', CompCount);*)
; [345]   end;
                pop     bc
; [346] end;
exit288:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [347] 
; [348] function FileFileSize(var F: FileRec): Integer;
; [349] begin
                if      __USE__FileFileSize292
; var FileFileSize(@RESULT), F(+4)
__FileFileSize292:                      ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [350]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false294
                jp      exit293         ; Exit
false294:
; [351] 
; [352]   FileFileSize := F.CompCount;
                ld      hl,(display+2)  ; Local FileFileSize
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38           ; Literal 38
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [353] end;
exit293:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [354] 
; [355] function FileFilePos(var F: FileRec): Integer;
; [356] begin
                if      __USE__FileFilePos295
; var FileFilePos(@RESULT), F(+4)
__FileFilePos295:                       ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [357]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false297
                jp      exit296         ; Exit
false297:
; [358] 
; [359]   FileFilePos := F.CompIndex;
                ld      hl,(display+2)  ; Local FileFilePos
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40           ; Literal 40
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [360] end;
exit296:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [361] 
; [362] function FileEof(var F: FileRec): Boolean;
; [363] begin
                if      __USE__FileEof298
; var FileEof(@RESULT), F(+4)
__FileEof298:                           ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [364]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false300
                jp      exit299         ; Exit
false300:
; [365] 
; [366]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [367]     FileEof := CompIndex = CompCount;
                push    de
                ld      hl,(display+2)  ; Local FileEof
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompIndex
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                dec     hl
                dec     hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
                pop     bc
; [368] end;
exit299:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [369] 
; [370] procedure FileFlush(var F: FileRec);
; [371] var
                if      __USE__FileFlush301
; [372]   E: Integer;
global302:      ds      2,0             ; Global E
; [373] begin
; var F(+4), E(@global302)
__FileFlush301:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [374]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false304
                jp      exit303         ; Exit
false304:
; [375] 
; [376]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [377]   begin
; [378]     if Modified then
                push    de
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      d,0
                ld      e,(hl)
; [379]     begin
                ex      de,hl
                bit     0,l
                jp      z,false305
; [380]       BlockSeek(FCB, FCB.RL - 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [381]       BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global302 + 0
                push    hl
                call    __BlockBlockWrite181
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [382]       if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false306
                jp      exit303         ; Exit
false306:
; [383]       Modified := False;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,0
                ld      (hl),e
; [384]     end;
false305:
; [385]   end;
                pop     bc
; [386] end;
exit303:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [387] 
; [388] procedure FileSeek(var F: FileRec; I: Integer);
; [389] var
                if      __USE__FileSeek307
; [390]   P, S: Real;
global308:      ds      6,0             ; Global P
global309:      ds      6,0             ; Global S
; [391]   E: Integer;
global310:      ds      2,0             ; Global E
; [392] begin
; var F(+6), I(+4), P(@global308), S(@global309), E(@global310)
__FileSeek307:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [393]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false312
                jp      exit311         ; Exit
false312:
; [394] 
; [395]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [396]   begin
; [397]     FileFlush(F);
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush301
; Post call cleanup 2 bytes
                pop     hl
; [398] 
; [399]     if I > CompCount then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [400]     begin
                bit     0,l
                jp      z,false313
; [401]       WriteLn('*** ', I, ' > ', CompCount);
                ld      hl,string314
                call    __puts
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string315
                call    __puts
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [402]       Halt;
                jp      __done
; [403]     end;
false313:
; [404] 
; [405]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false316
                jp      exit311         ; Exit
false316:
; [406] 
; [407]     P := 4.0 + I * 1.0 * CompSize;    (* Should we use Real here?    *)
                ld      hl,global308 + 0
                push    hl
                constfp 0x0083,0x0000,0x0000
                pushfp
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                constfp 0x0081,0x0000,0x0000
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                pushfp
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    FLOAT
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPADD
                exx
                pop     hl
                call    __storefp
; [408]     S := Int(P / 128);
                ld      hl,global309 + 0
                push    hl
                ld      hl,global308 + 0
                call    __loadfp
                pushfp
                ld      hl,128          ; Literal 128
                call    FLOAT
                exx
                popfp
                call    FPDIV
                call    INT
                exx
                pop     hl
                call    __storefp
; [409]     (* WriteLn('Seeking to index ', I, ' offset ', P, ' sector ', S);*)
; [410]     BlockSeek(FCB, Trunc(S));  (* Why does div not work here? *)
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global309 + 0
                call    __loadfp
                call    FIX
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [411]     if I < CompCount then
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [412]       BlockBlockRead(FCB, DMA, 1, E)
                bit     0,l
                jp      z,false317
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global310 + 0
; [413]     else
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                jp      endif318
false317:
; [414]       BlockSeek(FCB, FCB.RL + 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
endif318:
; [415] 
; [416]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false319
                jp      exit311         ; Exit
false319:
; [417] 
; [418]     Offset := Trunc(P - 128 * S); (* Abs(P mod 128); *)
                ld      hl,(display+2)  ; Local Offset
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,global308 + 0
                call    __loadfp
                pushfp
                ld      de,128          ; Literal 128
                push    de
                ld      hl,global309 + 0
                call    __loadfp
                exx
                pop     hl
                exx
                pushfp
                exx
                call    FLOAT
                exx
                popfp
                exx
                pushfp
                exx
                exx
                popfp
                call    FPMUL
                exx
                popfp
                call    FPSUB
                call    FIX
                ex      de,hl
                pop     hl
                ld      (hl),de
; [419] 
; [420]     CompIndex := I;
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-16
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [421]   end;
                pop     bc
; [422] end;
exit311:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [423] 
; [424] procedure FileRead(var F: FileRec; var Comp);
; [425] var
                if      __USE__FileRead320
; [426]   Address, Need, Avail, Bytes, E: Integer;
global321:      ds      2,0             ; Global Address
global322:      ds      2,0             ; Global Need
global323:      ds      2,0             ; Global Avail
global324:      ds      2,0             ; Global Bytes
global325:      ds      2,0             ; Global E
; [427]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [428]   P: ^Byte absolute Address;
; [429] begin
; var F(+6), Comp(+4), Address(@global321), Need(@global322), Avail(@global323), Bytes(@global324), E(@global325), P(@global321)
__FileRead320:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [430]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false327
                jp      exit326         ; Exit
false327:
; [431] 
; [432]   (* WriteLn('Read entry #', FileFilePos(F)); *)
; [433] 
; [434]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [435]   begin
; [436]     Address := Addr(Comp);
                push    de
                ld      hl,global321 + 0
                push    hl
                ld      hl,(display+2)  ; Local Comp
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [437]     Need := CompSize;
                ld      hl,global322 + 0
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [438] 
; [439]     while Need <> 0 do
while328:
                ld      hl,(global322 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [440]     begin
                bit     0,l
                jp      z,false329
; [441]       Avail := 128 - Offset;
                ld      hl,global323 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [442]       if Avail >= Need then
                ld      hl,(global323 + 0)
                push    hl
                ld      hl,(global322 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [443]         Bytes := Need
                bit     0,l
                jp      z,false330
                ld      hl,global324 + 0
; [444]       else
                push    hl
                ld      hl,(global322 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
                jp      endif331
false330:
; [445]         Bytes := Avail;
                ld      hl,global324 + 0
                push    hl
                ld      hl,(global323 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
endif331:
; [446] 
; [447]       Move(DMA[Offset], P^, Bytes); (* Hmm... feels like a hack. *)
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,global321 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global324 + 0)
                ld      bc,hl
                pop     de
                pop     hl
                call    __move
; [448]       Inc(Address, Bytes);
                ld      hl,global321 + 0
                push    hl
                ld      hl,(global324 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [449]       Inc(Offset, Bytes);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,(global324 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [450]       Dec(Need, Bytes);
                ld      hl,global322 + 0
                push    hl
                ld      hl,(global324 + 0)
                ld      bc,hl
                pop     hl
                call    __dec16by
; [451] 
; [452]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [453]       begin
                bit     0,l
                jp      z,false332
; [454]         FileFlush(F);
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush301
; Post call cleanup 2 bytes
                pop     hl
; [455]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileEof298
; Post call cleanup 2 bytes
                pop     hl
; [456]           BlockSeek(FCB, FCB.RL + 1)
                pop     hl
                bit     0,l
                jp      z,false333
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
; [457]         else
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                jp      endif334
false333:
; [458]           BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global325 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
endif334:
; [459]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false335
                jp      exit326         ; Exit
false335:
; [460]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [461]       end;
false332:
; [462]     end;
                jp      while328
false329:
; [463] 
; [464]     Inc(CompIndex);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                call    __inc16
; [465]   end;
                pop     bc
; [466] end;
exit326:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [467] 
; [468] procedure FileWrite(var F: FileRec; var Comp);
; [469] var
                if      __USE__FileWrite336
; [470]   Address, Need, Avail, Bytes, E: Integer;
global337:      ds      2,0             ; Global Address
global338:      ds      2,0             ; Global Need
global339:      ds      2,0             ; Global Avail
global340:      ds      2,0             ; Global Bytes
global341:      ds      2,0             ; Global E
; [471]   (*Mem: array[0..65535] of Byte absolute 0;*)
; [472]   P: ^Byte absolute Address;
; [473] begin
; var F(+6), Comp(+4), Address(@global337), Need(@global338), Avail(@global339), Bytes(@global340), E(@global341), P(@global337)
__FileWrite336:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-12          ; Space
                add     hl,sp
                ld      sp,hl
; [474]   if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false343
                jp      exit342         ; Exit
false343:
; [475] 
; [476]   (* WriteLn('Wrote entry #', FileFilePos(F)); *)
; [477] 
; [478]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [479]   begin
; [480]     Address := Addr(Comp);
                push    de
                ld      hl,global337 + 0
                push    hl
                ld      hl,(display+2)  ; Local Comp
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                pop     hl
                ld      (hl),de
; [481]     Need := CompSize;
                ld      hl,global338 + 0
                push    hl
                ld      hl,(display+2)  ; Local CompSize
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,36
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [482] 
; [483]     while Need <> 0 do
while344:
                ld      hl,(global338 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [484]     begin
                bit     0,l
                jp      z,false345
; [485]       Avail := 128 - Offset;
                ld      hl,global339 + 0
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [486]       if Avail >= Need then
                ld      hl,(global339 + 0)
                push    hl
                ld      hl,(global338 + 0)
                ex      de,hl
                pop     hl
                call    __int16_geq
                ld      h,0
                ld      l,a
; [487]         Bytes := Need
                bit     0,l
                jp      z,false346
                ld      hl,global340 + 0
; [488]       else
                push    hl
                ld      hl,(global338 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
                jp      endif347
false346:
; [489]         Bytes := Avail;
                ld      hl,global340 + 0
                push    hl
                ld      hl,(global339 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
endif347:
; [490] 
; [491]       Move(P^, DMA[Offset], Bytes); (* Hmm... feels like a hack. *)
                ld      hl,global337 + 0
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(global340 + 0)
                ld      bc,hl
                pop     de
                pop     hl
                call    __move
; [492]       Inc(Address, Bytes);
                ld      hl,global337 + 0
                push    hl
                ld      hl,(global340 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [493]       Inc(Offset, Bytes);
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                push    hl
                ld      hl,(global340 + 0)
                ld      bc,hl
                pop     hl
                call    __inc16by
; [494]       Dec(Need, Bytes);
                ld      hl,global338 + 0
                push    hl
                ld      hl,(global340 + 0)
                ld      bc,hl
                pop     hl
                call    __dec16by
; [495]       Modified := True;
                ld      hl,(display+2)  ; Local Modified
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,44
                add     hl,de
                ld      de,1
                ld      (hl),e
; [496] 
; [497]       if Offset = 128 then
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_eq
                ld      h,0
                ld      l,a
; [498]       begin
                bit     0,l
                jp      z,false348
; [499]         FileFlush(F);
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush301
; Post call cleanup 2 bytes
                pop     hl
; [500]         if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false349
                jp      exit342         ; Exit
false349:
; [501] 
; [502]         if FileEof(F) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileEof298
; Post call cleanup 2 bytes
                pop     hl
; [503]         begin
                pop     hl
                bit     0,l
                jp      z,false350
; [504]           BlockSeek(FCB, FCB.RL + 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [505]           FillChar(DMA, 128, $FF);
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,128          ; Literal 128
                push    de
                ld      bc,255          ; Literal 255
                pop     de
                pop     hl
                call    __fillchar
; [506]         end
; [507]         else
                jp      endif351
false350:
; [508]           BlockSeek(FCB, FCB.RL + 1);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,33           ; Literal 33
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                push    hl
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
endif351:
; [509]           BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global341 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [510] 
; [511]         Offset := 0;
                ld      hl,(display+2)  ; Local Offset
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,42
                add     hl,de
                ld      de,0
                ld      (hl),de
; [512]       end;
false348:
; [513]     end;
                jp      while344
false345:
; [514] 
; [515]     if CompIndex = CompCount then Inc(CompCount);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                pop     hl
                call    __int16_eq
                and     a
                jp      z,false352
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                call    __inc16
false352:
; [516]     Inc(CompIndex);
                ld      hl,(display+2)  ; Local CompIndex
                ld      de,-14
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,40
                add     hl,de
                call    __inc16
; [517]   end;
                pop     bc
; [518] end;
exit342:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [519] 
; [520] procedure FileClose(var F: FileRec);
; [521] var
                if      __USE__FileClose353
; [522]   E: Integer;
global354:      ds      2,0             ; Global E
; [523] begin
; var F(+4), E(@global354)
__FileClose353:                         ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [524]   if LastError <> 0 then Exit;
                push    hl
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false356
                jp      exit355         ; Exit
false356:
; [525] 
; [526]   with F do
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
; [527]   begin
; [528]     FileFlush(F);
                push    de
                ld      hl,(display+2)  ; Local F
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __FileFlush301
; Post call cleanup 2 bytes
                pop     hl
; [529] 
; [530]     BlockSeek(FCB, 0);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [531]     BlockBlockRead(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global354 + 0
                push    hl
                call    __BlockBlockRead171
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [532] 
; [533]     if LastError <> 0 then Exit;
                ld      hl,const104 + 0
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __int16_neq0    ; Literal 0
                and     a
                jp      z,false357
                jp      exit355         ; Exit
false357:
; [534] 
; [535]     HdrCount := CompCount;
                ld      hl,(display+2)  ; Local HdrCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local CompCount
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,38
                add     hl,de
                ld      de,(hl)
                pop     hl
                ld      (hl),de
; [536] 
; [537]     (*WriteLn('File closing: ', CompCount, '*', CompCount, ' --- ', HdrCount, '*', HdrSize);
; [538]     ReadLn; *)
; [539] 
; [540]     BlockSeek(FCB, 0);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      de,0            ; Literal 0
                push    de
                call    __BlockSeek168
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [541]     BlockBlockWrite(FCB, DMA, 1, E);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local DMA
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,45
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      hl,global354 + 0
                push    hl
                call    __BlockBlockWrite181
; Post call cleanup 8 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [542]     BlockClose(FCB);
                ld      hl,(display+2)  ; Local FCB
                ld      de,-4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BlockClose157
; Post call cleanup 2 bytes
                pop     hl
; [543]   end;
                pop     bc
; [544]   (* WriteLn('Closed file'); *)
; [545] end;
exit355:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [513] 
; [514] end.
; [0] program Pebbles;
; [1] 
; [2] {$i bigint.pas }
; [0] {$L bigint.asm}
                include "/Users/joerg/Projects/NetBeans/aoc24/src/day11/bigint.asm"
; [1] 
; [2] type
; [3]   BigInt = array[0..7] of Byte;
; [4] 
; [5] const
; [6]   BigMin: BigInt = (0, 0, 0, 0, 0, 0, 0, 0);
const358:
                db      0,0,0,0,0,0,0,0
; [7]   BigMax: BigInt = (255, 255, 255, 255, 255, 255, 255, 127);
const359:
                db      255,255,255,255,255,255,255,127
; [8]   BigOne: BigInt = (1, 0, 0, 0, 0, 0, 0, 0);
const360:
                db      1,0,0,0,0,0,0,0
; [9]   BigTen: BigInt = (10, 0, 0, 0, 0, 0, 0, 0);
const361:
                db      10,0,0,0,0,0,0,0
; [10] 
; [11] procedure BigAdd(var X, Y: BigInt); register; external 'bigadd';
; [12] procedure BigSub(var X, Y: BigInt); register; external 'bigsub';
; [13] procedure BigMul(var X, Y: BigInt); register; external 'bigmul';
; [14] procedure BigDiv(var X, Y, Z: BigInt); register; external 'bigdiv';
; [15] 
; [16] function BigCmp(var X, Y: BigInt): Integer;
; [17] var
                if      __USE__BigCmp366
; [18]   I: Integer;
global367:      ds      2,0             ; Global I
; [19]   B: Byte;
global368:      ds      1,0             ; Global B
; [20] begin
; var BigCmp(@RESULT), X(+6), Y(+4), I(@global367), B(@global368)
__BigCmp366:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
; [21]   for B := 7 downto 0 do
                push    hl
                ld      hl,global368    ; Global B
                ld      de,7
                ld      (hl),e
                ld      de,0            ; Literal 0
                push    de
                push    de
                ld      hl,global368    ; Global B
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_geq
                and     a
                jp      z,forbreak371
forloop370:
; [22]   begin
; [23]     I := X[B] - Y[B];
                ld      hl,global367 + 0
                push    hl
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global368 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local Y
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global368 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [24]     if I <> 0 then
                ld      hl,(global367 + 0)
                call    __int16_neq0
                ld      h,0
                ld      l,a
; [25]     begin 
                bit     0,l
                jp      z,false373
; [26]       BigCmp := I; 
                ld      hl,(display+2)  ; Local BigCmp
                ld      de,8
                add     hl,de
                push    hl
                ld      hl,(global367 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),de
; [27]       Exit;
                jp      exit369         ; Exit
; [28]     end;
false373:
; [29]   end;
fornext372:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global368    ; Global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_lt
                and     a
                jp      z,forbreak371
                ld      hl,global368    ; Global B
                dec     (hl)
                jp      forloop370
forbreak371:    pop     de              ; Cleanup limit
; [30] 
; [31]   BigCmp := 0;
                ld      hl,(display+2)  ; Local BigCmp
                ld      de,8
                add     hl,de
                ld      de,0
                ld      (hl),de
; [32] end;
exit369:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [33] 
; [34] procedure BigVal(S: String; var X: BigInt);
; [35] var
                if      __USE__BigVal374
; [36]   B: Byte;
global375:      ds      1,0             ; Global B
; [37]   Y: BigInt;
global376:      ds      8,0             ; Global Y
; [38]   I, J: Integer;
global377:      ds      2,0             ; Global I
global378:      ds      2,0             ; Global J
; [39] begin
; var S(+6), X(+4), B(@global375), Y(@global376), I(@global377), J(@global378)
__BigVal374:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-14          ; Space
                add     hl,sp
                ld      sp,hl
; [40]   X := BigMin;
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const358 + 0
                ld      bc,8
                pop     de
                ldir
; [41] 
; [42]   if Length(S) < 3 then
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,3            ; Literal 3
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [43]   begin
                bit     0,l
                jp      z,false380
; [44]     Val(S, I, J);
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                ld      hl,global377 + 0
                push    hl
                ld      hl,global378 + 0
                push    hl
                call    __val_int
; [45]     X[0] := I;
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                push    hl
                ld      hl,(global377 + 0)
                ex      de,hl
                pop     hl
                ld      (hl),e
; [46]     Exit;
                jp      exit379         ; Exit
; [47]   end;
false380:
; [48] 
; [49]   Y := BigMin;
                ld      hl,global376 + 0
                push    hl
                ld      hl,const358 + 0
                ld      bc,8
                pop     de
                ldir
; [50] 
; [51]   for B := 1 to Length(S) do
                ld      hl,global375    ; Global B
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,global375    ; Global B
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak382
forloop381:
; [52]   begin
; [53]     BigMul(X, BigTen);
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const361 + 0
                ex      de,hl
                pop     hl
                call    bigmul
; [54]     Y[0] := Ord(S[B]) - 48;
                ld      hl,global376 + 0
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,global375 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,48           ; Literal 48
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [55]     BigAdd(X, Y); 
                ld      hl,(display+2)  ; Local X
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global376 + 0
                ex      de,hl
                pop     hl
                call    bigadd
; [56]   end;
fornext383:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global375    ; Global B
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak382
                ld      hl,global375    ; Global B
                inc     (hl)
                jp      forloop381
forbreak382:    pop     de              ; Cleanup limit
; [57] end;
exit379:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [58] 
; [59] procedure BigStr(X: BigInt; var S: String);
; [60] var
                if      __USE__BigStr384
; [61]   Y: BigInt;
global385:      ds      8,0             ; Global Y
; [62] begin
; var X(+6), S(+4), Y(@global385)
__BigStr384:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                push    hl
                push    hl
                push    hl
; [63]   S := '';
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ld      hl,string103
                ld      a,255
                call    __movestr
; [64] 
; [65]   repeat
repeat387:
; [66]     BigDiv(X, BigTen, Y);
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,const361 + 0
                push    hl
                ld      hl,global385 + 0
                ld      bc,hl
                pop     de
                pop     hl
                call    bigdiv
; [67]     S := '' + Char(48 + Y[0]) + S;
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,string103
                call    __loadstr
                ld      de,48           ; Literal 48
                push    de
                ld      hl,global385 + 0
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      hl,(display+2)  ; Local S
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                call    __loadstr
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
; [68]   until BigCmp(X, BigMin) = 0;
                push    hl
                ld      hl,(display+2)  ; Local X
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,const358 + 0
                push    hl
                call    __BigCmp366
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                and     a
                jp      z,repeat387
break388:
; [69] end;
exit386:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [3] 
; [4] type
; [5]   FileEntry = record
; [6]     Number: BigInt;
; [7]     Count:  BigInt;
; [8]   end;
; [9] 
; [10]   HashEntry = record
; [11]     Number: BigInt;
; [12]     Offset: Integer;
; [13]   end;
; [14] 
; [15] var  
; [16]   HashTable: array[0..4095] of HashEntry;
global389:      ds      40960,0         ; Global HashTable
; [17] 
; [18] procedure Clear;
; [19] var
                if      __USE__Clear390
; [20]   I: Integer;
global391:      ds      2,0             ; Global I
; [21] begin
; var I(@global391)
__Clear390:                             ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [22]   for I := 0 to 4095 do
                push    hl
                ld      hl,global391    ; Global I
                ld      de,0
                ld      (hl),de
                ld      de,4095         ; Literal 4095
                push    de
                push    de
                ld      hl,(global391)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak394
forloop393:
; [23]     HashTable[I].Offset := -1;
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global391 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                and     a
                sbc     hl,hl
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
fornext395:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global391)
                call    __int16_lt
                and     a
                jp      z,forbreak394
                ld      hl,global391    ; Global I
                call    __inc16
                jp      forloop393
forbreak394:    pop     de              ; Cleanup limit
; [24] end;
exit392:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [25] 
; [26] function Lookup(var Number: BigInt; var Entry: Integer): Boolean;
; [27] begin
                if      __USE__Lookup396
; var Lookup(@RESULT), Number(+6), Entry(+4)
__Lookup396:                            ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
; [28]   Entry := (Number[0] or (Number[1] shl 8)) mod 4096;
                ld      hl,(display+2)  ; Local Entry
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Number
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,(display+2)  ; Local Number
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      h,l             ; Literal 8
                ld      l,0
                ex      de,hl
                pop     hl
                ld      a,h
                or      d
                ld      h,a
                ld      a,l
                or      e
                ld      l,a
                ld      de,4096
                call    __sdiv16        ; Mod
                ex      hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [29]   while True do
while398:
                ld      de,1            ; Literal 1
; [30]   begin
                ex      de,hl
                bit     0,l
                jp      z,false399
; [31]     if HashTable[Entry].Offset = -1 then
                ld      hl,global389 + 0
                push    hl
                ld      hl,(display+2)  ; Local Entry
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                ld      de,(hl)
                push    de
                ld      de,1            ; Literal 1
                and     a
                sbc     hl,hl
                sbc     hl,de
                ex      de,hl
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
; [32]     begin
                bit     0,l
                jp      z,false400
; [33]       Lookup := False;
                ld      hl,(display+2)  ; Local Lookup
                ld      de,8
                add     hl,de
                ld      de,0
                ld      (hl),e
; [34]       Exit;
                jp      exit397         ; Exit
; [35]     end;
false400:
; [36] 
; [37]     if BigCmp(HashTable[Entry].Number, Number) = 0 then
                push    hl
                ld      hl,global389 + 0
                push    hl
                ld      hl,(display+2)  ; Local Entry
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local Number
                ld      de,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                call    __BigCmp366
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
; [38]     begin
                bit     0,l
                jp      z,false401
; [39]       Lookup := True;
                ld      hl,(display+2)  ; Local Lookup
                ld      de,8
                add     hl,de
                ld      de,1
                ld      (hl),e
; [40]       Exit;
                jp      exit397         ; Exit
; [41]     end;
false401:
; [42]     
; [43]     Entry := (Entry + 1) mod 4096;
                ld      hl,(display+2)  ; Local Entry
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+2)  ; Local Entry
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ld      de,4096
                call    __sdiv16        ; Mod
                ex      hl,de
                ex      de,hl
                pop     hl
                ld      (hl),de
; [44]   end;
                jp      while398
false399:
; [45] end;
exit397:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [46] 
; [47] function IntToStr(I: Integer): String;
; [48] var
                if      __USE__IntToStr402
; [49]   S: String;
; [50] begin
; var IntToStr(@RESULT), I(+4), S(-256)
__IntToStr402:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                call    __mkstr
; [51]   Str(I, S);
                ld      hl,(display+2)  ; Local I
                ld      de,4
                add     hl,de
                ld      de,(hl)
                push    de
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                push    hl
                ld      a,255
                pop     de
                pop     hl
                call    __strn
; [52]   IntToStr := S;
                ld      hl,(display+2)  ; Local IntToStr
                ld      de,6
                add     hl,de
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,-256
                add     hl,de
                pop     de
                ld      a,255
                call    __movestr
; [53] end;
exit403:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [54] 
; [55] procedure Simulate(Step: Integer; var Total: BigInt);
; [56] var
                if      __USE__Simulate404
; [57]   InFile, OutFile: file of FileEntry;
; [58]   Entry: FileEntry;
global405:      ds      16,0            ; Global Entry
; [59]   Left, Right, Big2024: BigInt;
global406:      ds      8,0             ; Global Left
global407:      ds      8,0             ; Global Right
global408:      ds      8,0             ; Global Big2024
; [60]   S, T: String;
; [61]   P: Integer;
global409:      ds      2,0             ; Global P
; [62] 
; [63]   procedure AddStones(Number, Count: BigInt);
; [64]   var
; [65]     Entry: FileEntry;
global411:      ds      16,0            ; Global Entry
; [66]     S, T: String;
; [67]     Index: Integer;
global412:      ds      2,0             ; Global Index
; [68]   begin
; var Number(+12), Count(+4), Entry(@global411), S(-272), T(-528), Index(@global412)
__AddStones410:                         ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      (display+4),sp
                ld      hl,-530         ; Space
                add     hl,sp
                ld      sp,hl
; [69]     BigStr(Number, S);
                ld      hl,(display+4)  ; Local Number
                ld      de,12
                add     hl,de
                ld      bc,8
                call    __load16
                ld      hl,(display+4)  ; Local S
                ld      de,-272
                add     hl,de
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [70]     BigStr(Count, T);
                ld      hl,(display+4)  ; Local Count
                ld      de,4
                add     hl,de
                ld      bc,8
                call    __load16
                ld      hl,(display+4)  ; Local T
                ld      de,-528
                add     hl,de
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [71] 
; [72]     WriteLn('Writing: ', T, ' x ', S);
                ld      hl,string414
                call    __puts
                ld      hl,(display+4)  ; Local T
                ld      de,-528
                add     hl,de
                call    __puts
                ld      hl,string415
                call    __puts
                ld      hl,(display+4)  ; Local S
                ld      de,-272
                add     hl,de
                call    __puts
                call    __newline
; [73] 
; [74]     if Lookup(Number, Index) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(display+4)  ; Local Number
                ld      de,12
                add     hl,de
                push    hl
                ld      hl,global412 + 0
                push    hl
                call    __Lookup396
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [75]     begin
                pop     hl
                bit     0,l
                jp      z,false416
; [76]       Seek(OutFile, HashTable[Index].Offset);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global412 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    __FileSeek307
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [77]       Read(OutFile, Entry);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global411 + 0
                push    hl
                call    __FileRead320
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [78]       BigAdd(Entry.Count, Count);
                ld      hl,global411 + 8
                push    hl
                ld      hl,(display+4)  ; Local Count
                ld      de,4
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [79]       Seek(OutFile, HashTable[Index].Offset);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global412 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                ld      de,(hl)
                push    de
                call    __FileSeek307
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [80]       Write(OutFile, Entry);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global411 + 0
                push    hl
                call    __FileWrite336
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [81]     end
; [82]     else
                jp      endif417
false416:
; [83]     begin
; [84]       HashTable[Index].Number := Number;
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global412 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      hl,(display+4)  ; Local Number
                ld      de,12
                add     hl,de
                ld      bc,8
                pop     de
                ldir
; [85]       HashTable[Index].Offset := FileSize(OutFile);
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global412 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                push    hl
                push    de
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                call    __FileFileSize292
; Post call cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),de
; [86] 
; [87]       WriteLn('New entry offset is ', HashTable[Index].Offset);
                ld      hl,string418
                call    __puts
                ld      hl,global389 + 0
                push    hl
                ld      hl,(global412 + 0)
                ld      de,10
                call    __mul16         ; Mul
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,8
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                call    __newline
; [88]       
; [89]       Entry.Number := Number;
                ld      hl,global411 + 0
                push    hl
                ld      hl,(display+4)  ; Local Number
                ld      de,12
                add     hl,de
                ld      bc,8
                pop     de
                ldir
; [90]       Entry.Count := Count;
                ld      hl,global411 + 8
                push    hl
                ld      hl,(display+4)  ; Local Count
                ld      de,4
                add     hl,de
                ld      bc,8
                pop     de
                ldir
; [91]       Seek(OutFile, FileSize(OutFile));
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                push    de
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                call    __FileFileSize292
; Post call cleanup 2 bytes
                pop     hl
                call    __FileSeek307
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [92]       Write(OutFile, Entry);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global411 + 0
                push    hl
                call    __FileWrite336
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [93]     end;
endif417:
; [94] 
; [95]     BigAdd(Total, Count);
                ld      hl,(display+2)  ; Local Total
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(display+4)  ; Local Count
                ld      de,4
                add     hl,de
                ex      de,hl
                pop     hl
                call    bigadd
; [96]   end;
exit413:        ld      sp,(display+4)  ; Epilogue
                pop     hl
                ld      (display+4),hl
                ret
; [97]   
; [98] begin
; var Step(+6), Total(+4), InFile(-256), OutFile(-512), Entry(@global405), Left(@global406), Right(@global407), Big2024(@global408), S(-808), T(-1064), P(@global409)
__Simulate404:                          ; Prologue
                ld      hl,(display+2)
                push    hl
                ld      (display+2),sp
                ld      hl,-1066        ; Space
                add     hl,sp
                ld      sp,hl
; [99]   WriteLn('--- Step ', Step, ' ---');
                ld      hl,string420
                call    __puts
                ld      hl,(display+2)  ; Local Step
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                call    __putn
                ld      hl,string421
                call    __puts
                call    __newline
; [100]   
; [101]   Assign(InFile, 'step-' + IntToStr(Step - 1) + '.tmp');
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                push    hl
                ld      hl,string422
                call    __loadstr
                call    __mkstr
                ld      hl,(display+2)  ; Local Step
                ld      de,6
                add     hl,de
                ld      de,(hl)
                ex      de,hl
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                push    hl
                call    __IntToStr402
; Post call cleanup 2 bytes
                pop     hl
                call    __stradd
                call    __rmstr
                ld      hl,string423
                call    __loadstr
                call    __stradd
                call    __rmstr
                ld      de,16           ; Literal 16
                push    de
                call    __FileAssign276
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
; [102]   Reset(InFile);
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                push    hl
                call    __FileReset279
; Post call cleanup 2 bytes
                pop     hl
; [103]   
; [104]   Assign(OutFile, 'step-' + IntToStr(Step) + '.tmp');
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                ld      hl,string422
                call    __loadstr
                call    __mkstr
                ld      hl,(display+2)  ; Local Step
                ld      de,6
                add     hl,de
                ld      de,(hl)
                push    de
                call    __IntToStr402
; Post call cleanup 2 bytes
                pop     hl
                call    __stradd
                call    __rmstr
                ld      hl,string423
                call    __loadstr
                call    __stradd
                call    __rmstr
                ld      de,16           ; Literal 16
                push    de
                call    __FileAssign276
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
; [105]   Rewrite(OutFile);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                call    __FileRewrite286
; Post call cleanup 2 bytes
                pop     hl
; [106] 
; [107]   Clear;
                call    __Clear390
; [108]   BigVal('2024', Big2024);
                ld      hl,string424
                call    __loadstr
                ld      hl,global408 + 0
                push    hl
                call    __BigVal374
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [109]   Total := BigMin;
                ld      hl,(display+2)  ; Local Total
                ld      de,4
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const358 + 0
                ld      bc,8
                pop     de
                ldir
; [110] 
; [111]   while not Eof(InFile) do
while425:
                push    de
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                push    hl
                call    __FileEof298
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [112]   begin
                bit     0,l
                jp      z,false426
; [113]     WriteLn(FilePos(InFile));
                push    de
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                push    hl
                call    __FileFilePos295
; Post call cleanup 2 bytes
                pop     hl
                pop     hl
                call    __putn
                call    __newline
; [114]     Read(InFile, Entry);
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global405 + 0
                push    hl
                call    __FileRead320
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [115] 
; [116]     with Entry do
                ld      hl,global405 + 0
; [117]     begin
; [118]       BigStr(Number, S);
                push    hl
                ld      hl,(display+2)  ; Local Number
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [119]       BigStr(Count, T);
                ld      hl,(display+2)  ; Local Count
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,8
                add     hl,de
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local T
                ld      de,-1064
                add     hl,de
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [120] 
; [121]       WriteLn('Reading: ', T, ' x ', S);
                ld      hl,string427
                call    __puts
                ld      hl,(display+2)  ; Local T
                ld      de,-1064
                add     hl,de
                call    __puts
                ld      hl,string415
                call    __puts
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                call    __puts
                call    __newline
; [122] 
; [123]       if BigCmp(Number, BigMin) = 0 then
                push    hl
                ld      hl,(display+2)  ; Local Number
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,const358 + 0
                push    hl
                call    __BigCmp366
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_eq
                ld      h,0
                ld      l,a
; [124]       begin
                bit     0,l
                jp      z,false428
; [125]         AddStones(BigOne, Count);
                ld      hl,const360 + 0
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local Count
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,8
                add     hl,de
                ld      bc,8
                call    __load16
                call    __AddStones410
; Post call cleanup 16 bytes
                ld      hl,16           ; Clear
                add     hl,sp
                ld      sp,hl
; [126]         Continue;
                jp      while425        ; Continue
; [127]       end;
false428:
; [128] 
; [129]       if not Odd(Length(S)) then
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     hl              ; Odd
                ld      a,l
                and     1
                ld      l,a
                ld      h,0
                ld      a,1
                xor     l
                ld      l,a
; [130]       begin
                bit     0,l
                jp      z,false429
; [131]         P := Length(S) div 2;
                ld      hl,global409 + 0
                push    hl
                push    hl
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,2            ; Literal 2
                pop     hl
                call    __sdiv16        ; Div
                ex      de,hl
                pop     hl
                ld      (hl),de
; [132]         BigVal(Copy(S, 1, P), Left);
                call    __mkstr
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                call    __loadstr
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global409 + 0)
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,global406 + 0
                push    hl
                call    __BigVal374
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [133]         BigVal(Copy(S, P + 1, 255), Right);
                call    __mkstr
                ld      hl,(display+2)  ; Local S
                ld      de,-808
                add     hl,de
                call    __loadstr
                ld      hl,(global409 + 0)
                inc     hl
                push    hl
                ld      de,255          ; Literal 255
                push    de
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,global407 + 0
                push    hl
                call    __BigVal374
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [134]         AddStones(Left, Count);
                ld      hl,global406 + 0
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local Count
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,8
                add     hl,de
                ld      bc,8
                call    __load16
                call    __AddStones410
; Post call cleanup 16 bytes
                ld      hl,16           ; Clear
                add     hl,sp
                ld      sp,hl
; [135]         AddStones(Right, Count);
                ld      hl,global407 + 0
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local Count
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,8
                add     hl,de
                ld      bc,8
                call    __load16
                call    __AddStones410
; Post call cleanup 16 bytes
                ld      hl,16           ; Clear
                add     hl,sp
                ld      sp,hl
; [136]         Continue;
                jp      while425        ; Continue
; [137]       end;
false429:
; [138] 
; [139]       BigMul(Number, Big2024);
                ld      hl,(display+2)  ; Local Number
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global408 + 0
                ex      de,hl
                pop     hl
                call    bigmul
; [140]       AddStones(Number, Count);
                ld      hl,(display+2)  ; Local Number
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      bc,8
                call    __load16
                ld      hl,(display+2)  ; Local Count
                ld      de,-1068
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,8
                add     hl,de
                ld      bc,8
                call    __load16
                call    __AddStones410
; Post call cleanup 16 bytes
                ld      hl,16           ; Clear
                add     hl,sp
                ld      sp,hl
; [141]     end;
                pop     bc
; [142]   end;
                jp      while425
false426:
; [143] 
; [144]   Close(OutFile);
                ld      hl,(display+2)  ; Local OutFile
                ld      de,-512
                add     hl,de
                push    hl
                call    __FileClose353
; Post call cleanup 2 bytes
                pop     hl
; [145]   Close(InFile);
                ld      hl,(display+2)  ; Local InFile
                ld      de,-256
                add     hl,de
                push    hl
                call    __FileClose353
; Post call cleanup 2 bytes
                pop     hl
; [146] end;
exit419:        ld      sp,(display+2)  ; Epilogue
                pop     hl
                ld      (display+2),hl
                ret
                endif
; [147] 
; [148] var
; [149]   Puzzle: Text;
global430:      ds      256,0           ; Global Puzzle
; [150]   IniFile: file of FileEntry;
global431:      ds      256,0           ; Global IniFile
; [151]   Entry: FileEntry;
global432:      ds      16,0            ; Global Entry
; [152]   Part1, Part2: BigInt;
global433:      ds      8,0             ; Global Part1
global434:      ds      8,0             ; Global Part2
; [153]   S: String;
global435:      ds      256,0           ; Global S
; [154]   I: Integer;
global436:      ds      2,0             ; Global I
; [155]   
; [156] begin
; var BigMin(@const358), BigMax(@const359), BigOne(@const360), BigTen(@const361), HashTable(@global389), Puzzle(@global430), IniFile(@global431), Entry(@global432), Part1(@global433), Part2(@global434), S(@global435), I(@global436)
main:
                ld      (display),sp
                call    __InitHeap20
; [157]   Assign(Puzzle, ParamStr(1));
                ld      hl,global430 + 0
                push    hl
                call    __mkstr
                ld      de,1            ; Literal 1
                push    de
                call    __ParamStr88
; Post call cleanup 2 bytes
                pop     hl
                call    __TextAssign189
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [158]   Reset(Puzzle);
                ld      hl,global430 + 0
                push    hl
                call    __TextReset191
; Post call cleanup 2 bytes
                pop     hl
; [159]   ReadLn(Puzzle, S);
                ld      hl,global430 + 0
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global435 + 0
                push    hl
                call    __TextReadStr205
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [160]   Close(Puzzle);
                ld      hl,global430 + 0
                push    hl
                call    __TextClose242
; Post call cleanup 2 bytes
                pop     hl
; [161] 
; [162]   Entry.Count := BigOne;
                ld      hl,global432 + 8
                push    hl
                ld      hl,const360 + 0
                ld      bc,8
                pop     de
                ldir
; [163] 
; [164]   Assign(IniFile, 'step-0.tmp');
                ld      hl,global431 + 0
                push    hl
                ld      hl,string438
                call    __loadstr
                ld      de,16           ; Literal 16
                push    de
                call    __FileAssign276
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
; [165]   Rewrite(IniFile);
                ld      hl,global431 + 0
                push    hl
                call    __FileRewrite286
; Post call cleanup 2 bytes
                pop     hl
; [166] 
; [167]   S := S + ' ';
                ld      hl,global435 + 0
                push    hl
                ld      hl,global435 + 0
                call    __loadstr
                ld      de,32           ; Literal 32
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
; [168]   I := 1;
                ld      hl,global436 + 0
                ld      de,1
                ld      (hl),de
; [169]   while Length(S) <> 0 do
while439:
                push    hl
                ld      hl,global435 + 0
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,0            ; Literal 0
                pop     hl
                call    __int16_neq
                ld      h,0
                ld      l,a
; [170]   begin
                bit     0,l
                jp      z,false440
; [171]     WriteLn(S);
                ld      hl,global435 + 0
                call    __puts
                call    __newline
; [172]     
; [173]     I := Pos(' ', S);
                ld      hl,global436 + 0
                push    hl
                push    hl
                ld      de,32           ; Literal 32
                call    __char2str
                ld      hl,global435 + 0
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),de
; [174]     BigVal(Copy(S, 1, I - 1), Entry.Number);
                call    __mkstr
                ld      hl,global435 + 0
                call    __loadstr
                ld      de,1            ; Literal 1
                push    de
                ld      hl,(global436 + 0)
                ld      de,1
                xor     a
                sbc     hl,de
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      hl,global432 + 0
                push    hl
                call    __BigVal374
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [175]     Write(IniFile, Entry);
                ld      hl,global431 + 0
                ld      (__cur_file),hl
                ld      hl,(__cur_file)
                push    hl
                ld      hl,global432 + 0
                push    hl
                call    __FileWrite336
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [176]     S := Copy(S, I + 1, 255);
                ld      hl,global435 + 0
                push    hl
                call    __mkstr
                ld      hl,global435 + 0
                call    __loadstr
                ld      hl,(global436 + 0)
                inc     hl
                push    hl
                ld      de,255          ; Literal 255
                push    de
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
; [177]   end;
                jp      while439
false440:
; [178] 
; [179]   Close(IniFile);
                ld      hl,global431 + 0
                push    hl
                call    __FileClose353
; Post call cleanup 2 bytes
                pop     hl
; [180] 
; [181] //  Part1 := BigMin;
; [182] //  Simulate(1, Part1);
; [183] //  BigStr(Part1, S);
; [184] //  WriteLn('Part 1: ', S);
; [185] 
; [186] //  Halt;
; [187]   
; [188]   for I := 1 to 6 do
                ld      hl,global436    ; Global I
                ld      de,1
                ld      (hl),de
                ld      de,6            ; Literal 6
                push    de
                push    de
                ld      hl,(global436)  ; Global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak442
forloop441:
; [189]     Simulate(I, Part1);
                ld      hl,(global436 + 0)
                push    hl
                ld      hl,global433 + 0
                push    hl
                call    __Simulate404
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
fornext443:
                pop     de              ; Dup and check limit
                push    de
                ld      hl,(global436)
                call    __int16_lt
                and     a
                jp      z,forbreak442
                ld      hl,global436    ; Global I
                call    __inc16
                jp      forloop441
forbreak442:    pop     de              ; Cleanup limit
; [190] 
; [191] //  for I := 26 to 75 do
; [192] //  begin
; [193] //    Part2 := BigMin;
; [194] //    Simulate(I, Part2);
; [195] //  end;
; [196] 
; [197]   BigStr(Part1, S);
                ld      hl,global433 + 0
                ld      bc,8
                call    __load16
                ld      hl,global435 + 0
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [198]   WriteLn('Part 1: ', S);
                ld      hl,string444
                call    __puts
                ld      hl,global435 + 0
                call    __puts
                call    __newline
; [199]   BigStr(Part2, S);
                ld      hl,global434 + 0
                ld      bc,8
                call    __load16
                ld      hl,global435 + 0
                push    hl
                call    __BigStr384
; Post call cleanup 10 bytes
                pop     hl
                pop     hl
                pop     hl
                pop     hl
                pop     hl
; [200]   WriteLn('Part 2: ', S); 
                ld      hl,string445
                call    __puts
                ld      hl,global435 + 0
                call    __puts
                call    __newline
; [201] end.
                ret
string54:       db      2,13,10
string103:      db      0
string115:      db      11,"BDos error "
string177:      db      16,"Reading record #"
string178:      db      8," of FCB "
string187:      db      16,"Writing record #"
string285:      db      17,"Invalid file type"
string314:      db      4,"*** "
string315:      db      3," > "
string414:      db      9,"Writing: "
string415:      db      3," x "
string418:      db      20,"New entry offset is "
string420:      db      9,"--- Step "
string421:      db      4," ---"
string422:      db      5,"step-"
string423:      db      4,".tmp"
string424:      db      4,"2024"
string427:      db      9,"Reading: "
string438:      db      10,"step-0.tmp"
string444:      db      8,"Part 1: "
string445:      db      8,"Part 2: "
display:        ds      16,0            ; Display
eof:                                    ; End of file
__USE__Simulate404:equ     1
__USE__IntToStr402:equ     1
__USE__Lookup396:equ     1
__USE__Clear390:equ     1
__USE__BigStr384:equ     1
__USE__BigVal374:equ     1
__USE__BigCmp366:equ     1
__USE__FileClose353:equ     1
__USE__FileWrite336:equ     1
__USE__FileRead320:equ     1
__USE__FileSeek307:equ     1
__USE__FileFlush301:equ     1
__USE__FileEof298:equ     1
__USE__FileFilePos295:equ     1
__USE__FileFileSize292:equ     1
__USE__FileRewrite286:equ     1
__USE__FileReset279:equ     1
__USE__FileAssign276:equ     1
__USE__TextAppend273:equ     0
__USE__TextSeekEoln267:equ     0
__USE__TextSeekEof260:equ     0
__USE__TextEof258:equ     0
__USE__TextEoln256:equ     0
__USE__TextWriteEoln254:equ     0
__USE__TextWriteStr247:equ     0
__USE__TextClose242:equ     1
__USE__TextFlush237:equ     1
__USE__TextWriteChar232:equ     1
__USE__TextReadFloat228:equ     0
__USE__TextReadInt224:equ     0
__USE__TextReadWord216:equ     0
__USE__TextReadStr205:equ     1
__USE__TextReadChar198:equ     1
__USE__TextRewrite195:equ     0
__USE__TextReset191:equ     1
__USE__TextAssign189:equ     1
__USE__BlockBlockWrite181:equ     1
__USE__BlockBlockRead171:equ     1
__USE__BlockSeek168:equ     1
__USE__BlockEof165:equ     0
__USE__BlockFileSize161:equ     0
__USE__BlockFilePos159:equ     0
__USE__BlockClose157:equ     1
__USE__BlockRewrite153:equ     1
__USE__BlockReset149:equ     1
__USE__BlockRename144:equ     0
__USE__BlockErase140:equ     0
__USE__BlockAssign116:equ     1
__USE__BDosThrow112:equ     0
__USE__BDosCatch107:equ     1
__USE__IOResult105:equ     0
__USE__ParamStr88:equ     1
__USE__ParamCount78:equ     0
__USE__Delay75: equ     0
__USE__ReadKey71:equ     0
__USE__KeyPressed69:equ     0
__USE__InitHeap20:equ     1
__USE__MaxAvail13:equ     0
__USE__MemAvail7:equ     0
HEAP:
; end
                savebin "pebbles.com",$0100,HEAP-$0100
