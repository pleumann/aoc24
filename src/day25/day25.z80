; program day25.pas
CPM:            equ     1               ; Target is CP/M .com file
                include "/Users/joerg/Projects/pl0/pl0.z80"
                jp      main
; [0] (* Built-ins that do not have to be defined in the compiler itself. *)
; [1] 
; [2] (* -------------------------------------------------------------------------- *)
; [3] (* --- String support ------------------------------------------------------- *)
; [4] (* -------------------------------------------------------------------------- *)
; [5] 
; [6] (* Built-in: procedure Val(S: String; var Scalar; var E: Integer); *)
; [7] (* Built-in: procedure Str(N: Scalar; var S: String);              *)
; [8] 
; [9] procedure Delete(var S: String; Start, Count: Integer);     external '__delete';
; [10] procedure Insert(S: String; var T: String; Start: Integer); external '__insert';
; [11] 
; [12] (* Built-in: function Concat(S: String, ...): String;              *)
; [13] 
; [14] function Copy(S: String; Start, Count: Integer): String;    external '__copy';
; [15] function Length(S: String): Integer;                        external '__length';
; [16] function Pos(S, T: String): Integer;                        external '__pos';
; [17] 
; [18] (* -------------------------------------------------------------------------- *)
; [19] (* --- Set support ---------------------------------------------------------- *)
; [20] (* -------------------------------------------------------------------------- *)
; [21] 
; [22] (* Built-in: procedure Include(var S: Set; E: Element);     *)
; [23] (* Built-in: procedure Exclude(var S: Set; E: Element);     *)
; [24] 
; [25] (* -------------------------------------------------------------------------- *)
; [26] (* --- File support --------------------------------------------------------- *)
; [27] (* -------------------------------------------------------------------------- *)
; [28] 
; [29] (* TBD *)
; [30] 
; [31] (* -------------------------------------------------------------------------- *)
; [32] (* --- Heap management ------------------------------------------------------ *)
; [33] (* -------------------------------------------------------------------------- *)
; [34] 
; [35] type
; [36]   PBlock = ^TBlock;
; [37]   TBlock = record
; [38]     Next: PBlock;
; [39]     Size: Integer;
; [40]   end;
; [41] 
; [42] var
; [43]   HeapPtr: PBlock absolute '__heapptr';
; [44] 
; [45] (* Built-in: procedure New(var P: Pointer);       *)
; [46] (* Built-in: procedure Dispose(P: Pointer);       *)
; [47] 
; [48] procedure FreeMem(P: Pointer; Size: Integer);     register; external '__freemem';
; [49] procedure GetMem(var P: Pointer; Size: Integer);  register; external '__getmem';
; [50] 
; [51] function MemAvail: Integer;
; [52] var
; [53]   P: PBlock;
; [54]   I: Integer;
; [55] begin
; var MemAvail(+6), P(-2), I(-4)
func7:          push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [56]   P := HeapPtr;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      hl,(__heapptr)  ; Get global HeapPtr
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [57]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [58]   while P <> nil do
while9:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [59]   begin
                bit     0,l
                jp      z,false10
; [60]     I := I + P^.Size;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [61]     P := P^.Next;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [62]   end;
                jp      while9
false10:
; [63] 
; [64]   MemAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [65] end;
exit8:          ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [66] 
; [67] function MaxAvail: Integer;
; [68] var
; [69]   P: PBlock;
; [70]   I: Integer;
; [71] begin
; var MaxAvail(+6), P(-2), I(-4)
func11:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [72]   P := HeapPtr;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      hl,(__heapptr)  ; Get global HeapPtr
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [73]   I := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [74]   while P <> nil do
while13:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [75]   begin
                bit     0,l
                jp      z,false14
; [76]     if P^.Size > I then I := P^.Size;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,false15
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false15:
; [77]     P := P^.Next;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [78]   end;
                jp      while13
false14:
; [79] 
; [80]   MaxAvail := I;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [81] end;
exit12:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [82] 
; [83] procedure InitHeap(Bytes: Integer);
; [84] var
; [85]   P: Pointer;
; [86] begin
; var Bytes(+6), P(-2)
proc16:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [87]   HeapPtr := nil;
                push    hl
                ld      hl,__heapptr    ; Get global HeapPtr
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [88]   P := Ptr(32768); (* GetHeapStart; *)
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,32768
                ld      (hl),e \ inc hl \ ld (hl),d
; [89]   FreeMem(P, Bytes);
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                call    __freemem
; [90] end;
exit17:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [91] 
; [92] (* -------------------------------------------------------------------------- *)
; [93] (* --- Standard procedures -------------------------------------------------- *)
; [94] (* -------------------------------------------------------------------------- *)
; [95] 
; [96] (* Built-in: procedure Break;                   *)
; [97] (* Built-in: procedure Continue;                *)
; [98] (* Built-in: procedure Exit;                    *)
; [99] 
; [100] procedure ClrScr; register;                 external '__clrscr';
; [101] procedure GotoXY(X, Y: Integer); register;  external '__gotoxy';
; [102] procedure CursorOn; register;               external '__cursor_on';
; [103] procedure CursorOff; register;              external '__cursor_off';
; [104] 
; [105] procedure ConOut(C: Char); register;        external '__conout';
; [106] 
; [107] procedure ClrEol; register; inline
proc23:
; [108] (
; [109]   $2e /                       (* ld   l,27      *)
                db      46
; [110]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [111]   $3e / 'K' /                 (* ld   l,'K'     *)
                db      62,75
; [112]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [113]   $c9                         (* ret            *)
; [114] );
                db      201
                ret
; [115] 
; [116] procedure ClrEos; register; inline
proc24:
; [117] (
; [118]   $2e /                       (* ld   l,27      *)
                db      46
; [119]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [120]   $3e / 'J' /                 (* ld   l,'J'     *)
                db      62,74
; [121]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [122]   $c9                         (* ret            *)
; [123] );
                db      201
                ret
; [124] 
; [125] procedure InsLine; register; inline
proc25:
; [126] (
; [127]   $2e /                       (* ld   l,27      *)
                db      46
; [128]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [129]   $3e / 'L' /                 (* ld   l,'L'     *)
                db      62,76
; [130]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [131]   $c9                         (* ret            *)
; [132] );
                db      201
                ret
; [133] 
; [134] procedure DelLine; register; inline
proc26:
; [135] (
; [136]   $2e /                       (* ld   l,27      *)
                db      46
; [137]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [138]   $3e / 'M' /                 (* ld   l,'M'     *)
                db      62,77
; [139]   $cd / ConOut /              (* call ConOut    *)
                db      205
                dw      __conout
; [140]   $c9                         (* ret            *)
; [141] );
                db      201
                ret
; [142] 
; [143] procedure TextColor(I: Integer); register;      external '__textfg';
; [144] procedure TextBackground(I: Integer); register; external '__textbg';
; [145] 
; [146] (* -------------------------------------------------------------------------- *)
; [147] (* --- Arithmetic functions ------------------------------------------------- *)
; [148] (* -------------------------------------------------------------------------- *)
; [149] 
; [150] {$A math48.z80}
; [151] 
; [152] const
; [153]   MaxInt = 32767;
; [154]   MinInt = -32768;
; [155] 
; [156] (* Built-in: function Abs(I: Integer): Integer  *)
; [157] (* Built-in: function Abs(R: Real): Real        *)
; [158] 
; [159] function ArcTan(R: Real): Real; register; external 'ATN';
; [160] function Cos(R: Real): Real; register;    external 'COS';
; [161] function Exp(R: Real): Real; register;    external 'EXP';
; [162] function Frac(R: Real): Real; register;   external 'FRAC';
; [163] function Int(R: Real): Real; register;    external 'INT';
; [164] function Ln(R: Real): Real; register;     external 'LN';
; [165] function Log(R: Real): Real; register;    external 'LOG';
; [166] function Sin(R: Real): Real; register;    external 'SIN';
; [167] function Sqr(R: Real): Real; register;    external '__fltpwr2';
; [168] function Sqrt(R: Real): Real; register;   external 'SQR';
; [169] function Tan(R: Real): Real; register;    external 'TAN';
; [170] 
; [171] function Pi: Real; register;              external 'ACPI';
; [172] 
; [173] function MaxReal: Real; register; inline
func41:
; [174] (
; [175]   $01 / $7FFF /
                db      1
                dw      32767
; [176]   $11 / $FFFF /
                db      17
                dw      65535
; [177]   $21 / $FFFF /
                db      33
                dw      65535
; [178]   $c9
; [179] );
                db      201
                ret
; [180] 
; [181] function MinReal: Real; register; inline
func42:
; [182] (
; [183]   $01 / $FFFF /
                db      1
                dw      65535
; [184]   $11 / $FFFF /
                db      17
                dw      65535
; [185]   $21 / $FFFF /
                db      33
                dw      65535
; [186]   $c9
; [187] );
                db      201
                ret
; [188] 
; [189] (* -------------------------------------------------------------------------- *)
; [190] (* --- Scalar functions ----------------------------------------------------- *)
; [191] (* -------------------------------------------------------------------------- *)
; [192] 
; [193] (* Built-in: function Pred(Ordinal): Ordinal;     *)
; [194] (* Built-in: function Succ(Ordinal): Ordinal;     *)
; [195] (* Built-in: function Odd(Ordinal): Boolean;      *)
; [196] (* Built-in: function Even(Ordinal): Boolean;     *)
; [197] 
; [198] (* -------------------------------------------------------------------------- *)
; [199] (* --- Transfer functions --------------------------------------------------- *)
; [200] (* -------------------------------------------------------------------------- *)
; [201] 
; [202] (* Built-in: function Ord(Ordinal): Integer;      *)
; [203] 
; [204] function Round(R: Real): Integer; register; external '__fltrnd';
; [205] function Trunc(R: Real): Integer; register; external 'FIX';
; [206] 
; [207] function Chr(B: Byte): Char; register; inline
func45:
; [208] (
; [209]   $c9         (* ret          *)
; [210] );
                db      201
                ret
; [211] 
; [212] (* -------------------------------------------------------------------------- *)
; [213] (* --- Miscellaneous standard functions ------------------------------------- *)
; [214] (* -------------------------------------------------------------------------- *)
; [215] 
; [216] (* Built-in: function KeyPressed: Boolean;        *)
; [217] (* Built-in: function SizeOf(XYZ): Integer;       *)
; [218] (* Built-in: function Addr(XYZ): Integer;         *)
; [219] (* Built-in: function Ptr(I: Integer): Pointer;   *)
; [220] 
; [221] function Hi(I: Integer): Byte; register; inline
func46:
; [222] (
; [223]   $6c /       (* ld   l,h     *)
                db      108
; [224]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [225]   $c9         (* ret          *)
; [226] );
                db      201
                ret
; [227] 
; [228] function Lo(I: Integer): Byte; register; inline
func47:
; [229] (
; [230]   $26 / $00 / (* ld   h,0     *)
                db      38,0
; [231]   $c9         (* ret          *)
; [232] );
                db      201
                ret
; [233] 
; [234] function Swap(I: Integer): Integer; register; inline
func48:
; [235] (
; [236]   $7c /       (* ld   a,h     *)
                db      124
; [237]   $65 /       (* ld   h,l     *)
                db      101
; [238]   $6f /       (* ld   l,a     *)
                db      111
; [239]   $c9         (* ret          *)
; [240] );
                db      201
                ret
; [241] 
; [242] function UpCase(C: Char): Char; register; inline
func49:
; [243] (
; [244]   $7d /       (* ld   a,l     *)
                db      125
; [245]   $fe / $61 / (* cp   'a'     *)
                db      254,97
; [246]   $d8 /       (* ret  c       *)
                db      216
; [247]   $fe / $7b / (* cp   'z' + 1 *)
                db      254,123
; [248]   $d0 /       (* ret  nc      *)
                db      208
; [249]   $cb / $ad / (* res  4,l     *)
                db      203,173
; [250]   $c9         (* ret          *)
; [251] );
                db      201
                ret
; [252] 
; [253] function LoCase(C: Char): Char; register; inline
func50:
; [254] (
; [255]   $7d /       (* ld   a,l     *)
                db      125
; [256]   $fe / $41 / (* cp   'A'     *)
                db      254,65
; [257]   $d8 /       (* ret  c       *)
                db      216
; [258]   $fe / $5b / (* cp   'Z' + 1 *)
                db      254,91
; [259]   $d0 /       (* ret  nc      *)
                db      208
; [260]   $cb / $ed / (* set  4,l     *)
                db      203,237
; [261]   $c9         (* ret          *)
; [262] );
                db      201
                ret
; [263] 
; [264] var
; [265]   CmdLine: String absolute $80;
; [266] 
; [267] function ParamCount: Byte;
; [268] var
; [269]   C, D: Boolean;
; [270]   I, J: Byte;
; [271] begin
; var ParamCount(+6), C(-2), D(-4), I(-6), J(-8)
func51:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [272]   C := True;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,1
                ld      (hl),e
; [273]   J := 0;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,0
                ld      (hl),e
; [274] 
; [275]   for I := 1 to Length(CmdLine) do
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak54
forloop53:
; [276]   begin
; [277]     D := CmdLine[I] > ' ';
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,128          ; Get global CmdLine
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [278]     if not C and D then Inc(J);
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
                bit     0,l
                jp      z,false56
                ld      de,ix
                ld      hl,-8
                add     hl,de
                inc     (hl)
false56:
; [279]     C := D;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [280]   end;
fornext55:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak54
                ld      de,ix
                ld      hl,-6
                add     hl,de
                inc     (hl)
                jp      forloop53
forbreak54:     pop     de              ; Cleanup limit
; [281] 
; [282]   ParamCount := J;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [283] end;
exit52:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [284] 
; [285] function ParamStr(I: Byte): String;
; [286] var
; [287]   C, D: Boolean;
; [288]   J, K: Byte;
; [289] begin
; var ParamStr(+8), I(+6), C(-2), D(-4), J(-6), K(-8)
func57:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [290]   C := True;
                push    hl
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      de,1
                ld      (hl),e
; [291]   K := 1;
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      de,1
                ld      (hl),e
; [292] 
; [293]   for J := 1 to Length(CmdLine) do
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      de,1
                ld      (hl),e
                push    hl
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak60
forloop59:
; [294]   begin
; [295]     D := CmdLine[J] > ' ';
                ld      de,ix
                ld      hl,-4
                add     hl,de
                push    hl
                ld      hl,128          ; Get global CmdLine
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      hl,32           ; Literal 32
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [296] 
; [297]     if not C and D then
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [298]       K := J
                bit     0,l
                jp      z,false62
                ld      de,ix
                ld      hl,-8
                add     hl,de
; [299]     else if C and not D then
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
                jp      endif63
false62:
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      a,1
                xor     l
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [300]     begin
                bit     0,l
                jp      z,false64
; [301]       if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [302]       begin
                bit     0,l
                jp      z,false65
; [303]         Dec(J);
                ld      de,ix
                ld      hl,-6
                add     hl,de
                dec     (hl)
; [304]         Break;
                jp      forbreak60      ; Break
; [305]       end;
false65:
; [306] 
; [307]       Dec(I);
                ld      de,ix
                ld      hl,6
                add     hl,de
                dec     (hl)
; [308]     end;
false64:
endif63:
; [309] 
; [310]     C := D;
                ld      de,ix
                dec     de \ dec de
                ex      de,hl
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [311]   end;
fornext61:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak60
                ld      de,ix
                ld      hl,-6
                add     hl,de
                inc     (hl)
                jp      forloop59
forbreak60:     pop     de              ; Cleanup limit
; [312] 
; [313]   if I = 0 then
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                call    __int16_eq
                ld      h,0
                ld      l,a
; [314]     ParamStr := Copy(CmdLine, K, J - K + 1)
                bit     0,l
                jp      z,false66
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                call    __mkstr
                ld      hl,128          ; Get global CmdLine
                call    __loadstr
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,-8
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                xor     a
                sbc     hl,de
                inc     hl
; [315]   else
                push    hl
                call    __copy
; Post call cleanup 260 bytes
                ld      hl,260          ; Clear
                add     hl,sp
                ld      sp,hl
                ld      a,255
                call    __storestr
                jp      endif67
false66:
; [316]     ParamStr := '';
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
endif67:
; [317] end;
exit58:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [318] 
; [319] var
; [320]   RandSeed1: Integer absolute 'seed1';
; [321]   RandSeed2: Integer absolute 'seed2';
; [322] 
; [323] function Random(Range: Integer): Integer; register; external '__random';
; [324] function RandomReal: Real; register;                external '__random48';
; [325] 
; [326] procedure CheckBreak; register; external '__checkbreak';
; [327] 
; [328] (* Built-in: procedure FillChar(var Dest; Length: Integer; Data); *)
; [329] 
; [330] procedure Move(var Source, Dest; Count: Integer); register; external '__move';
; [331] 
; [332] (* -------------------------------------------------------------------------- *)
; [333] (* --- Assertion support ---------------------------------------------------- *)
; [334] (* -------------------------------------------------------------------------- *)
; [335] 
; [336] (* Built-in: procedure Assert(B: Boolean); *)
; [337] 
; [338] var
; [339]   AssertPassed: Integer absolute '__assertpassed';
; [340]   AssertFailed: Integer absolute '__assertfailed';
; [0] program Day19;
; [1] 
; [2] {$a+}
; [3] 
; [4] {$I /Users/joerg/Projects/pl0/lib/files.pas}
; [0] type
; [1]   FileControlBlock = record
; [2]     DR: Byte;
; [3]     FN: array[0..7] of Char;
; [4]     TN: array[0..2] of Char;
; [5]     EX, S1, S2, RC: Byte;
; [6]     AL: array[0..15] of Byte;
; [7]     CR: Byte;
; [8]     RN: array[0..2] of Byte;
; [9]   end;
; [10] 
; [11]   Text = record
; [12]     Offset: Integer;
; [13]     Writing: Boolean;
; [14]     FCB: FileControlBlock;
; [15]     DMA: array[0..127] of Char;
; [16]   end;
; [17] 
; [18] procedure InitFCB(var F: FileControlBlock; S: String);
; [19] var
; [20]   I, L, P, Q: Integer;
global74:       ds      2               ; Global I
global75:       ds      2               ; Global L
global76:       ds      2               ; Global P
global77:       ds      2               ; Global Q
; [21] begin
; var F(+262), S(+6), I(-2), L(-4), P(-6), Q(-8)
proc73:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [22]   with F do
                push    hl
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [23]   begin
; [24]     L := Length(S);
                push    de
                ld      hl,global75     ; Get global L
                push    hl
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [25] 
; [26]     if (L > 1) and (S[2] = ':') then
                ld      hl,(global75)   ; Get global L
                ex      de,hl
                push    de
                ld      hl,1            ; Literal 1
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl \ inc hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,58           ; Literal 58
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      a,l
                and     e
                ld      l,a
; [27]     begin
                bit     0,l
                jp      z,false79
; [28]       DR := Ord(UpCase(S[1])) - 64;
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                inc     hl
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ld      de,64
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e
; [29]       Delete(S, 1, 2);
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      de,1            ; Literal 1
                push    de
                ld      de,2            ; Literal 2
                push    de
                call    __delete
; Post call cleanup 6 bytes
                pop     hl
                pop     hl
                pop     hl
; [30]       Dec(L, 2);
                ld      hl,global75     ; Get global L
                push    hl
                ld      bc,2            ; Literal 2
                pop     hl
                call    __dec16by
; [31]     end
; [32]     else DR := 0;
                jp      endif80
false79:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e
endif80:
; [33] 
; [34]     P := Pos('.', S);
                ld      hl,global76     ; Get global P
                push    hl
                push    hl
                ld      de,46           ; Literal 46
                call    __char2str
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __pos
; Post call cleanup 512 bytes
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [35]     if P = 0 then P := L + 1;
                ld      hl,(global76)   ; Get global P
                ld      de,0            ; Literal 0
                call    __int16_eq
                and     a
                jp      z,false81
                ld      hl,global76     ; Get global P
                push    hl
                ld      hl,(global75)   ; Get global L
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false81:
; [36] 
; [37]     Q := P - 1;
                ld      hl,global77     ; Get global Q
                push    hl
                ld      hl,(global76)   ; Get global P
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [38]     if Q > 8 then Q := 8;
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                ld      hl,8            ; Literal 8
                pop     de
                call    __int16_lt
                and     a
                jp      z,false82
                ld      hl,global77     ; Get global Q
                ld      de,8
                ld      (hl),e \ inc hl \ ld (hl),d
false82:
; [39] 
; [40]     for I := 1 to Q do FN[I - 1] := UpCase(S[I]);
                ld      hl,global74     ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak84
forloop83:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext85:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak84
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop83
forbreak84:     pop     de              ; Cleanup limit
; [41]     for I := Q + 1 to 8 do FN[I - 1] := ' ';
                ld      hl,global74     ; Get global I
                push    hl
                ld      hl,(global77)   ; Get global Q
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,8            ; Literal 8
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak87
forloop86:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext88:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak87
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop86
forbreak87:     pop     de              ; Cleanup limit
; [42] 
; [43]     Q := L - P;
                ld      hl,global77     ; Get global Q
                push    hl
                ld      hl,(global75)   ; Get global L
                ex      de,hl
                push    de
                ld      hl,(global76)   ; Get global P
                ex      de,hl
                pop     hl
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [44]     if Q > 3 then Q := 3;
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                ld      hl,3            ; Literal 3
                pop     de
                call    __int16_lt
                and     a
                jp      z,false89
                ld      hl,global77     ; Get global Q
                ld      de,3
                ld      (hl),e \ inc hl \ ld (hl),d
false89:
; [45] 
; [46]     for I := 1 to Q do TN[I - 1] := UpCase(S[P + I]);
                ld      hl,global74     ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      hl,(global77)   ; Get global Q
                ex      de,hl
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak91
forloop90:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global76)   ; Get global P
                ex      de,hl
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    func49
                ex      de,hl
                pop     hl
                ld      (hl),e
fornext92:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak91
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop90
forbreak91:     pop     de              ; Cleanup limit
; [47]     for I := Q + 1 to 3 do TN[I - 1] := ' ';
                ld      hl,global74     ; Get global I
                push    hl
                ld      hl,(global77)   ; Get global Q
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,3            ; Literal 3
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak94
forloop93:
                ld      de,ix
                ld      hl,-10
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,9
                add     hl,de
                push    hl
                ld      hl,(global74)   ; Get global I
                ld      de,1            ; Literal 1
                xor     a
                sbc     hl,de
                ex      de,hl
                pop     hl
                add     hl,de
                ld      de,32
                ld      (hl),e
fornext95:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global74)   ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak94
                ld      hl,global74     ; Get global I
                call    __inc16
                jp      forloop93
forbreak94:     pop     de              ; Cleanup limit
; [48] (*
; [49]     Write(DR, ':');
; [50]     for I := 0 to 7 do Write(FN[I]);
; [51]     Write('.');
; [52]     for I := 0 to 2 do Write(TN[I]);
; [53]     WriteLn;
; [54] *)
; [55]   end;
                pop     bc
; [56] end;
exit78:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [57] 
; [58] procedure Assign(var T: Text; S: String);
; [59] begin
; var T(+262), S(+6)
proc96:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [60]   InitFCB(T.FCB, S);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc73
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [61] end;
exit97:         ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [62] 
; [63] procedure Reset(var T: Text);
; [64] var
; [65]   A: Integer;
global99:       ds      2               ; Global A
; [66] begin
; var T(+6), A(-2)
proc98:         push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [67]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [68]   begin
; [69]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [70]     begin
; [71]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [72]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [73]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [74]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [75]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [76]     end;
                pop     bc
; [77] 
; [78]     A := Bdos(15, Addr(T.FCB));
                ld      hl,global99     ; Get global A
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [79] 
; [80]     T.Offset := 128;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                ld      (hl),e \ inc hl \ ld (hl),d
; [81]     T.Writing := False;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      de,0
                ld      (hl),e
; [82]   end;
                pop     bc
; [83] end;
exit100:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [84] 
; [85] procedure Rewrite(var T: Text);
; [86] var
; [87]   A: Integer;
global102:      ds      2               ; Global A
; [88] begin
; var T(+6), A(-2)
proc101:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [89]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [90]   begin
; [91]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [92]     begin
; [93]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [94]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [95]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [96]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [97]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [98]     end;
                pop     bc
; [99] 
; [100]     A := Bdos(19, Addr(FCB));
                ld      hl,global102    ; Get global A
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [101]     A := Bdos(22, Addr(FCB));
                ld      hl,global102    ; Get global A
                push    hl
                ld      de,22           ; Literal 22
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [102] 
; [103]     Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [104]     Writing := True;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl
                ld      de,1
                ld      (hl),e
; [105]   end;
                pop     bc
; [106] end;
exit103:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [107] 
; [108] procedure Append(var T: Text);
; [109] var
; [110]   A: Integer;
global105:      ds      2               ; Global A
; [111] begin
; var T(+6), A(-2)
proc104:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [112]   with T do
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
; [113]   begin
; [114]     with FCB do
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
; [115]     begin
; [116]       EX := 0;
                push    hl
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,12
                add     hl,de
                ld      de,0
                ld      (hl),e
; [117]       S1 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,13
                add     hl,de
                ld      de,0
                ld      (hl),e
; [118]       S2 := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,14
                add     hl,de
                ld      de,0
                ld      (hl),e
; [119]       RC := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,15
                add     hl,de
                ld      de,0
                ld      (hl),e
; [120]       CR := 0;
                ld      de,ix
                ld      hl,-6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,32
                add     hl,de
                ld      de,0
                ld      (hl),e
; [121]     end;
                pop     bc
; [122] 
; [123]     A := Bdos(15, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,15           ; Literal 15
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [124]     A := Bdos(35, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,35           ; Literal 35
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [125]     A := Bdos(33, Addr(FCB));
                ld      hl,global105    ; Get global A
                push    hl
                ld      de,33           ; Literal 33
                push    de
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [126] 
; [127]     Offset := 0;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [128]     while Offset < 128 do
while107:
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,128          ; Literal 128
                call    __int16_lt
                ld      h,0
                ld      l,a
; [129]     begin
                bit     0,l
                jp      z,false108
; [130]       if DMA[Offset] = #26 then Exit;
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false109
                jp      exit106         ; Exit
false109:
; [131]       Inc(Offset);
                ld      de,ix
                ld      hl,-4
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __inc16
; [132]     end;
                jp      while107
false108:
; [133] 
; [134]     (* Treat 128 as file format error? *)
; [135]   end;
                pop     bc
; [136] end;
exit106:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [137] 
; [138] procedure ReadRec(var T: Text);
; [139] var
; [140]   A: Integer;
global111:      ds      2               ; Global A
; [141] begin
; var T(+6), A(-2)
proc110:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [142]   A := Bdos(26, Addr(T.DMA));
                push    hl
                ld      hl,global111    ; Get global A
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [143]   A := Bdos(20, Addr(T.FCB));
                ld      hl,global111    ; Get global A
                push    hl
                ld      de,20           ; Literal 20
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [144]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [145] end;
exit112:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [146] 
; [147] function ReadChar(var T: Text): Char;
; [148] var
; [149]   C: Char;
global114:      ds      1               ; Global C
; [150] begin
; var ReadChar(+8), T(+6), C(-2)
func113:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [151]   if T.Offset > 127 then ReadRec(T);
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false116
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc110
; Post call cleanup 2 bytes
                pop     hl
false116:
; [152]   C := T.DMA[T.Offset];
                ld      hl,global114    ; Get global C
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [153]   if C <> #26 then T.Offset := T.Offset + 1;
                ld      hl,global114    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_neq
                and     a
                jp      z,false117
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
false117:
; [154]   ReadChar := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      hl,global114    ; Get global C
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [155] end;
exit115:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [156] 
; [157] procedure ReadLine(var T: Text; var S: String);
; [158] var
; [159]   C: Char;
global119:      ds      1               ; Global C
; [160] begin
; var T(+8), S(+6), C(-2)
proc118:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [161]   S := '';
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,string68
                pop     de
                ld      a,255
                call    __movestr
; [162] 
; [163]   while Length(S) < 255 do
while121:
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                ld      de,255          ; Literal 255
                pop     hl
                call    __int16_lt
                ld      h,0
                ld      l,a
; [164]   begin
                bit     0,l
                jp      z,false122
; [165]     C := ReadChar(T);
                ld      hl,global119    ; Get global C
                push    hl
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    func113
; Post call cleanup 2 bytes
                pop     hl
                pop     de
                pop     hl
                ld      (hl),e
; [166] 
; [167]     if C = #10 then Break;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,10           ; Literal 10
                call    __int16_eq
                and     a
                jp      z,false123
                jp      false122        ; Break
false123:
; [168]     if C = #26 then Break;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                and     a
                jp      z,false124
                jp      false122        ; Break
false124:
; [169] 
; [170]     if C >= ' ' then S := S + C;
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,32           ; Literal 32
                call    __int16_geq
                and     a
                jp      z,false125
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                call    __loadstr
                ld      hl,global119    ; Get global C
                ld      d,0
                ld      e,(hl)
                call    __char2str
                call    __stradd
                call    __rmstr
                ld      a,255
                call    __storestr
false125:
; [171]   end;
                jp      while121
false122:
; [172] end;
exit120:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [173] 
; [174] procedure WriteRec(var T: Text);
; [175] var
; [176]   A: Integer;
global127:      ds      2               ; Global A
; [177] begin
; var T(+6), A(-2)
proc126:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [178]   A := Bdos(26, Addr(T.DMA));
                push    hl
                ld      hl,global127    ; Get global A
                push    hl
                ld      de,26           ; Literal 26
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [179]   A := Bdos(21, Addr(T.FCB));
                ld      hl,global127    ; Get global A
                push    hl
                ld      de,21           ; Literal 21
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [180]   T.Offset := 0;
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,0            ; Literal 0
                ld      (hl),e \ inc hl \ ld (hl),d
; [181] end;
exit128:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [182] 
; [183] 
; [184] procedure WriteChar(var T: Text; C: Char);
; [185] begin
; var T(+8), C(+6)
proc129:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [186]   if T.Offset > 127 then WriteRec(T);
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false131
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc126
; Post call cleanup 2 bytes
                pop     hl
false131:
; [187]   T.DMA[T.Offset] := C;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                ld      (hl),e
; [188]   T.Offset := T.Offset + 1;
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [189] end;
exit130:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [190] 
; [191] procedure WriteLine(var T: Text; S: String);
; [192] var
; [193]   I: Integer;
global133:      ds      2               ; Global I
; [194] begin
; var T(+262), S(+6), I(-2)
proc132:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [195]   for I := 1 to Length(S) do WriteChar(T, S[I]);
                push    hl
                ld      hl,global133    ; Get global I
                ld      de,1
                ld      (hl),e \ inc hl \ ld (hl),d
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    __length
; Post call cleanup 256 bytes
                call    __rmstr
                pop     de              ; Dup and pre-check limit
                push    de
                push    de
                ld      hl,(global133)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak136
forloop135:
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global133)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
fornext137:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global133)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak136
                ld      hl,global133    ; Get global I
                call    __inc16
                jp      forloop135
forbreak136:    pop     de              ; Cleanup limit
; [196] 
; [197]   WriteChar(T, #13);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,13           ; Literal 13
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [198]   WriteChar(T, #10);
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,10           ; Literal 10
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [199] end;
exit134:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [200] 
; [201] function IsEof(var T: Text): Boolean;
; [202] begin
; var IsEof(+8), T(+6)
func138:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [203]   if T.Offset > 127 then ReadRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      hl,127          ; Literal 127
                pop     de
                call    __int16_lt
                and     a
                jp      z,false140
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc110
; Post call cleanup 2 bytes
                pop     hl
false140:
; [204]   IsEof := T.DMA[T.Offset] = #26;
                ld      de,ix
                ld      hl,8
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,39           ; Literal 39
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,26           ; Literal 26
                call    __int16_eq
                ld      h,0
                ld      l,a
                ex      de,hl
                pop     hl
                ld      (hl),e
; [205] end;        
exit139:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [206] 
; [207] procedure Close(var T: Text);
; [208] var
; [209]   A: Integer;
global142:      ds      2               ; Global A
; [210] begin
; var T(+6), A(-2)
proc141:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [211]   if T.Writing then
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                inc     hl \ inc hl     ; Literal 2
                ld      d,0
                ld      e,(hl)
; [212]   begin
                ex      de,hl
                bit     0,l
                jp      z,false144
; [213]     WriteChar(T, #26);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                ld      de,26           ; Literal 26
                push    de
                call    proc129
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [214]     WriteRec(T);
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                push    de
                call    proc126
; Post call cleanup 2 bytes
                pop     hl
; [215]   end;
false144:
; [216] 
; [217]   A := Bdos(16, Addr(T.FCB));
                ld      hl,global142    ; Get global A
                push    hl
                ld      de,16           ; Literal 16
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [218] end;
exit143:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [219] 
; [220] procedure Erase(var T: Text);
; [221] var
; [222]   A: Integer;
global146:      ds      2               ; Global A
; [223] begin
; var T(+6), A(-2)
proc145:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [224]   A := Bdos(19, Addr(T.FCB));
                push    hl
                ld      hl,global146    ; Get global A
                push    hl
                ld      de,19           ; Literal 19
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [225] end;
exit147:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [226] 
; [227] procedure Rename(var T: Text; S: String);
; [228] var
; [229]   F: FileControlBlock;
; [230]   A: Integer;
global149:      ds      2               ; Global A
; [231] begin
; var T(+262), S(+6), F(-36), A(-38)
proc148:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-38          ; Space
                add     hl,sp
                ld      sp,hl
; [232]   InitFCB(F, S);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc73
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [233]   Move(F, T.FCB.AL, 12);
                ld      de,ix
                ld      hl,-36
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ld      de,16
                add     hl,de
                push    hl
                ld      bc,12           ; Literal 12
                pop     de
                pop     hl
                call    __move
; [234]   A := Bdos(23, Addr(T.FCB));
                ld      hl,global149    ; Get global A
                push    hl
                ld      de,23           ; Literal 23
                push    de
                ld      de,ix
                ld      hl,262
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                ex      de,hl
                ld      de,3            ; Literal 3
                add     hl,de
                ex      de,hl
                pop     hl
                push    ix
                ld      c,l
                call    5
                pop     ix
                ld      l,a
                ld      h,0
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [235] end;
exit150:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [5] 
; [6] type
; [7]   SchematicPtr = ^Schematic;
; [8]   Schematic = record
; [9]     Heights: array[0..4] of Byte;
; [10]     Next: SchematicPtr;
; [11]   end;
; [12] 
; [13] var
; [14]   Locks, Keys: SchematicPtr;
global151:      ds      2               ; Global Locks
global152:      ds      2               ; Global Keys
; [15] 
; [16] procedure Load(Path: String);
; [17] var
; [18]   T: Text;
; [19]   S: String;
; [20]   P: SchematicPtr;
global154:      ds      2               ; Global P
; [21]   I, J, KC, LC: Byte;
global155:      ds      1               ; Global I
global156:      ds      1               ; Global J
global157:      ds      1               ; Global KC
global158:      ds      1               ; Global LC
; [22]   IsLock: Boolean;
global159:      ds      1               ; Global IsLock
; [23] begin
; var Path(+6), T(-167), S(-423), P(-425), I(-427), J(-429), KC(-431), LC(-433), IsLock(-435)
proc153:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                ld      hl,-435         ; Space
                add     hl,sp
                ld      sp,hl
; [24]   Locks := nil;
                ld      hl,global151    ; Get global Locks
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [25]   Keys := nil;
                ld      hl,global152    ; Get global Keys
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [26] 
; [27]   KC := 0;
                ld      hl,global157    ; Get global KC
                ld      de,0
                ld      (hl),e
; [28]   LC := 0;
                ld      hl,global158    ; Get global LC
                ld      de,0
                ld      (hl),e
; [29] 
; [30]   Assign(T, Path);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                call    __loadstr
                call    proc96
; Post call cleanup 258 bytes
                ld      hl,258          ; Clear
                add     hl,sp
                ld      sp,hl
; [31]   Reset(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc98
; Post call cleanup 2 bytes
                pop     hl
; [32] 
; [33]   while not IsEof(T) do
while161:
                ld      de,0            ; Literal 0
                push    de
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    func138
; Post call cleanup 2 bytes
                pop     hl
                pop     hl              ; Not
                ld      a,1
                xor     l
                ld      l,a
; [34]   begin
                bit     0,l
                jp      z,false162
; [35]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [36]     IsLock := S = '#####';
                ld      hl,global159    ; Get global IsLock
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                call    __loadstr
                ld      hl,string163
                call    __loadstr
                call    __streq
                ld      hl,512          ; Clear
                add     hl,sp
                ld      sp,hl
                pop     hl
                ld      (hl),e
; [37] 
; [38]     New(P);
                ld      hl,global154    ; Get global P
                ld      de,7
                call    __getmem
; [39]     for I := 0 to 4 do
                ld      hl,global155    ; Get global I
                ld      de,0
                ld      (hl),e
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,global155    ; Get global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak165
forloop164:
; [40]       P^.Heights[I] := 0;
                ld      hl,global154    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global155    ; Get global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                ld      de,0
                ld      (hl),e
fornext166:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global155    ; Get global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak165
                ld      hl,global155    ; Get global I
                inc     (hl)
                jp      forloop164
forbreak165:    pop     de              ; Cleanup limit
; [41] 
; [42]     for I := 0 to 4 do
                ld      hl,global155    ; Get global I
                ld      de,0
                ld      (hl),e
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,global155    ; Get global I
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak168
forloop167:
; [43]     begin
; [44]       ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [45]       for J := 0 to 4 do
                ld      hl,global156    ; Get global J
                ld      de,0
                ld      (hl),e
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,global156    ; Get global J
                ld      d,0
                ld      e,(hl)
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak171
forloop170:
; [46]         if S[J +  1] = '#' then 
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                ld      hl,global156    ; Get global J
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                ld      de,35           ; Literal 35
                call    __int16_eq
                ld      h,0
                ld      l,a
; [47]           Inc(P^.Heights[J]);
                bit     0,l
                jp      z,false173
                ld      hl,global154    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,global156    ; Get global J
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                inc     (hl)
false173:
fornext172:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global156    ; Get global J
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak171
                ld      hl,global156    ; Get global J
                inc     (hl)
                jp      forloop170
forbreak171:    pop     de              ; Cleanup limit
; [48]     end;
fornext169:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,global155    ; Get global I
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak168
                ld      hl,global155    ; Get global I
                inc     (hl)
                jp      forloop167
forbreak168:    pop     de              ; Cleanup limit
; [49] 
; [50]     (*for I := 0 to 4 do
; [51]       Write(P^.Heights[I], ' ');
; [52]     WriteLn;*)
; [53] 
; [54]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [55]     ReadLine(T, S);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                ld      de,ix
                ld      hl,-423
                add     hl,de
                push    hl
                call    proc118
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [56] 
; [57]     if IsLock then
                ld      hl,global159    ; Get global IsLock
                ld      d,0
                ld      e,(hl)
; [58]     begin
                ex      de,hl
                bit     0,l
                jp      z,false174
; [59]       P^.Next := Locks;
                ld      hl,global154    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,5            ; Literal 5
                add     hl,de
                push    hl
                ld      hl,(global151)  ; Get global Locks
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [60]       Locks := P;
                ld      hl,global151    ; Get global Locks
                push    hl
                ld      hl,(global154)  ; Get global P
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [61]       Inc(LC);
                ld      hl,global158    ; Get global LC
                inc     (hl)
; [62]       GotoXY(9, 4); Write(LC);
                ld      hl,9            ; Literal 9
                ld      de,4            ; Literal 4
                call    __gotoxy
                ld      hl,global158    ; Get global LC
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __putn
; [63]     end
; [64]     else
                jp      endif175
false174:
; [65]     begin
; [66]       P^.Next := Keys;
                ld      hl,global154    ; Get global P
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,5            ; Literal 5
                add     hl,de
                push    hl
                ld      hl,(global152)  ; Get global Keys
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [67]       Keys := P;
                ld      hl,global152    ; Get global Keys
                push    hl
                ld      hl,(global154)  ; Get global P
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [68]       Inc(KC);
                ld      hl,global157    ; Get global KC
                inc     (hl)
; [69]       GotoXY(9, 3); Write(KC);
                ld      hl,9            ; Literal 9
                ld      de,3            ; Literal 3
                call    __gotoxy
                ld      hl,global157    ; Get global KC
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                call    __putn
; [70]     end;
endif175:
; [71]   end;
                jp      while161
false162:
; [72] 
; [73]   Close(T);
                ld      de,ix
                ld      hl,-167
                add     hl,de
                push    hl
                call    proc141
; Post call cleanup 2 bytes
                pop     hl
; [74] end;
exit160:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [75] 
; [76] function Fits(L, K: SchematicPtr): Boolean;
; [77] var
; [78]   I: Integer;
global177:      ds      2               ; Global I
; [79] begin
; var Fits(+10), L(+8), K(+6), I(-2)
func176:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
; [80]   Fits := False;
                push    hl
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,0
                ld      (hl),e
; [81] 
; [82]   for I := 0 to 4 do
                ld      hl,global177    ; Get global I
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,(global177)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak180
forloop179:
; [83]     if L^.Heights[I] + K^.Heights[I] > 5 then
                ld      de,ix
                ld      hl,8
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global177)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global177)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                pop     hl
                add     hl,de
                push    hl
                ld      hl,5            ; Literal 5
                pop     de
                call    __int16_lt
                ld      h,0
                ld      l,a
; [84]       Exit;
                bit     0,l
                jp      z,false182
                jp      exit178         ; Exit
false182:
fornext181:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global177)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak180
                ld      hl,global177    ; Get global I
                call    __inc16
                jp      forloop179
forbreak180:    pop     de              ; Cleanup limit
; [85] 
; [86]   Fits := True;
                ld      de,ix
                ld      hl,10
                add     hl,de
                ld      de,1
                ld      (hl),e
; [87] end;
exit178:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [88] 
; [89] procedure ShowLock(L: SchematicPtr);
; [90] var
; [91]   I, J: Integer;
global184:      ds      2               ; Global I
global185:      ds      2               ; Global J
; [92] begin
; var L(+6), I(-2), J(-4)
proc183:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [93]   for I := 0 to 4 do
                push    hl
                ld      hl,global184    ; Get global I
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,(global184)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak188
forloop187:
; [94]   begin
; [95]     GotoXY(20, 10 + I);
                ld      de,20           ; Literal 20
                push    de
                ld      de,10           ; Literal 10
                push    de
                ld      hl,(global184)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    __gotoxy
; [96]     for J := 0 to L^.Heights[I] do
                ld      hl,global185    ; Get global J
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global184)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                push    de
                ld      hl,(global185)  ; Get global J
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak191
forloop190:
; [97]       Write('#');
                ld      a,35            ; Literal 35
                call    __putc
fornext192:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global185)  ; Get global J
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak191
                ld      hl,global185    ; Get global J
                call    __inc16
                jp      forloop190
forbreak191:    pop     de              ; Cleanup limit
; [98]     for J := L^.Heights[I] + 1 to 7 do
                ld      hl,global185    ; Get global J
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global184)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,7            ; Literal 7
                push    de
                push    de
                ld      hl,(global185)  ; Get global J
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak194
forloop193:
; [99]       Write(' ');
                ld      a,32            ; Literal 32
                call    __putc
fornext195:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global185)  ; Get global J
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak194
                ld      hl,global185    ; Get global J
                call    __inc16
                jp      forloop193
forbreak194:    pop     de              ; Cleanup limit
; [100]   end;
fornext189:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global184)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak188
                ld      hl,global184    ; Get global I
                call    __inc16
                jp      forloop187
forbreak188:    pop     de              ; Cleanup limit
; [101] end;
exit186:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [102] 
; [103] procedure ShowKey(L: SchematicPtr);
; [104] var
; [105]   I, J: Integer;
global197:      ds      2               ; Global I
global198:      ds      2               ; Global J
; [106] begin
; var L(+6), I(-2), J(-4)
proc196:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
; [107]   for I := 0 to 4 do
                push    hl
                ld      hl,global197    ; Get global I
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,4            ; Literal 4
                push    de
                push    de
                ld      hl,(global197)  ; Get global I
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak201
forloop200:
; [108]   begin
; [109]     GotoXY(30, 10 + I);
                ld      de,30           ; Literal 30
                push    de
                ld      de,10           ; Literal 10
                push    de
                ld      hl,(global197)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ex      de,hl
                pop     hl
                call    __gotoxy
; [110]     for J := L^.Heights[I] + 1 to 7 do
                ld      hl,global198    ; Get global J
                push    hl
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global197)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                ex      de,hl
                inc     hl              ; Literal 1
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,7            ; Literal 7
                push    de
                push    de
                ld      hl,(global198)  ; Get global J
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak204
forloop203:
; [111]       Write(' ');
                ld      a,32            ; Literal 32
                call    __putc
fornext205:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global198)  ; Get global J
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak204
                ld      hl,global198    ; Get global J
                call    __inc16
                jp      forloop203
forbreak204:    pop     de              ; Cleanup limit
; [112]     for J := 0 to L^.Heights[I] do
                ld      hl,global198    ; Get global J
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
                ld      de,ix
                ld      hl,6
                add     hl,de
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                push    de
                ld      hl,(global197)  ; Get global I
                ex      de,hl
                pop     hl
                add     hl,de
                ld      d,0
                ld      e,(hl)
                push    de
                push    de
                ld      hl,(global198)  ; Get global J
                ex      de,hl
                pop     hl
                call    __int16_geq
                and     a
                jp      z,forbreak207
forloop206:
; [113]       Write('#');
                ld      a,35            ; Literal 35
                call    __putc
fornext208:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global198)  ; Get global J
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak207
                ld      hl,global198    ; Get global J
                call    __inc16
                jp      forloop206
forbreak207:    pop     de              ; Cleanup limit
; [114]   end;
fornext202:
                pop     de              ; Dup and check limit
                push    de
                push    de
                ld      hl,(global197)  ; Get global I
                pop     de
                call    __int16_lt
                and     a
                jp      z,forbreak201
                ld      hl,global197    ; Get global I
                call    __inc16
                jp      forloop200
forbreak201:    pop     de              ; Cleanup limit
; [115] end;
exit199:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [116] 
; [117] function Solve: Integer;
; [118] var
; [119]   Result, KKK: Integer;
global210:      ds      2               ; Global Result
global211:      ds      2               ; Global KKK
; [120]   L, K: SchematicPtr;
global212:      ds      2               ; Global L
global213:      ds      2               ; Global K
; [121] begin
; var Solve(+6), Result(-2), KKK(-4), L(-6), K(-8)
func209:        push    ix              ; Prologue
                ld      hl,(display+4)
                push    hl
                ld      ix,0
                add     ix,sp
                ld      (display+4),ix
                push    hl
                push    hl
                push    hl
; [122]   Result := 0;
                push    hl
                ld      hl,global210    ; Get global Result
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [123] 
; [124]   L := Locks;
                ld      hl,global212    ; Get global L
                push    hl
                ld      hl,(global151)  ; Get global Locks
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [125]   while L <> nil do
while215:
                ld      hl,(global212)  ; Get global L
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [126]   begin
                bit     0,l
                jp      z,false216
; [127]     ShowLock(L);
                ld      hl,(global212)  ; Get global L
                ex      de,hl
                push    de
                call    proc183
; Post call cleanup 2 bytes
                pop     hl
; [128]     KKK := 0;
                ld      hl,global211    ; Get global KKK
                ld      de,0
                ld      (hl),e \ inc hl \ ld (hl),d
; [129] 
; [130]     K := Keys;
                ld      hl,global213    ; Get global K
                push    hl
                ld      hl,(global152)  ; Get global Keys
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [131]     while K <> nil do
while217:
                ld      hl,(global213)  ; Get global K
                ld      de,0            ; Literal 0
                call    __int16_neq
                ld      h,0
                ld      l,a
; [132]     begin
                bit     0,l
                jp      z,false218
; [133]       ShowKey(K);
                ld      hl,(global213)  ; Get global K
                ex      de,hl
                push    de
                call    proc196
; Post call cleanup 2 bytes
                pop     hl
; [134]       if Fits(L, K) then
                ld      de,0            ; Literal 0
                push    de
                ld      hl,(global212)  ; Get global L
                ex      de,hl
                push    de
                ld      hl,(global213)  ; Get global K
                ex      de,hl
                push    de
                call    func176
; Post call cleanup 4 bytes
                pop     hl
                pop     hl
; [135]       begin
                pop     hl
                bit     0,l
                jp      z,false219
; [136]         Inc(Result);
                ld      hl,global210    ; Get global Result
                call    __inc16
; [137]         Inc(KKK);
                ld      hl,global211    ; Get global KKK
                call    __inc16
; [138]       end;
false219:
; [139] 
; [140]       K := K^.Next;
                ld      hl,global213    ; Get global K
                push    hl
                ld      hl,global213    ; Get global K
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,5            ; Literal 5
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [141]     end;
                jp      while217
false218:
; [142] 
; [143]     (*WriteLn(KKK);*)
; [144]   
; [145]     L := L^.Next;
                ld      hl,global212    ; Get global L
                push    hl
                ld      hl,global212    ; Get global L
                ld      e,(hl)
                inc     hl
                ld      d,(hl)
                ex      de,hl
                ld      de,5            ; Literal 5
                add     hl,de
                ld      e,(hl) \ inc hl \ ld d,(hl)
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [146]   end;
                jp      while215
false216:
; [147] 
; [148]   Solve := Result;
                ld      de,ix
                ld      hl,6
                add     hl,de
                push    hl
                ld      hl,(global210)  ; Get global Result
                ex      de,hl
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [149] end;
exit214:        ld      sp,ix           ; Epilogue
                pop     hl
                ld      (display+4),hl
                pop     ix
                ret
; [150] 
; [151] var
; [152]   Part1: Integer;
global220:      ds      2               ; Global Part1
; [153] 
; [154] begin
; var Locks(0), Keys(0), Part1(0)
main:           call    __init
                ld      ix,0
                add     ix,sp
; [155]   (* ClrScr; *)
; [156] 
; [157]   WriteLn('*** AoC 2024.25 Code Chronicle ***');
                ld      hl,string222
                call    __puts
                call    __newline
; [158]   WriteLn;
                call    __newline
; [159]   WriteLn('Keys:  ');
                ld      hl,string223
                call    __puts
                call    __newline
; [160]   WriteLn('Locks: ');
                ld      hl,string224
                call    __puts
                call    __newline
; [161]   WriteLn;
                call    __newline
; [162]   WriteLn('Part 1:');
                ld      hl,string225
                call    __puts
                call    __newline
; [163] 
; [164]   InitHeap(49152);
                ld      de,49152        ; Literal 49152
                push    de
                call    proc16
; Post call cleanup 2 bytes
                pop     hl
; [165] 
; [166]   Load('INPUT   .TXT');
                ld      hl,string226
                call    __loadstr
                call    proc153
; Post call cleanup 256 bytes
                call    __rmstr
; [167]   Part1 := Solve;
                ld      hl,global220    ; Get global Part1
                push    hl
                push    hl
                call    func209
                pop     de
                pop     hl
                ld      (hl),e \ inc hl \ ld (hl),d
; [168] 
; [169]   WriteLn('Part 1: ', Part1);
                ld      hl,string227
                call    __puts
                ld      hl,(global220)  ; Get global Part1
                call    __putn
                call    __newline
; [170] end.
exit221:        call    __done
                ret
string68:       db      0
string163:      db      5,"#####"
string222:      db      34,"*** AoC 2024.25 Code Chronicle ***"
string223:      db      7,"Keys:  "
string224:      db      7,"Locks: "
string225:      db      7,"Part 1:"
string226:      db      12,"INPUT   .TXT"
string227:      db      8,"Part 1: "
display:        ds      32              ; Display
eof:                                    ; End of file
; HEAP:
; end
